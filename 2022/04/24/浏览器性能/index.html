<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="fx" />
  <meta name="description" content="" />
  
  
  <title>
    
      浏览器 
      
      
      |
    
     F blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/welcome.jfif">
    <link rel="icon" href="/images/welcome.jfif">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 5.4.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/welcome.jfif" alt="">
      
    </a>
    <div class="nickname"><a href="/">F</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">浏览器</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="Update time"></i>
          2022-04-24 15:17:06
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="Tags"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" title="浏览器">
                    <b>#</b> 浏览器
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="浏览器的缓存"><a href="#浏览器的缓存" class="headerlink" title="浏览器的缓存"></a>浏览器的缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>检查强缓存，这个阶段<strong>不需要</strong>发送HTTP请求。</p>
<p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。在早期，也就是<code>HTTP/1.0</code>时期，使用的是<strong>Expires</strong>，而<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。过期了就得向服务端发请求。</p>
<p>缺点:<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP1.1中，采用了一个非常关键的字段：<code>Cache-Control</code>。采用过期时长来控制缓存，对应的字段是<strong>max-age</strong>。除了max-age还可以配合一下字段</p>
<p><strong>public</strong>: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<code>代理服务器</code>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</p>
<p><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</p>
<p><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</p>
<p><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。</p>
<p>值得注意的是，当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p>
<p>当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——<strong>协商缓存</strong>了。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。</p>
<h3 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h3><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p>
<p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p>
<ul>
<li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<h3 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<code>响应头</code>把这个值给浏览器。</p>
<p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<strong>If-None-Match</strong>这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对: - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。 - 否则返回304，告诉浏览器直接用缓存。</p>
<p>如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p>
<ul>
<li>Service Worker 主要用在离线缓存</li>
<li>Memory Cache 内存缓存</li>
<li>Disk Cache 磁盘缓存</li>
<li>Push Cache 推送缓存</li>
</ul>
<p>主要策略如下： 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存.内存使用率比较高的时候，文件优先进入磁盘</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用 - 如果强缓存可用，直接使用 - 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段检查资源是否更新 - 若资源更新，返回资源和200状态码 - 否则，返回304，告诉浏览器直接从缓存获取资源</p>
<h1 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h1><ul>
<li><strong>浏览器进程</strong>：主要负责tab页的管理。</li>
<li><strong>浏览器渲染进程</strong>：负责页面的渲染，每个tab页都会有浏览器渲染进程</li>
<li><strong>GPU进程</strong>：主要用于3D绘制，例如使用canvas进行3D绘图</li>
<li><strong>插件进程</strong>：插件运行在插件进程，每个不同的插件都会运行在一个新的进程</li>
</ul>
<h1 id="输入url到页面呈现"><a href="#输入url到页面呈现" class="headerlink" title="输入url到页面呈现"></a>输入url到页面呈现</h1><h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><ol>
<li>构建请求</li>
<li>查找强缓存 如果命中则直接使用</li>
<li>DNS解析 得到域名对应的ip地址,浏览器提供了<strong>DNS数据缓存功能</strong>。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 <code>DNS解析</code>。</li>
<li>建立TCP连接 </li>
<li>发送http请求</li>
<li>响应http 响应完成之后要判断<code>Connection</code>字段, 如果请求头或响应头中包含<strong>Connection: Keep-Alive</strong>，表示建立了持久连接，这样<code>TCP</code>连接会一直保持，之后请求统一站点的资源会复用这个连接。</li>
</ol>
<h2 id="解析渲染篇"><a href="#解析渲染篇" class="headerlink" title="解析渲染篇"></a>解析渲染篇</h2><ol>
<li>解析HTML，生成DOM树</li>
<li>解析css，生成渲染树(包含width,颜色等) CSSOM tree</li>
<li>将HTML DOM树与CSS规则树结合,生成生成Render tree</li>
<li>布局Render树（layout/reflow），负责各元素大小、位置的计算</li>
<li>绘制Render树（painting），绘制页面像素信息</li>
<li>浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</li>
</ol>
<h1 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h1><h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><p>重排也叫回流</p>
<p>简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生<code>回流</code>的过程。</p>
<p>有以下的操作会触发回流:</p>
<ol>
<li>一个 DOM 元素的几何属性变化，常见的几何属性有<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>left</code>、<code>top</code>、<code>border</code> 等等, 这个很好理解。</li>
<li>使 DOM 节点发生<code>增减</code>或者<code>移动</code>。</li>
<li>读写 <code>offset</code>族、<code>scroll</code>族和<code>client</code>族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li>
<li>调用 <code>window.getComputedStyle</code> 方法。</li>
</ol>
<p>过程:如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致<code>重绘</code>(<code>repaint</code>)。</p>
<p>由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程只会出发计算css样式并绘制</p>
<p>重绘不一定导致回流，但回流一定发生了重绘。</p>
<h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>还有一种情况，是直接合成。比如利用 CSS3 的<code>transform</code>、<code>opacity</code>、<code>filter</code>这些属性就可以实现合成的效果，也就是大家常说的<strong>GPU加速</strong>。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol>
<li>避免频繁使用 style，而是采用修改<code>class</code>的方式。</li>
<li>使用<code>createDocumentFragment</code>进行批量的 DOM 操作。</li>
<li>对于 resize、scroll 等进行防抖/节流处理。</li>
<li>添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于<code>tranform</code>, 任何可以实现合成效果的 CSS 属性都能用<code>will-change</code>来声明。这行代码能够开启 GPU 加速页面渲染，从而大大降低了 CPU 的负载压力，达到优化页面渲染性能的目的</li>
</ol>
<h1 id="js和css阻塞"><a href="#js和css阻塞" class="headerlink" title="js和css阻塞"></a>js和css阻塞</h1><p>load事件：load 应该仅用于检测一个完全加载的页面 当一个资源及其依赖资源已完成加载时，将触发load事件。也就是说，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。</p>
<p>DOMContentLoaded事件：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。也就是说，DOM 树已经构建完毕就会触发 DOMContentLoaded 事件。</p>
<h2 id="js阻塞了什么"><a href="#js阻塞了什么" class="headerlink" title="js阻塞了什么"></a>js阻塞了什么</h2><ul>
<li>js是否会阻塞dom树构建</li>
</ul>
<p>因为js在执行的过程中可能会操作DOM，发生回流和重绘，所以GUI渲染线程与JS引擎线程是互斥的。</p>
<p>在解析HTML过程中，如果遇到 script 标签，渲染线程会暂停渲染过程，将控制权交给 JS 引擎。内联的js代码会直接执行，如果是js外部文件，则要下载该js文件，下载完成之后再执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染线程，继续 DOM 的解析。</p>
<p>因此，<strong>js会阻塞DOM树的构建</strong>。</p>
<ul>
<li>是否会阻塞页面的显示呢？</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码,页面中会先显示hello world,然后遇到script标签则导致阻塞渲染,运行js代码,js代码完成后会再显示hello world2</p>
<p>js不会阻塞位于它之前的dom元素的渲染。现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有DOM解析完成后才布局渲染树。而是当js阻塞发生时，会将已经构建好的DOM元素渲染到屏幕上，减少白屏的时间。</p>
<p>这也是为什么我们会将script标签放到body标签的底部，因为这样就不会影响前面的页面的渲染。</p>
<h2 id="css阻塞了什么"><a href="#css阻塞了什么" class="headerlink" title="css阻塞了什么"></a>css阻塞了什么</h2><p>当我们解析 HTML 时遇到 link 标签或者 style 标签时，就会计算样式，构建CSSOM。</p>
<p><strong>css不会阻塞dom树的构建，但是会阻塞页面的显示</strong>。</p>
<ul>
<li>会不会阻塞DOM树的构建</li>
</ul>
<p><strong>css不会阻塞dom树的构建.但是浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容</strong>。即便 DOM 已经解析完毕了，只要 CSSOM 不没构建好，页面也不会显示内容。</p>
<p>只有当我们遇到 link 标签或者 style 标签时，才会构建CSSOM，所以如果 link 标签之前有dom元素，会加载css发生阻塞,如下面的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样做会导致一个问题，就是页面闪烁，在css被加载之前，浏览器按照默认样式渲染 <div class="woo-spinner-filled">hello world</div>，当css加载完成，会为该div计算新的样式，重新渲染，出现闪烁的效果。</p>
<p>为了避免页面闪烁，通常 link 标签都放在head中。</p>
<p>下面的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码,DOMContentLoaded事件会在30ms左右就完成,也就是说DOM树会在30ms就构建完成,但是在30ms时页面此时依然是空白;而loaded事件会在2.92s发生,并且页面才出现内容.也就是说这时候资源全部加载完毕.由此可见,在head中的link标签加载css较费时,但是不会阻塞DOM树的构建,会阻塞页面的渲染.</p>
<ul>
<li>css会不会阻塞后面js执行</li>
</ul>
<p>答案是会.</p>
<p>JS 的作用在于修改，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。当在JS中访问了CSSDOM中某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行JS脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a test&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子，就会发现等css加载完成后，才会在控制台打印“this is a test”。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>(1)js</p>
<ul>
<li>js既会阻塞dom树的构建,也会阻塞页面的渲染</li>
</ul>
<p>(2)css</p>
<ul>
<li><p>css不会阻塞dom树的构建(DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析)</p>
</li>
<li><p><strong>style不会</strong>阻塞页面的渲染(dom会先展示但是没有任何样式,当加载完css后才显示样式,因此会造成<strong>闪屏现象</strong>)</p>
</li>
<li><p><strong>link会</strong>阻塞页面的渲染(dom树解析完也不会进行任何渲染,当加载完link后才显示合并cssom一起显示,因此会造成<strong>白屏现象</strong>)</p>
</li>
<li><p>css会阻塞后面js的执行</p>
</li>
</ul>
<p>(3)link和@import的区别</p>
<ul>
<li>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；</li>
<li><strong>加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载</strong>；因此可能造成闪屏现象</li>
<li>link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；</li>
<li>可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="对称和非对称加密结合"><a href="#对称和非对称加密结合" class="headerlink" title="对称和非对称加密结合"></a>对称和非对称加密结合</h2><p>演示一下整个流程： 1. 浏览器向服务器发送<code>client_random</code>和加密方法列表。 2. 服务器接收到，返回<code>server_random</code>、加密方法以及公钥。 3. 浏览器接收，接着生成另一个随机数<code>pre_random</code>, 并且用公钥加密，传给服务器。(敲黑板！重点操作！) 4. 服务器用私钥解密这个被加密后的<code>pre_random</code>。</p>
<p>现在浏览器和服务器有三样相同的凭证:<code>client_random</code>、<code>server_random</code>和<code>pre_random</code>。然后两者用相同的加密方法混合这三个随机数，生成最终的<code>密钥</code>。</p>
<p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用<code>对称加密</code>。</p>
<p>缺点:尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p>
<h2 id="添加数字证书"><a href="#添加数字证书" class="headerlink" title="添加数字证书"></a>添加数字证书</h2><p>添加了<code>数字证书认证</code>的步骤。其目的就是让服务器证明自己的身份。为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫<code>CA</code>(<code>Certificate Authority</code>), 认证通过后 CA 会给服务器颁发<strong>数字证书</strong>。</p>
<p>这个数字证书有两个作用: 1. 服务器向浏览器证明自己的身份。 2. 把公钥传给浏览器。</p>
<p>这个验证的过程发生在什么时候呢？</p>
<p>当服务器传送<code>server_random</code>、加密方法的时候，顺便会带上<code>数字证书</code>(包含了<code>公钥</code>), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p>
<h2 id="HTTPS加解密过程"><a href="#HTTPS加解密过程" class="headerlink" title="HTTPS加解密过程"></a>HTTPS加解密过程</h2><img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220525213117645.png" alt="image-20220525213117645" style="zoom:80%;">

<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>在JavaScript中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。</p>
<ul>
<li>基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的</li>
<li>引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。</li>
</ul>
<p>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是<code>操作系统自动分配和释放回收的</code></p>
<p>由于堆内存所存大小不固定，系统<code>无法自动释放回收</code>，所以需要<code>JS引擎来手动释放这些内存</code></p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 </span></span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; <span class="comment">// A 的引用个数变为 2</span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 1</span></span><br><span class="line">obj2 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>

<p>但是引用计数有个最大的问题： 循环引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p>
<p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p>
<p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p>
<h2 id="V8的垃圾回收算法"><a href="#V8的垃圾回收算法" class="headerlink" title="V8的垃圾回收算法"></a>V8的垃圾回收算法</h2><p>那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？</p>
<p>对于这个问题，V8做了<strong>分代回收</strong>的优化方法，通俗点说就是：<strong>V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方</strong></p>
<p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。</p>
<p><code>Scavange算法</code>将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用。</p>
<img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133234703.png" alt="image-20220530133234703" style="zoom: 33%;">

<p>新生代中的对象什么时候变成老生代的对象？</p>
<p>在新生代中，还进一步进行了细分。分为<code>nursery子代</code>和<code>intermediate子代</code>两个区域，一个对象第一次分配内存时会被分配到新生代中的<code>nursery子代</code>，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到<code>intermediate子代</code>，在经过下一次垃圾回收，如果这个对象还在新生代中，<code>副垃圾回收器</code>会将该对象移动到老生代中，这个移动的过程被称为<code>晋升</code></p>
<h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>老生代里，回收算法不宜使用<code>Scavenge算法</code>，为啥呢，有以下原因：</p>
<ul>
<li><code>Scavenge算法</code>是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低</li>
<li><code>Scavenge算法</code>是以空间换时间的算法，老生代是内存很大的空间，如果使用<code>Scavenge算法</code>，空间资源非常浪费，得不偿失啊。。</li>
</ul>
<p>所以老生代里使用了<code>Mark-Sweep算法(标记清理)</code>和<code>Mark-Compact算法(标记整理)</code></p>
<h4 id="Mark-Sweep-标记清理"><a href="#Mark-Sweep-标记清理" class="headerlink" title="Mark-Sweep(标记清理)"></a>Mark-Sweep(标记清理)</h4><p><code>Mark-Sweep</code>分为两个阶段，标记和清理阶段，之前的<code>Scavenge算法</code>也有标记和清理，但是<code>Mark-Sweep算法</code>跟<code>Scavenge算法</code>的区别是，后者需要复制后再清理，前者不需要，<code>Mark-Sweep</code>直接标记活动对象和非活动对象之后，就直接执行清理了。</p>
<ul>
<li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li>
<li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象</li>
</ul>
<img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133626739.png" alt="image-20220530133626739" style="zoom: 33%;">

<p>由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多<code>零零散散的空位</code>。</p>
<h4 id="Mark-Compact-标记整理"><a href="#Mark-Compact-标记整理" class="headerlink" title="Mark-Compact(标记整理)"></a>Mark-Compact(标记整理)</h4><p>这个时候<code>Mark-Compact算法</code>出现了，他是<code>Mark-Sweep算法</code>的加强版，在<code>Mark-Sweep算法</code>的基础上，加上了<code>整理阶段</code>，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存</p>
<img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133811523.png" alt="image-20220530133811523" style="zoom:33%;">

<h3 id="全停顿-Stop-The-World"><a href="#全停顿-Stop-The-World" class="headerlink" title="全停顿(Stop-The-World)"></a>全停顿(Stop-The-World)</h3><p>说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，<code>垃圾回收优先于代码执行</code>，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为<code>全停顿</code></p>
<p>由于新生代空间小，并且存活对象少，再配合<code>Scavenge算法</code>，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了<code>卡顿现象</code>。</p>
<h3 id="Orinoco优化"><a href="#Orinoco优化" class="headerlink" title="Orinoco优化"></a>Orinoco优化</h3><p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决<code>全停顿问题</code>，它提出了<code>增量标记、懒性清理、并发、并行</code>的优化方法。</p>
<h4 id="增量标记-Incremental-marking"><a href="#增量标记-Incremental-marking" class="headerlink" title="增量标记(Incremental marking)"></a>增量标记(Incremental marking)</h4><p>咱们前面不断强调了<code>先标记，后清除</code>，而增量标记就是在<code>标记</code>这个阶段进行了优化。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：<code>标记一点，JS代码运行一段</code>，从而提高效率</p>
<h4 id="惰性清理-Lazy-sweeping"><a href="#惰性清理-Lazy-sweeping" class="headerlink" title="惰性清理(Lazy sweeping)"></a>惰性清理(Lazy sweeping)</h4><p>增量标记只是针对<code>标记</code>阶段，而惰性清理就是针对<code>清除</code>阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就<code>延迟了清理</code>，让JS代码先执行，或者<code>只清理部分垃圾</code>，而不清理全部。这个优化就叫做<code>惰性清理</code></p>
<p>整理标记和惰性清理的出现，大大改善了<code>全停顿</code>现象。但是问题也来了：增量标记是<code>标记一点，JS运行一段</code>，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成<code>对象引用改变，标记错误</code>现象。这就需要使用<code>写屏障</code>技术来记录这些引用关系的变化</p>
<h4 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h4><p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行<code>写屏障</code>操作。</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p>
<h2 id="V8当前的垃圾回收机制"><a href="#V8当前的垃圾回收机制" class="headerlink" title="V8当前的垃圾回收机制"></a>V8当前的垃圾回收机制</h2><p>2011年，V8应用了<code>增量标记机制</code>。直至2018年，Chrome64和Node.js V10启动<code>并发标记（Concurrent）</code>，同时在并发的基础上添加<code>并行（Parallel）技术</code>，使得垃圾回收时间大幅度缩短。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/03/31/vue%E9%83%A8%E7%BD%B2%E5%88%B0nginx/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="Update time"></i>
              2022-04-24 15:17:06
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="Tags"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" title="浏览器">
                        <b>#</b> 浏览器
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/04/24/JS%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-text">浏览器的缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires"><span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control"><span class="toc-text">Cache-Control</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">协商缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-Modified%E5%92%8CIf-Modified-Since"><span class="toc-text">Last-Modified和If-Modified-Since</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETag%E5%92%8CIf-None-Match"><span class="toc-text">ETag和If-None-Match</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-text">缓存位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">浏览器的进程和线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0"><span class="toc-text">输入url到页面呈现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%AF%87"><span class="toc-text">网络篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E7%AF%87"><span class="toc-text">解析渲染篇</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-text">重排和重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%8E%92"><span class="toc-text">重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BB%98"><span class="toc-text">重绘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90"><span class="toc-text">合成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-text">实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E5%92%8Ccss%E9%98%BB%E5%A1%9E"><span class="toc-text">js和css阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E9%98%BB%E5%A1%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">js阻塞了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%98%BB%E5%A1%9E%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">css阻塞了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS"><span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%BB%93%E5%90%88"><span class="toc-text">对称和非对称加密结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">添加数字证书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%8A%A0%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="toc-text">HTTPS加解密过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">V8的垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3"><span class="toc-text">老生代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark-Sweep-%E6%A0%87%E8%AE%B0%E6%B8%85%E7%90%86"><span class="toc-text">Mark-Sweep(标记清理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark-Compact-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-text">Mark-Compact(标记整理)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%81%9C%E9%A1%BF-Stop-The-World"><span class="toc-text">全停顿(Stop-The-World)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Orinoco%E4%BC%98%E5%8C%96"><span class="toc-text">Orinoco优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0-Incremental-marking"><span class="toc-text">增量标记(Incremental marking)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E6%B8%85%E7%90%86-Lazy-sweeping"><span class="toc-text">惰性清理(Lazy sweeping)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-Concurrent"><span class="toc-text">并发(Concurrent)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-text">并行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E5%BD%93%E5%89%8D%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">V8当前的垃圾回收机制</span></a></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        





      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Fx12138">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
        <li>
          <a title="facebook" href="">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" href="">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="wechat" href="">
            <i class="iconfont icon-wechat"></i>
          </a>
        </li>
      
        <li>
          <a title="weibo" href="">
            <i class="iconfont icon-weibo"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/fx12138">Copyright © stupidbird 2021</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div>
  </body>
</html>
