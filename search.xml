<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js高级程序设计</title>
      <link href="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>基本数据类型的值在内存中占据固定大小的空间,因此被保存在栈内存中.<ul><li>从一个变量向另一个变量复制基本类型的值,会创建这个值的一个副本</li></ul></li><li>引用类型的值是对象,保存在堆内存中<ul><li>从一个变量向另一个变量复制引用类型的值,复制的其实是指针,因此两个变量最终都指向同一个对象</li></ul></li></ul><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>非数值.</p><p>特点:</p><p>(1)任何涉及NaN的操作都会返回NaN</p><p>(2)NaN与任何值都不相等,包括NaN本身</p><p>isNaN()方法也适用于对象,在基于对象调用这个函数时,会首先调用对象的valueOf()方法,然后确定该方法返回的值是否可以转换为数值,如果不能,则给予这个返回值再调用toString()方法,再测试返回值.</p><h3 id="Number-parseInt-和parseFloat"><a href="#Number-parseInt-和parseFloat" class="headerlink" title="Number(),parseInt()和parseFloat()"></a>Number(),parseInt()和parseFloat()</h3><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210621154640957.png" alt="Number()转换规则"></p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210621155004329.png" alt="parseInt()转换规则"></p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210621155130885.png" alt="parseFloat()转换规则"></p><h1 id="迭代器与生成器-ES6"><a href="#迭代器与生成器-ES6" class="headerlink" title="迭代器与生成器(ES6)"></a>迭代器与生成器(ES6)</h1><h1 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h1><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210621172336067.png" alt="执行环境和作用域"></p><ul><li>每次进入一个新的执行环境,都会创建一个用于搜索变量和函数的作用域链</li><li>变量的执行环境有助于确定应该何时释放内存</li></ul><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>使用var生命的变量会自动被添加到最接近的环境中,在函数内部,最接近的环境就是函数的局部环境.</p><p>如果初始化时没有用var声明,该变量会自动被添加到全局环境.如下面两种不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = num1+num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>,<span class="number">20</span>)<span class="comment">//30</span></span><br><span class="line">alert(sum)<span class="comment">//由于sum不是有效的变量,因此会导致错误</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">sum = num1+num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">10</span>,<span class="number">20</span>)<span class="comment">//30</span></span><br><span class="line">alert(sum)<span class="comment">//30 由于add()函数内的sum没有用var声明,因此会添加到全局变量中可以访问</span></span><br></pre></td></tr></table></figure><p>访问局部变量要比访问全局变量更快,因为不用向上搜索作用域链.</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>最常用的垃圾收集方式是标记清除.垃圾收集器在运行的时候会给存储在内存的所有变量都加上标记.然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记.而在此之后再被加上标记的变量将被视为准备删除的变量,原因是环境中的变量已经无法访问到这些变量了.最后垃圾收集器完成内存清除工作,销毁那些带标记的值并回收他们所占用的空间.</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>属性分数据属性和访问器属性.</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个保存数据值的位置,值会从这个位置读取,也会写入到这个位置.数据属性有4个特性描述他们的行为.</p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20210622140123295.png" alt="数据属性的4个特性"></p><p>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包 含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改 的特性，可以设置其中一个或多个值。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就 不能再修改了.</p><p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不 指定，则都默认为 false。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不 过这两个函数不是必需的。</p><p>访问器属性有 4 个特性描述它们的行为。 </p><ul><li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性 都是 true。</li><li> [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。 </li><li> [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。 </li><li> [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition </span></span><br><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">year_</span>: <span class="number">2017</span>, </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123; </span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue; </span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">book.year = <span class="number">2018</span>; </span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>year_和 edition。year_中的下划线常用来表示该 属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简 单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改 为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性 值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽 略。类似地，只有一个设置函数的属性 是不能读取的.</p><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添 加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; <span class="comment">//数据属性</span></span><br><span class="line"> <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; <span class="comment">//数据属性</span></span><br><span class="line"> <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; <span class="comment">//访问器属性</span></span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue; </span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>读取属性特性方法如下,两种方法,第一种获取的是year_属性的特性描述,第二种方法获取的是book对象的全部属性和描述.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br></pre></td></tr></table></figure><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>有时也称为”混入,就是把源对象所有的本地属性一起复制到目标对象上.</p><p>ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个 或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true） 和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。</p><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力.</p><p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑 到了上述边界情形。这个方法必须接收两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN() </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 0、-0、+0 相等/不等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 正确的 NaN 相等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>创建对象的方法有多种,使用 Object 构造函数或对象字面量可以方便地创建对象.下面介绍几种其他的创建对象的方法</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> o.name = name; </span><br><span class="line"> o.age = age; </span><br><span class="line"> o.job = job; </span><br><span class="line"> o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.name = name; </span><br><span class="line"> <span class="built_in">this</span>.age = age; </span><br><span class="line"> <span class="built_in">this</span>.job = job; </span><br><span class="line"> <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.sayName(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。 </p><p>(1) 在内存中创建一个新对象。</p><p> (2) 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</p><p>(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</p><p> (4) 执行构造函数内部的代码（给新对象添加属性）。</p><p> (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p><p>定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在 这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承 自 Object.</p><h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p>构造函数的主要问题在于，其定义的方法会在每个实例上 都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方 法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会 初始化一个对象。</p><p>但创建新 Function 实例的机制是一样的。因此不同实例上的函数虽然同名却不相等如下.</p><p><code>console.log(person1.sayName == person2.sayName); // false </code></p><p>这个新问题可以通过原型模式来解决</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>(1)isPrototypeOf()方法</p><p>可以使用 isPrototypeOf()方法确定两个对 象之间的这种关系。本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时 返回 true，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(2)Object.getPrototypeOf()方法</p><p>返回参数的内部特性 [[Prototype]]的值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>(3)setPrototypeOf()方法</p><p>Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一 个新值。这样就可以重写一个对象的原型继承关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创 建一个新对象，同时为其指定原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped); </span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>(4)hasOwnProperty()方法</p><p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object 的，会在属性存在于调用它的对象实例上时返回 true.</p><h4 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h4><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。</p><p>在单独使用时，in 操作符会在可 以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>只要通过对象可以访问，in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上 时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性 是一个原型属性。</p><p>如果要确定某个属性是否存在于原型上，则可以像下 面这样同时使用 hasOwnProperty()和 in 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例 属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会 在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p><h4 id="获取实例属性"><a href="#获取实例属性" class="headerlink" title="获取实例属性"></a>获取实例属性</h4><p>要获得对象上所有*<em>可枚举的实例属性</em>***，可以使用 Object.keys()方法。这个方法接收一个对象作 为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;name,age,job,sayName&quot; </span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(); </span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>; </span><br><span class="line">p1.age = <span class="number">31</span>; </span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1); </span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure><p>如果想列出<strong>所有实例属性，无论是否可以枚举</strong>，都可以使用 Object.getOwnPropertyNames()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure><p>注意，返回的结果中包含了一个不可枚举的属性 constructor。</p><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对 象所做的修改也会在实例上反映出来。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">friend.sayHi(); <span class="comment">// &quot;hi&quot;，没问题！</span></span><br></pre></td></tr></table></figure><p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但<strong>这跟重写整个原型是两 回事</strong>。<strong>实例的[[Prototype]]指针是在调用构造函数时自动赋值的</strong>，这个指针即使把原型修改为不同 的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。 记住，<strong>实例只有指向原型的指针，没有指向构造函数的指针</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: Person, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">friend.sayName(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时 候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。</p><h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默 认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共 享特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: Person, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，Person.prototype 有一个名为 friends 的属性，它包含一个字符串数组。然后这里创建 了两个 Person 的实例。person1.friends 通过 push 方法向数组中添加了一个字符串。由于这个 friends 属性存在于 Person.prototype 而非 person1 上，新加的这个字符串也会在（指向同一个 数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一 般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>ECMAScript 2017 新增了两 个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values() 返回对象值的数组，Object.entries()返回键/值对的数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP权威指南</title>
      <link href="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一-简述HTTP"><a href="#一-简述HTTP" class="headerlink" title="一.简述HTTP"></a>一.简述HTTP</h1><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>客户端向服务器发起请求访问资源,服务器响应时,Web服务器会为所有的Http对象数据附加一个MIME类型.如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210603221720458.png" alt="服务器响应的mine类型"></p><p>URI 统一资源标识符(URL和URN是URI的两种类型)</p><p>URL 统一资源定位符</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604113110181.png" alt="image-20210604113110181"></p><p>​    标准格式包含三部分</p><p>​        “方案://服务器位置/路径”</p><p>​        (1)方案(scheme) 说明访问资源所使用的协议类型(比如http://)</p><p>​        (2)第二部分是服务器的位置,因特网地址 (比如<a href="http://www.baidu.com/">www.baidu.com</a>)</p><p>​        (3)其余部分指定服务器上的某个资源,资源路径(比如/img.png)</p><p>URN 统一资源名</p><p>​        是作为特定内容的唯一名称使用的,与目的资源所在地无关.</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604093009602.png" alt="常用方法"></p><h2 id="客户端发起服务器返回的过程"><a href="#客户端发起服务器返回的过程" class="headerlink" title="客户端发起服务器返回的过程"></a>客户端发起服务器返回的过程</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604103916295.png" alt="发起请求并响应的过程"></p><h2 id="HTTP版本"><a href="#HTTP版本" class="headerlink" title="HTTP版本"></a>HTTP版本</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604105459302.png" alt="协议版本"></p><h2 id="常见的方案"><a href="#常见的方案" class="headerlink" title="常见的方案"></a>常见的方案</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604145015386.png" alt="常见的方案1"><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604145028826.png" alt="常见的方案2"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604145028826.png" alt="常见的方案3"></p><h1 id="二-HTTP报文"><a href="#二-HTTP报文" class="headerlink" title="二.HTTP报文"></a>二.HTTP报文</h1><p>术语:</p><p>​    流入:请求报文流入源端服务器</p><p>​    流出:报文从源端服务器流出到用户Agent代理(Agent代理是所有能代替用户发送请求的应用程序,比如web浏览器)</p><p>​    上游 下游:所有的报文都会像河水一样流动,不管是请求报文还是响应报文,都会像下游流动.所有报文的发送者都在接收者的上游.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604145820623.png" alt="流入和流出"></p><h2 id="报文的格式"><a href="#报文的格式" class="headerlink" title="报文的格式"></a>报文的格式</h2><p>任何报文都由三个部分组成:<strong>起始行</strong>(请求报文称为请求行,响应报文中称为响应行),<strong>首部</strong>,和<strong>主体</strong>部分如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604150716208.png" alt="报文示例"></p><p>下面展示了请求报文和响应报文的组成,和一组假想的请求报文和响应报文作文参照</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604150429851.png" alt="请求报文格式"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604150545573.png" alt="对比"></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><strong>并不是每个服务器都实现了所有的方法,比如一台服务器要与HTTP1.1兼容,那么只要为其资源实现GET方法和HEAD方法就可以了</strong></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604151544099.png" alt="常见方法"></p><h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>HEAD方法在服务器响应中只返回首部,不会返回实体的主题部分,这就允许客户端在未获取实际资源的情况下,对资源的首部进行检查.比如可以:</p><pre><code>- 在不获取资源的情况下了解资源的情况(比如判断其类型)- 通过查看响应中的状态码,看看某个对象是否存在- 通过查看首部,测试资源是否被修改了</code></pre><h3 id="TRACE方法"><a href="#TRACE方法" class="headerlink" title="TRACE方法"></a>TRACE方法</h3><p>可恶端发起一个请求时,这个请求可能要穿过防火墙,代理,网关或其他一些应用程序.每个中间节点都可能会修改原始的HTTP请求.TRACE方法允许客户端在最终将请i去发送给服务器时,蓝看他办成了什么样子</p><h3 id="OPTIONS方法"><a href="#OPTIONS方法" class="headerlink" title="OPTIONS方法"></a>OPTIONS方法</h3><p>OPTIONS方法请求web服务器告知其支持的各种功能,可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法.下图显示了一个使用OPTIONS方法的请求</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604160823846.png" alt="OPTIONS方法示例"></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="100-199信息性状态码"><a href="#100-199信息性状态码" class="headerlink" title="100-199信息性状态码"></a>100-199信息性状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604161531968.png" alt="1的状态码"></p><p>100 Continue目的时对这样的情况进行优化:HTTP客户端应用程序有一个尸体的主体部分想要发送给服务器,但是希望在发送之前查看一下服务器是否会接受这个实体.</p><h3 id="200-299成功状态码"><a href="#200-299成功状态码" class="headerlink" title="200-299成功状态码"></a>200-299成功状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604161727326.png" alt="2的状态码"></p><h3 id="300-399重定向状态码"><a href="#300-399重定向状态码" class="headerlink" title="300-399重定向状态码"></a>300-399重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源,要么就提供一个体态的响应而不是资源的内容.如果资源已经被移动,可以发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被一走,以及现在可以在哪里找到它,这样浏览器可以在不打扰使用者的情况下,透明的转入新的位置.如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604163648167.png" alt="重定向状态码示例"></p><p>可以通过某些重定向状态码对本地的副本进行验证,确认是否源服务端上的资源被修改过,如下请求</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604164615015.png" alt="有条件的请求示例"></p><p>从下面列出所有的重定向状态码</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604163933794.png" alt="3状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604163947803.png" alt="3状态码2"></p><h3 id="400-499客户端错误状态码"><a href="#400-499客户端错误状态码" class="headerlink" title="400-499客户端错误状态码"></a>400-499客户端错误状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604165206275.png" alt="4状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604165219898.png" alt="4状态码2"></p><h3 id="500-599状态码"><a href="#500-599状态码" class="headerlink" title="500-599状态码"></a>500-599状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604165302940.png" alt="5状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604165315445.png" alt="5状态码2"></p><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><p>HTTP规范定义了几种首部字段,应用程序亦可以随意发明自己所用的首部.分为以下几类</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><p>既可以出现在请求报文中,也可以出现在响应报文中</p><p>![通用首部]image-20210604190213633.png)</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604190501850.png" alt="缓存首部"></p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604190610991.png" alt="请求首部"></p><h5 id="1-Accept首部"><a href="#1-Accept首部" class="headerlink" title="(1)Accept首部"></a>(1)Accept首部</h5><p>Accept首部为客户端提供了一种将其想要什么形式的内容告知服务器的方式.Accept首部会使连接的两端都收益,客户端会得到他们想要的内容,服务器就可以根据这些信息来决定发送的内容,不会浪费其时间和贷款来发送客户端无法使用的东西.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604191311768.png" alt="accept首部"></p><h5 id="2-条件请求首部"><a href="#2-条件请求首部" class="headerlink" title="(2)条件请求首部"></a>(2)条件请求首部</h5><p>有时客户端希望为其请求加上某些限制,就可以通过使用条件请求头部的方式,要求服务器在对请求进行响应之前,确保某个条件为真.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604191619053.png" alt="条件请求首部"></p><h5 id="3-安全请求首部"><a href="#3-安全请求首部" class="headerlink" title="(3)安全请求首部"></a>(3)安全请求首部</h5><p>质询/响应认证.这种机制要求客户端在获取特定的资源之前,先对自身进行认证,这样可以使事务安全一些.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604192648331.png" alt="安全请求首部"></p><h5 id="4-代理请求首部"><a href="#4-代理请求首部" class="headerlink" title="(4)代理请求首部"></a>(4)代理请求首部</h5><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604192719914.png" alt="代理请求首部"></p><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604192807882.png" alt="相应首部"></p><h5 id="1-协商首部"><a href="#1-协商首部" class="headerlink" title="(1)协商首部"></a>(1)协商首部</h5><p>如果资源有多种表示方法,比如如果服务器上有某文档的法语和德语稿,HTTP1/1.1可以为服务器和客户端提供对资源进行协商的能力.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604193018651.png" alt="协商首部"></p><h5 id="2-安全响应首部"><a href="#2-安全响应首部" class="headerlink" title="(2)安全响应首部"></a>(2)安全响应首部</h5><p>前面提到的质询/响应机制的响应侧.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604193927961.png" alt="安全响应首部"></p><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><p>描述实体的长度和内容,或者资源自身</p><p>在请求和响应报文中都可能包含实体部分,所有这两中类型的报文都可能出现这些首部</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604194155520.png" alt="实体首部"></p><h5 id="1-内容首部"><a href="#1-内容首部" class="headerlink" title="(1)内容首部"></a>(1)内容首部</h5><p>与实体内容有关的特定信息,说明了其类型尺寸以及处理它所需要的其他有用信息.比如web浏览器可以通过查看返回的内容类型,得知如何显示对象.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604194345491.png" alt="内容首部"></p><h5 id="2-实体缓存首部"><a href="#2-实体缓存首部" class="headerlink" title="(2)实体缓存首部"></a>(2)实体缓存首部</h5><p>通用的缓存首部说明了如何或什么时候进行缓存,实体的缓存首部提供了与被缓存实体有关的信息.比如验证已缓存的资源副本是否仍然有效所需的信息,以及更好的估计已缓存的资源合适失效所需的线索.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604194619183.png" alt="实体缓存首部"></p><h4 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h4><h2 id="版本0-9的报文"><a href="#版本0-9的报文" class="headerlink" title="版本0.9的报文"></a>版本0.9的报文</h2><p>版本0.9请求中只包含方法和URL,响应中只包含实体,他没有版本信息,没有状态码或原因短语也没有首部</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210604153729637.png" alt="版本0.9的报文"></p><h1 id="三-连接"><a href="#三-连接" class="headerlink" title="三.连接"></a>三.连接</h1><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210615092208139.png" alt="连接"></p><p>每个TCP段都是由IP分组承载,从一个IP地址发送到另一个IP地址的,每个IP分组中都包括:</p><ul><li>一个IP分组首部</li><li>一个TCP段首部</li><li>一个TCP数据块</li></ul><p>TCP连接是通过四个值来辨别的,&lt;源IP地址,源端口号,目的IP地址,目的端口号&gt;这四个值一起唯一定义了一条连接</p><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210615135947172.png" alt="并行连接"></p><p>如上图所示即为并行连接请求和响应的过程.</p><p>即使并行连接的速度可能会更快,但是不一定总是更快.客户端的网络带宽不足时,一个连接到速度较快的服务器上的HTTP事务就会很容易地耗尽所有可用的带宽.如果并行加载多个对象,每个对象都去竞争这有限的带宽,每个对象都会以较慢的速度按比例加载,这样带来的性能提升就非常小</p><p>而且打开大量连接会消耗很多内存资源,从而引发自身性能的问题.一百个用户同时发出申请,每个用户打开一百个连接,服务器就要负责处理10000个连接,这会造成服务器性能严重下降.</p><p>实际上,浏览器确实使用了并行连接,但是会将连接的总数限制为一个较小的值.</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><blockquote><p>TCP慢启动</p><p>TCP数据传输会随着时间进行自我调谐,起初会限制连接的最大速度,如果数据成功传输,会随着时间的推移提高传输的速度.这种调谐被成为TCP慢启动,用于防止因特网的突然过载和拥塞.所以新连接的传输速度会比已经交换过一定量数据的连接慢一些.</p></blockquote><p>在事务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接.重用已对目标服务器打开的空闲持久连接,就可以避开缓慢的连接建立阶段.</p><h3 id="keep-alive和持久连接的区别"><a href="#keep-alive和持久连接的区别" class="headerlink" title="keep-alive和持久连接的区别"></a>keep-alive和持久连接的区别</h3><p>与HTTP/1.0的keep-alive连接不同,HTTP/1.1持久连接在默认情况下是激活的,除非特别指明,否则HTTP/1.1假定所有链接都是持久的.</p><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><h1 id="四-代理"><a href="#四-代理" class="headerlink" title="四.代理"></a>四.代理</h1><p>Web代理(proxy)服务器是网络的中间实体,位于客户端和服务器之间,扮演”中间人的角色,在各端点之间来回传送HTTP报文”</p><h2 id="私有和共享代理"><a href="#私有和共享代理" class="headerlink" title="私有和共享代理"></a>私有和共享代理</h2><p>代理服务器可以是某个客户端专用的,也可以是很多客户端共享的.单个客户端专用的代理被称为私有代理.众多客户端共享的代理被称为公共代理.</p><h2 id="代理和网关的对比"><a href="#代理和网关的对比" class="headerlink" title="代理和网关的对比"></a>代理和网关的对比</h2><p>代理连接的是两个或多个是同<strong>相同协议的应用程序</strong>,而网关连接的是两个或多个使用<strong>不同协议的端点</strong>.网关扮演的是”协议转换器”的角色,即使客户端和服务器使用的是不同的协议,客户端也可以通过它完成与服务器之间的事务处理.如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210617160127706.png" alt="代理和网关的对比"></p><p>实际上,代理和网关之间的区别很模糊.由于浏览器和服务器实现的是不同版本的HTTTP,代理也经常要做一些协议转换工作.而商业化的代理服务器也会实现网关的功能来支持SSL安全协议,SICKS防火墙,FTP访问等.</p><h2 id="为什么使用代理"><a href="#为什么使用代理" class="headerlink" title="为什么使用代理"></a>为什么使用代理</h2><p>代理服务器可以实现各种时髦且有用的功能。它们可以改善安全性，提高性能，节省费用。代理服务器可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的增值Web服务。</p><ul><li>儿童过滤器</li><li></li></ul><h2 id="代理URI与服务器URI的不同"><a href="#代理URI与服务器URI的不同" class="headerlink" title="代理URI与服务器URI的不同"></a>代理URI与服务器URI的不同</h2><p>客户端向服务器和代理发送请求时,HTTP报文中的URI有所不同,除了这一点,服务器报文和代理报文语法是一样的.</p><p>客户端向web服务器发送请求时,请求行中只包含部分URI(没有方案,主机或者端口),如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618115151160.png" alt="向服务器发送请求示例"></p><p>但是向代理发送请求时,请求行中则包含完整的URI,如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618115240995.png" alt="向代理发送请求示例"></p><h2 id="URI的客户端自动扩展和主机名解析"><a href="#URI的客户端自动扩展和主机名解析" class="headerlink" title="URI的客户端自动扩展和主机名解析"></a>URI的客户端自动扩展和主机名解析</h2><h3 id="没有代理时URI的解析"><a href="#没有代理时URI的解析" class="headerlink" title="没有代理时URI的解析"></a>没有代理时URI的解析</h3><p>在没有代理的情况下,浏览器进行主机名自动扩展,如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618134700422.png" alt="没有代理时URI的解析"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618134737985.png" alt="没有代理时URI的解析过程"></p><h3 id="有显示代理时URI的解析"><a href="#有显示代理时URI的解析" class="headerlink" title="有显示代理时URI的解析"></a>有显示代理时URI的解析</h3><p>使用显示代理时,用户的URI会被直接发送给代理,所以浏览器就不再执行所有的便捷的扩展功能了.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618134948486.png" alt="有显示代理时URI的解析"></p><h2 id="Via首部字段"><a href="#Via首部字段" class="headerlink" title="Via首部字段"></a>Via首部字段</h2><p>Via首部字段用于记录报文的转发,诊断报文循环,标识请求/响应链上所有发送者的协议能力.</p><p>代理也可以使用Via首部来检测网络中的路由循环.代理应该在发送一条请求之前,在ia首部插入一个与其自身有关的独特字符串,并在输入的请求中查找这个字符串,以检测网络中是否存在路由循环.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618135630181.png" alt="Via示例"></p><p>代理也可以为使用非HTTP协议的服务器提供网关的功能.Via首部记录了这些协议转换.这时Via字段中协议的版本号之前必须加上协议的类型(如果是HTTP协议则可加可不加)如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618142058586.png" alt="代理网关示例"></p><p>可以使用Max-Forwards首部来限制请求报文经过代理转发的跳数.</p><h2 id="代理认证"><a href="#代理认证" class="headerlink" title="代理认证"></a>代理认证</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618144545665.png" alt="代理认证"></p><h1 id="五-缓存"><a href="#五-缓存" class="headerlink" title="五.缓存"></a>五.缓存</h1><h2 id="命中和未命中"><a href="#命中和未命中" class="headerlink" title="命中和未命中"></a>命中和未命中</h2><p>缓存命中:可以用已有的副本为某些到达缓存的请求提供服务.</p><p>缓存未命中:一些到达缓存的请求可能会由于没有副本可用,而被转发给原始服务器,</p><p>再验证:原始服务器的内容可能会发生变化,缓存要不时对其进行检测,看看它们保存的副本是否仍是服务器上的最新版本.这些新鲜度检测称为HTTP再验证.</p><p>验证再命中:缓存对缓存的副本进行再验证时,会向原始服务器发送一个小的在验证请求,如果内容没有变化,服务器会以一个小的304 Not Modified进行响应,缓存知道副本仍然有效.,就会再次将副本标识为暂时新鲜的,并将副本提供给客户端,这被称为再验证命中,或者缓慢命中.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210618161151295.png" alt="命中示例"></p><p>再验证的工具最常用的就是If-Modified-Since首部,将这个首部添加到get请求中,就可以告诉服务器,只有在缓存了对象的副本之后,又对其进行了修改的情况下,才发送此对象.</p><h3 id="区分命中和未命中的情况"><a href="#区分命中和未命中的情况" class="headerlink" title="区分命中和未命中的情况"></a>区分命中和未命中的情况</h3><p>HTTP没有为用户提供一种手段来区分响应是缓存命中的还是访问原始服务器得到的,在这两种情况下,响应码都是200OK.</p><p>客户端可以使用Date首部,将响应中Date首部的值与当前时间进行比较,如果响应中的日期比较早,客户端就可以认为这是一条缓存的响应.</p><p>也可以通过Age首部来检测缓存的响应,通过这个首部可以分辨出这条响应的使用期.</p><h2 id="缓存处理过程"><a href="#缓存处理过程" class="headerlink" title="缓存处理过程"></a>缓存处理过程</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210621141546286.png" alt="缓存处理过程"></p><h2 id="新鲜度检测"><a href="#新鲜度检测" class="headerlink" title="新鲜度检测"></a>新鲜度检测</h2><p>HTTP有一些简单的机制可以在不要求服务器记住哪些缓存拥有其文档副本的情况下,保持已缓存数据与服务器数据之间充分一致.HTTP将这些简单的机制称为文档过期和服务器再验证.</p><h3 id="文档过期"><a href="#文档过期" class="headerlink" title="文档过期"></a>文档过期</h3><p>通过特殊的HTTP Cache-Control首部和Expires首部,HTTP让原始服务器向每个文档附加了一个’过期日期’(如下图).</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210621142527681.png" alt="Cache-Control首部和Expires首部"></p><h3 id="服务器再验证"><a href="#服务器再验证" class="headerlink" title="服务器再验证"></a>服务器再验证</h3><p>已缓存的文档过期并不意味着它和服务器上的文档有实际的区别,这只是意味着到了要进行核对的时间了,这种情况被称为’服务器再验证’,说明缓存需要询问原始服务器文档是否发生了变化.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210621143021847.png" alt="再验证过程"></p><h3 id="条件方法再验证"><a href="#条件方法再验证" class="headerlink" title="条件方法再验证"></a>条件方法再验证</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210621143234576.png" alt="条件再验证首部"></p><h4 id="If-Modified-Since日期再验证"><a href="#If-Modified-Since日期再验证" class="headerlink" title="If-Modified-Since日期再验证"></a>If-Modified-Since日期再验证</h4><p>If-Modified-Since首部(一般称为IMS)可以与Last-Modified服务器响应首部配合工作.如下图为一个工作流程示例.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210621143632010.png" alt="If-Modified-Since示例"></p><h4 id="If-None-Match实体标签再验证"><a href="#If-None-Match实体标签再验证" class="headerlink" title="If-None-Match实体标签再验证"></a>If-None-Match实体标签再验证</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621144119753.png" alt="If-None-Match"></p><p>如果服务器回送了实体标签,HTTP/1.1客户端就必须使用实体标签验证器.如果HTTP/1.1缓存或者服务器收到的请求既带有If-Modified-Since又带有实体标签条件首部,那么只有这两个条件都满足时,才能返回304Not Modified响应.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2021/05/13/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/05/13/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="宏任务微任务"><a href="#宏任务微任务" class="headerlink" title="宏任务微任务"></a>宏任务微任务</h2><h3 id="7-1-问题分析"><a href="#7-1-问题分析" class="headerlink" title="7.1 问题分析"></a>7.1 问题分析</h3><p>事件执行的机制(eventLoop)</p><p>考察  js 代码的执行过程  执行顺序</p><p>凡是异步代码和定时器代码 都会等到主程序执行完毕再执行</p><h3 id="7-2-核心问题讲解"><a href="#7-2-核心问题讲解" class="headerlink" title="7.2 核心问题讲解"></a>7.2 核心问题讲解</h3><h4 id="7-2-1-Js-代码执行机制"><a href="#7-2-1-Js-代码执行机制" class="headerlink" title="7.2.1 Js 代码执行机制"></a>7.2.1 Js 代码执行机制</h4><ul><li>所有同步任务都在主线程上的栈中执行。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，选择出需要首先执行的任务（由浏览器决定，并不按序）。</li></ul><h4 id="7-2-2-宏任务与微任务"><a href="#7-2-2-宏任务与微任务" class="headerlink" title="7.2.2 宏任务与微任务"></a>7.2.2 宏任务与微任务</h4><ol><li>MacroTask（宏观Task） <strong>setTimeout, setInterval</strong>, , requestAnimationFrame, I/O</li><li>MicroTask（微观任务） process.nextTick, <strong>Promise</strong>, Object.observe, MutationObserver</li><li><strong>先同步 再取出第一个宏任务执行 所有的相关微任务总会在下一个宏任务之前全部执行完毕   如果遇见 就  先微后宏</strong></li></ol><h3 id="7-3-问题扩展"><a href="#7-3-问题扩展" class="headerlink" title="7.3 问题扩展"></a>7.3 问题扩展</h3><p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。<strong>*（检查还有没有微任务需要处理）*</strong><br>而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。<strong>*（结束本次宏任务、检查还有没有宏任务需要处理）</strong>*</p><p><strong>题目</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 5 11 6 2 3 4 7 8 10 9</span></span><br><span class="line">    <span class="comment">// 第一个setTimeout宏任务结束之后，会去检查队列中是否有微任务存在，如果有的话先执行微任务。（微任务优先级高）</span></span><br></pre></td></tr></table></figure><h2 id="重绘和重排-回流"><a href="#重绘和重排-回流" class="headerlink" title="重绘和重排(回流)"></a>重绘和重排(回流)</h2><h3 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h3><p>​    该问题主要考核  html中的优化 与 重点概念</p><h3 id="1-2-核心问题讲解"><a href="#1-2-核心问题讲解" class="headerlink" title="1.2 核心问题讲解"></a>1.2 核心问题讲解</h3><h5 id="浏览器的运行机制："><a href="#浏览器的运行机制：" class="headerlink" title="浏览器的运行机制："></a><strong>浏览器的运行机制：</strong></h5><ol><li>构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）<strong>生成内容树</strong>（Content Tree/DOM Tree）；</li><li>构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>）<strong>，构建渲染树</strong>（Rendering Tree/Frame Tree）；render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现</li><li>布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</li><li>绘制渲染树（paint/repaint）：遍历渲染树，使用UI 层来绘制每个节点。</li></ol><p><strong>重绘（repaint或redraw）</strong>：</p><p>​    当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。</p><p><strong>重绘是指一个元素外观的改变</strong>所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p> 　　<strong>触发重绘的条件：改变元素外观属性。如：color，background-color等。</strong></p><p><strong>注意：</strong>table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p><p><strong>重排（重构/回流/reflow）：</strong>当渲染树中的一部分(或全部)因为元素的**规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)**。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p><strong>重绘和重排的关系</strong>：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p>　　所以，<strong>重排必定会引发重绘</strong>，但重绘不一定会引发重排。</p><p><strong>触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如：</strong></p><p>　　1、页面渲染初始化；(无法避免)</p><p>　　2、添加或删除可见的DOM元素；</p><p>　　3、元素位置的改变，或者使用动画；</p><p>　　4、元素尺寸的改变——大小，外边距，边框；</p><p>　　5、浏览器窗口尺寸的变化（resize事件发生时）；</p><p>　　6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；</p><p>　　7、读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)</p><p><strong>重绘重排的代价：耗时，导致浏览器卡慢。</strong>****</p><h3 id="1-3-问题扩展"><a href="#1-3-问题扩展" class="headerlink" title="1.3 问题扩展"></a>1.3 问题扩展</h3><p><strong>优化：</strong>　　</p><p>1、浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p><p>2、我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。</p><p>（1）<strong>直接改变元素的className</strong></p><p>（2）display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排；</p><p>（3）使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p><p>（4）<strong>将需要多次重排的元素，position属性设为absolute或fixed</strong>，元素脱离了文档流，它的变化不会影响到其他元素；</p><p>（5）如果需要创建多个DOM节点，可以使用DocumentFragment<strong>创建完后一次性的加入document；</strong></p><h3 id="1-4-结合项目中使用"><a href="#1-4-结合项目中使用" class="headerlink" title="1.4 结合项目中使用"></a>1.4 结合项目中使用</h3><p>代码例子</p><p><strong>// 举个例子  这么一个思路 建议不要边循环边渲染</strong> </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    li.innerHTML = <span class="string">&#x27;apple&#x27;</span>+i;</span><br><span class="line"></span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fruit&#x27;</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure><h2 id="对async、await的理解"><a href="#对async、await的理解" class="headerlink" title="对async、await的理解"></a>对async、await的理解</h2><h3 id="4-1-问题分析"><a href="#4-1-问题分析" class="headerlink" title="4.1 问题分析"></a>4.1 问题分析</h3><p>​        考察 地狱回调  Promise  async 与await</p><h3 id="4-2-核心问题讲解-有代码"><a href="#4-2-核心问题讲解-有代码" class="headerlink" title="4. 2 核心问题讲解-有代码"></a>4. 2 核心问题讲解-有代码</h3><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p><a href="http://es6.ruanyifeng.com/#docs/async">阮老师文档</a></p><p>同步:代码从上往下执行,遇见同步会一直等,等到同步执行完毕才继续向下执行</p><p>异步:代码从上往下执行,遇见异步会先走,后面再执行异步</p><p>异步操作: 定时器 ajax 事件处理(绑定的onClick等) node.js读取文件  <strong>new promise是同步的而promise.then是异步的</strong></p><p>axios就是用promise把ajax封装了一遍</p><p>Promise.all和Promise.race的区别:</p><p>​    Promise.all([p1,p2,p3],函数)要数组中的所有promise全部执行完毕后才执行then</p><p>​    Promise.race([p1,p2,p3],函数)是只要数组中的任意一个执行完毕后就执行then</p><h3 id="4-3-问题扩展"><a href="#4-3-问题扩展" class="headerlink" title="4.3 问题扩展"></a>4.3 问题扩展</h3><p><strong>内部原理</strong></p><p>async await函数是什么？一句话，它就是 Generator + yield函数的语法糖。yield又暂停一段的功能</p><p>Generator 函数可以返回一系列的值，因为可以有任意多个yield。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">  const readFile = function (fileName) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">      fs.readFile(fileName, function(error, data) &#123;</span><br><span class="line">        if (error) return reject(error);</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const gen = function* () &#123;</span><br><span class="line">    const f1 = yield readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">    const f2 = yield readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">  改造</span><br><span class="line"></span><br><span class="line">  const asyncReadFile = async function () &#123;</span><br><span class="line">  const f1 = await readFile(&#x27;/etc/fstab&#x27;);</span><br><span class="line">  const f2 = await readFile(&#x27;/etc/shells&#x27;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-4-结合项目中使用"><a href="#4-4-结合项目中使用" class="headerlink" title="4.4  结合项目中使用"></a>4.4  结合项目中使用</h3><p> axios 请求 配合 async await  拿到数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2021/05/07/js/"/>
      <url>/2021/05/07/js/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>js共有6种数据类型</p><p>(基本数据类型5个)String Number Boolean Null Undefined  (引用数据类型)Object</p><p><strong>注意:使用typeof(null)得出的是Object 而不是Null</strong></p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>一 强制转为String</p><p>String Number Boolean可以直接使用.toString()方法进行转换,而Null Undefined类型的数据使用.toString()方法会报错.</p><p>Null Undefined类型的数据可以使用String(a)函数进行转换,这种方法实际上是直接对null 或 undefined加双引号.</p><p>二 强制转为Number</p><p>(1)Number(a)函数</p><p>若a中包含字符则返回NaN</p><p>(2)parseInt(a)和parseFloat(a)</p><p>parseInt(a)可以将字符串中有效的整数内容取出并转换为Number</p><p>对于非字符串的a 会先将其转换成字符串后再取值</p><h1 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象(prototype)"></a>原型对象(prototype)</h1><p>我们所创建的每一个函数,解析器都会向<strong>函数中添加一个属性prototype</strong>,<strong>prototype是函数才有的属性，切记，切记</strong>,这个属性对应着一个对象,默认指向一个Object空对象,这个对象就是原型对象.</p><p>原型对象中有一个constructor属性,指向函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fun.prototype.constructor===fun)<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加属性(一般是方法),实例对象可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person()</span><br><span class="line">a.sayHello()<span class="comment">//hello</span></span><br></pre></td></tr></table></figure><p>当函数以构造函数的形式调用时,他所创建的对象都会有一个隐含的属性,指向该构造函数的原型对象,我们可以访问</p><p>原型对象就相当于一个公共的区域,所有同一个类的实例都可以访问到这个原型对象,<code>__proto__</code>是每个对象都有的属性</p><p>原型对象也是对象,所以他也有原型.</p><p>当我们访问对象中的一个属性或方法时,它首先会在对象自身中寻找,如有则直接用;如果没有则会去原型对象中寻找,如果有则直接用;如果没有,则会到原型的原型中去找.直到找到Object这个对象的原型,Object对象的原型没有原型,如果在Object的原型中依然没有找到,则返回undefined.</p><h2 id="显示原型和隐式原型"><a href="#显示原型和隐式原型" class="headerlink" title="显示原型和隐式原型"></a>显示原型和隐式原型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">//每个函数function都有一个prototype,即显示原型</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="comment">//每个实例对象都有一个__proto__,即隐式原型</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__)</span><br><span class="line"><span class="comment">//每个实例对象的__proto__就是函数function的prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype===a.__proto__)<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例对象的隐式原型等于函数对象的显式原型</span></span><br><span class="line"><span class="comment">//Person函数的显式原型(Person.prototype)返回的时一个空的Object实例对象,所以这个实例对象有隐式原型(Person.prototype.__proto__)</span></span><br><span class="line"><span class="comment">//因为时Object的实例对象,所以他的隐式原型就是Object的显式原型</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype)<span class="comment">//true 如图二</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/07/js/%E5%8E%9F%E5%9E%8B.png" alt="原型"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/2021/05/07/js/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p><p>​    访问一个对象的属性时,先在自身属性中查找,找到返回.如果没有,再沿着proto这条链向上查找,找到返回.如果最终没有找到,返回undefined</p><p>​    所以原型链的别名又叫做隐式原型链,作用是查找对象的属性</p><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h2><p>　在js当中，我们常常遇到数组复制的的情况，许多人一般都会使用“=”来直接把一个数组赋值给一个变量，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b=a;</span><br><span class="line"><span class="built_in">console</span>.log(b);　　<span class="comment">//输出的是1,2,3</span></span><br><span class="line">a[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);　　<span class="comment">//输出的是1,2,0</span></span><br></pre></td></tr></table></figure><p>把数组a用等号“=”的形式复制给变量b，这种就是js数组的浅拷贝。然而，正如上面代码所示，一旦对数组a做出修改，实际上会影响拷贝出来的其他数组，这并不是我们所想要的结果，因此就必须用到数组的深拷贝来解决这个问题 </p><h2 id="实现深拷贝的方法"><a href="#实现深拷贝的方法" class="headerlink" title="实现深拷贝的方法"></a>实现深拷贝的方法</h2><p>(1)for循环实现数组的深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    arr2.push(arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//4, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//1, 2, 3</span></span><br></pre></td></tr></table></figure><p>(2)concat 方法实现数组的深拷贝</p><p>concat() 方法用于连接两个或多个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.concat();</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//4, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//1, 2, 3</span></span><br></pre></td></tr></table></figure><p>(3)ES6扩展运算符实现数组的深拷贝</p><p>用扩展运算符对数组或者对象进行拷贝时，只能扩展和深拷贝第一层的值，对于第二层极其以后的值，扩展运算符将不能对其进行打散扩展，也不能对其进行深拷贝，即拷贝后和拷贝前第二层中的对象或者数组仍然引用的是同一个地址，其中一方改变，另一方也跟着改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> [...arr2] = arr1;</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//4, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//1, 2, 3</span></span><br></pre></td></tr></table></figure><h1 id="函数声明与var声明函数的区别"><a href="#函数声明与var声明函数的区别" class="headerlink" title="函数声明与var声明函数的区别"></a>函数声明与var声明函数的区别</h1><p>使用function 函数(){}创建的函数会在所有代码执行前被声明,所以即使在它声明前调用亦可以正常执行.如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数被调用了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会正常输出&quot;函数被调用了&quot;</span></span><br></pre></td></tr></table></figure><p>使用var声明的函数提前调用会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数被调用了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况会报错</span></span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>构造函数和普通函数的区别就是调用方式的不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="keyword">var</span> normal = Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>构造函数执行流程:</p><p>​    1.立即创建一个新的对象</p><p>​    2.将新建的对象设置为函数中的this</p><p>​    3.逐行执行函数中的代码</p><p>​    4.将新建的对象作为返回值返回</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的方法</p><p>​    1array.sort() 对数组进行排序</p><p>​    2 foreach() 遍历</p><p>​    3 push() 添加元素,push() 方法返回新数组的长度</p><p>​    4 pop() 方法返回“被弹出”的值</p><p>​    5 toString() 把数组转换为数组值（逗号分隔）的字符串</p><p>​    6 join() 方法也可将所有数组元素结合为一个字符串。它的行为类似 toString()，但是可以规定分隔符</p><p>​    7 shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引,方法返回被“位移出”的字符串</p><p>​    8 unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素, 方法返回新数组的长度</p><p>​    9 splice() 方法可用于向数组添加新项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);</span><br></pre></td></tr></table></figure><p>​        第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>​        第二个参数（0）定义应删除多少元素。</p><p>​        其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>​        splice() 方法返回一个包含已删除项的数组</p><p>​    10 concat() 方法通过合并（连接）现有数组来创建一个新数组</p><p>​    11 slice() 方法用数组的某个片段切出新数组</p><p>​            slice() 可接受两个参数，比如 (1, 3)。</p><p>​            该方法会从开始参数选取元素，直到结束参数（不包括）为止</p><p>​            如果结束参数被省略，则 slice() 会切出数组的剩余部分</p><h1 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h1><p>这两个都是函数对象的方法,函数对象调用这两个方法时都会调用执行这个函数.</p><p>在调用call()和apply()时可以将一个对象指定为第一个参数.此时这个对象将会成为函数执行时的this.</p><p><strong>这两种方法都可以通过传入对象来任意的改变this的指向.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">fun();<span class="comment">//此时打印的this为window</span></span><br><span class="line">fun.call(obj1);<span class="comment">//此时this为obj1</span></span><br><span class="line">fun.apply(obj1);<span class="comment">//此时this为obj1</span></span><br></pre></td></tr></table></figure><p>call()方法可以将实参在对象之后依次传递.</p><p>apply()方法需要将实参封装到一个数组中统一传递.如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//call()方法可以将实参在对象之后依次传递.</span></span><br><span class="line">fun.call(obj1,<span class="number">10</span>,<span class="number">20</span>)<span class="comment">//这样this指向的是obj1,传入的参数a=10,b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply()方法需要将实参封装到一个数组中统一传递.</span></span><br><span class="line">fun.apply(obj1,[<span class="number">10</span>,<span class="number">20</span>])<span class="comment">//这样this指向的是obj1,传入的参数a=10,b=20</span></span><br></pre></td></tr></table></figure><h2 id="this指向的情况"><a href="#this指向的情况" class="headerlink" title="this指向的情况"></a>this指向的情况</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.以函数的形式调用时,this永远都是window</span></span><br><span class="line">fun()<span class="comment">//this是window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.以方法的形式调用时,this指向的是调用方法的对象</span></span><br><span class="line">obj1.fun()<span class="comment">//this是obj1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.以构造函数的形式调用时,this是新创建的那个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();<span class="comment">//this是per</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用call或apply方法调用时,this是传入的第一个指定的对象</span></span><br><span class="line">fun.call(obj1,<span class="number">10</span>,<span class="number">20</span>)<span class="comment">//这样this指向的是obj1</span></span><br><span class="line">fun.apply(obj1,[<span class="number">10</span>,<span class="number">20</span>])<span class="comment">//这样this指向的是obj1</span></span><br></pre></td></tr></table></figure><h1 id="argument"><a href="#argument" class="headerlink" title="argument"></a>argument</h1><p>在调用函数时浏览器会自动传入两个参数,一个是this,一个是arguments,它是封装实参的对象.</p><p>arguments是一个类数组对象,它也可以通过索引来操作数据,也可以获取长度</p><p>在调用函数时,我们所传递的实参都会在arguments中保存</p><p>arguments.length可以用来获取实参的长度</p><p>arguments有一个属性callee,这个属性对应一个函数对象,就是当前正在指向的函数的对象</p><h1 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h1><h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><h2 id="页面加载得流程"><a href="#页面加载得流程" class="headerlink" title="页面加载得流程"></a>页面加载得流程</h2><p>浏览器在加载一个页面得时候是按照自上而下得顺序加载的</p><p>读取一行就运行一行,如果将js代码写在上面,在代码执行时页面还没有加载,dom对象也没有加载,这样会导致无法获取到dom对象.</p><p>所以要将js代码写在下面确保页面加载完毕后再执行js代码.</p><p>不过如果非要写在上面,可以在window.onload = function(){}这里面写,这个函数是在页面加载完成后才执行.</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数.</p><p>(在IE8以下的浏览器中,响应函数被触发时,浏览器不会传递事件对象,而是将事件对象作为window对象的属性传入)</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡就是指事件的向上传导,当后代元素上的事件被触发时,其祖先元素的事件也会被出发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;out&quot;</span>&gt;</span><br><span class="line">我是div</span><br><span class="line">&lt;span id=<span class="string">&quot;inner&quot;</span>&gt;</span><br><span class="line">我是span</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;out&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;div被点击了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;inner&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;span被点击了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;body被点击了&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的情况中,当点击span部分时,三个事件都会被触发,首先pan然后div,然后body</p><p>如果不希望冒泡发生,可以通过事件对象来取消冒泡event.cancelBubble = true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;inner&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;span被点击了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">event.cancelBubble = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h2><p>指将事件统一绑定给元素共同的祖先元素,这样当后代元素上的事件发生时,会一直冒泡到祖先元素</p><p>事件委派时利用了冒泡,事件委派可以减少事件绑定的次数,提高程序的性能</p><p><strong>event中的target表示的触发事件的对象 ，使用它对触发事件的元素进行判断。</strong></p><h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><p>document.getElementById(‘inner’).onclick = function(){}这种方法定义点击事件有局限性,如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;out&quot;</span>&gt;</span><br><span class="line">我是div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;out&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;div被点击了1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;out&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;div被点击了2&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况我可能想要div被点击时既弹出第一个提示框,又弹出第二个提示框.但是实际上第二个点击的函数会覆盖第一个,所以只会弹出第二个框.</p><p>事件的绑定addEventListener()接收三个参数</p><p>​    ①事件的字符串,不加on</p><p>​    ②回调函数,当事件被触发时会调用该函数</p><p>​    ③是否在捕获阶段触发事件,需要一个布尔值,一般都传false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;out&quot;</span>&gt;</span><br><span class="line">我是div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickDiv1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;div被点击了1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickDiv2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;div被点击了2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;out&#x27;</span>)</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;clickDiv1&#x27;</span>,<span class="literal">false</span>)</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="string">&#x27;clickDiv2&#x27;</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这样的话,可以用addEventListener()方法为div绑定多个事件,会按照绑定的顺序被触发.</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>setInterval()</p><p>定时调用,可以将一个函数每隔一段时间执行一次</p><p>参数: ①回调函数 ②时间</p><p>返回值: 返回一个Number  当有多个定时器时,返回的就是定时器的标识</p><p>clearInterval() 传入一个setInterval()的标识即关闭定时器</p><h1 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>返回数据类型的字符串表达</p><p>typeof 可以对JS基础数据类型做出准确的判断，而对于引用类型返回的基本上都是object, 其实返回object也没有错，因为所有对象的原型链最终都指向了Object,Object是所有对象的<code>祖宗</code>。 如果判断的是引用类型的话，typeof 就显得有些力不从心了。</p><p>typeof null 返回Object</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型,当 A 的 <em><em>proto</em></em> 指向 B 的 prototype 时，就认为A就是B的实例。instanceof只能用来检测两个对象是否在一条原型链上，并不能检测出对象的具体类型。</p><p>instanceof是如何判断的(A instanceof B)</p><p>​    如果B函数的显示原型对象在A的原型链上,则返回true,否则false</p><img src="/2021/05/07/js/devApp\myblog\source\_posts\js.assets\image-20210518140451187.png" alt="image-20210518140451187" style="zoom:50%;"><h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(’’) ; <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ; <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object Window] window是全局对象global的引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>通过var声明的变量,在定义语句前就可以访问到,但返回的时undefined,这就时变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">f()<span class="comment">//输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数内的执行逻辑相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数会现在自身内部去找a,然而因为a变量提升所以输出undefined.</p><p>先变量提升,后函数提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>)<span class="comment">//报错,这段代码相当于下面的过程执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c<span class="comment">//先进性变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;<span class="comment">//进行函数提升</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span><span class="comment">//变量提升和函数提升执行后进行赋值</span></span><br><span class="line">c(<span class="number">2</span>)<span class="comment">//此时c=1不是一个函数,所以执行会报错</span></span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>全局作用域</p><p>函数作用域</p><p>ES6有了块作用域</p><p>作用:隔离变量,不同作用域中同名变量不会冲突</p><p>如果定义了n个函数,就有n+1个作用域,n个相应的函数作用域和1个全局作用域</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h2><p>当一个嵌套的内部函数引用了嵌套的外部函数的变量时,就产生了闭包</p><p>在下面的代码中,内部函数的f2引用了f2外部f1中的a,所以产生闭包,并且闭包中有a</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包产生条件"><a href="#闭包产生条件" class="headerlink" title="闭包产生条件"></a>闭包产生条件</h2><p><strong>1函数嵌套</strong></p><p><strong>2内部函数引用外部函数的变量或函数</strong></p><p><strong>3执行外部函数</strong></p><p><strong>内部函数定义执行时就会产生闭包,不用必须调用内部函数</strong>.外部函数被调用几次就会产生几次闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1将函数作为另一个函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f3 = f1()<span class="comment">//此时f3得到的是f2</span></span><br><span class="line">f3()<span class="comment">//a=3</span></span><br><span class="line">f3()<span class="comment">//a=4</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2将函数作为实参传递给另一个函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span>(<span class="params">mes,time</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(mes)</span><br><span class="line">&#125;,time)</span><br><span class="line">&#125;</span><br><span class="line">showDelay(<span class="string">&quot;这是消息&quot;</span>,<span class="number">2000</span>)</span><br><span class="line"><span class="comment">//内部函数为setTimeout中的第一个函数参数,其中alert(mes)引用了外部函数中的mes,因此会产生闭包</span></span><br><span class="line"><span class="comment">//但是time不是</span></span><br></pre></td></tr></table></figure><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>1使用函数内部的变量在函数执行完后,仍然存在内存里,(延长了局部变量的生命周期)</p><p>2 让函数外部可以操作到函数内部的数据</p><p>​    如上面的例1,a是f1的局部变量,本应该在f1函数执行结束后销毁,但是由于内部函数f2调用了a,产生了闭包,仍然可以对a进行操作,这样就延长了局部变量的生命周期同时在函数外操作函数内的变量</p><h2 id="闭包的声明周期"><a href="#闭包的声明周期" class="headerlink" title="闭包的声明周期"></a>闭包的声明周期</h2><p>产生:在嵌套内部函数定义被执行时就产生(不是调用)</p><p>死亡:在嵌套的内部函数成为辣鸡对象的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//在这个时候闭包就已经产生了,因为f1函数被调用开始执行f1,这时因为函数提升f2已经创建了</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f3 = f1()<span class="comment">//此时f3得到的是f2</span></span><br><span class="line">f3 = <span class="literal">null</span><span class="comment">//此时闭包死亡(因为包含闭包的函数对象成为辣鸡对象)</span></span><br></pre></td></tr></table></figure><h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><p>1函数执行完后,函数内的局部变量没有被释放,占用内存时间会变长</p><p>2容易造成内存泄漏</p><p>解决:1 能不用闭包就不用闭包 2 及时释放</p><h1 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h1><p>内存溢出</p><p>​    内存溢出是一种程序运行出现的错误</p><p>​    当程序运行需要的内存超过了剩余的内存时,就抛出内存溢出的错误</p><p>内存泄漏</p><p>​    占用的内存没有被及时释放</p><p>​    内存泄漏积累多了就容易导致内存溢出</p><p>常见的内存泄露:1意外的全局变量     2 没有及时清理的计时器或回调函数    3 闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//意外的全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况下,本来在函数内部应该用var a = 2来定义局部变量,这样a就能在函数执行完成后自动被释放.但是这种定义方法会使a成为全局变量,这样在函数执行完成后不会被自动释放</span></span><br></pre></td></tr></table></figure><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;the window&quot;</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;my object&quot;</span>,</span><br><span class="line"><span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(object.getName()())</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印的是&quot;the window&quot;</span></span><br><span class="line"><span class="comment">//因为object.getName()得到的是内部返回的函数,object.getName()()是执行这个返回的函数,函数中的this指向的是window,所以this.name指向的是window中的name</span></span><br></pre></td></tr></table></figure><p>上面这段代码没有闭包,因为内部函数为<img src="/2021/05/07/js/devApp\myblog\source\_posts\js.assets\image-20210520134628664.png" alt="image-20210520134628664" style="zoom: 33%;">,外部函数<img src="/2021/05/07/js/devApp\myblog\source\_posts\js.assets\image-20210520134726730.png" alt="image-20210520134726730" style="zoom:33%;">,这样的话内部函数并没有引用外部函数中的变量,而是引用了全局中的变量,外部函数中并没有定义变量.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;the window&quot;</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;my object&quot;</span>,</span><br><span class="line"><span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">that = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> that.name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(object.getName()())</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印的是my object</span></span><br><span class="line"><span class="comment">//因为that = this时,这是的this时object.getName这个函数中的this,所以this指向object,因此that也是指向object,that.name就是object中的name</span></span><br></pre></td></tr></table></figure><p>这个有闭包,内部函数引用了外部函数中的that</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h2><p>原型链的继承就是<strong>让子类型的原型成为父类型的实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想让Child成为Father的子类,既可以调用父类型的方法,又可以调用子类型的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.fathMes = <span class="string">&#x27;这是父类的mes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.showFathMes = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.fathMes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.childMes = <span class="string">&#x27;这是子类的mes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类型的原型为夫类型的一个实例对象,这样就实现了Child成为Father的一个子类型,并能调用夫类型的方法</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Father()</span><br><span class="line">Child.prototype.showChildMes = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.childMes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是这样child实例的constructor为Father,并不是Child.</span></span><br><span class="line"><span class="comment">//因为constructor会沿着原型链找,child实例的__proto__是Father的一个实例,他的__proto__中的constructor就是Father</span></span><br><span class="line"><span class="comment">//因此需要为Child指定一个正确的constructor</span></span><br><span class="line">Child.prototype.constructor = Sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child.showChildMes()</span><br><span class="line">child.showFathMes()</span><br></pre></td></tr></table></figure><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>进程就是程序的一次运行,它占有一片独有的内存空间</p><p>线程是进程内的一个独立执行单元,是程序执行的一个完整流程,是cpu最小的调度单元</p><p>多进程:一个应用程序可以同时启动多个实例运行</p><p>多线程:在一个进程内,同时有多个线程运行</p><h2 id="比较单线程和多线程"><a href="#比较单线程和多线程" class="headerlink" title="比较单线程和多线程"></a>比较单线程和多线程</h2><p>多线程优点</p><p>​    1有效提升cpu的利用率</p><p>多线程缺点</p><p>​    1创建多线程开销</p><p>​    2线程间切换开销(例如单核的程序同一时间只能执行一个线程,但可以创建多个线程,频繁的再多个线程间切换执行)</p><p>​    3死锁与状态同步问题</p><p>单线程的优点</p><p>​    1顺序编程简单易懂</p><p>单线程缺点</p><p>​    2效率低</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>浏览器是多线程运行的</p><p>浏览器有的是多进程有的是单进程</p><p>单进程:火狐 老版ie</p><p>多进程:chrome 新版ie</p><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>内核:支撑浏览器运行的最核心的程序</p><p>chrome,safari:webkit</p><p>火狐:Gecko</p><p>IE:Trident</p><p>360,搜狗等:Trident(用到钱的时候切换这个内核,比较安全)+webkit(一般用这个)</p><h1 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h1><p>alert暂停当前主线程的执行,同时暂停计时,点击确定后,恢复程序的执行和计时</p><p>为什么是单线程不是多线程?</p><p>​    因为当进行界面更新的时候,假如是p1和p2线程都读取了一个标签,p1要更新p标签中的文本,但是p2要删除p标签,p1线程刚要更新但还没更新就到p2线程了,p2删除了p标签,之后又到了p1线程,p1因为刚刚检测过了存在p标签,就不会再检测p标签是否存在,而是直接更新就会报错.</p><p>如果是多线程的话可不可以避免上面的问题?</p><p>​    可以,当p1对p标签进行操作的时候对其上锁,在p1线程对p标签的执行操作完成前其他线程不能对p标签进行其他操作.</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><img src="/2021/05/07/js/devApp\myblog\source\_posts\js.assets\image-20210520204523336.png" alt="image-20210520204523336" style="zoom:50%;"><p>初始化代码执行完毕后才会执行回调函数队列中的回调函数,从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)</p><p>回调函数分为同步回调函数和异步回调函数,</p><p>array.foreach(item=&gt;{</p><p>})这是同步回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newarray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">newarray.foreach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;foreach后&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种情况由于foreach是同步的回调函数,不会放入到队列中,所以代码会从上到下依次执行,打印1,2,3,foreach后</p><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h2 id="为什么使用promise"><a href="#为什么使用promise" class="headerlink" title="为什么使用promise"></a>为什么使用promise</h2><p>promise是一种处理异步操作的一种解决方案,是一个构造函数</p><p>为什么使用这种方法处理异步操作呢?</p><p>​    <strong>1指定回调函数的方式更加灵活</strong></p><p>​        旧的方法:必须在启动异步任务前指定好回调函数</p><p>​        promise:启动异步任务=&gt;返回promise对象=&gt;给promise对象绑定回调函数</p><p>​    <strong>2支持链式调用,可以解决地狱回调问题</strong></p><p>​        什么是地狱回调?回调函数嵌套调用,外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p><p>​        回调函数的缺点?不便于阅读,不便于异常处理</p><p>​        而且promise错误处理只需定义一个错误的回调函数,异常传透会让reject都回调这个函数</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.<strong>函数执行上下文只有在函数被调用的时候才会产生函数执行上下文,并压入栈顶</strong>.<strong>执行上下文对象的个数为n+1,其中n为函数被调用的次数,1为全局上下文</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>现在 JavaScript 遇到下面的这段代码了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1()</span></span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span></span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦，fun2还调用了fun3！</span></span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun2执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1执行完毕</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</p><p>答案就是执行上下文栈的变化不一样。</p><p>让我们模拟第一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>让我们模拟第二段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码执行会报错,因为变量提升和函数提升,上面的代码执行时等同于下面的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>所以由此看来c并不是一个函数,所以会报错</p><h1 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h1><p>作用域相对于上下文而言,上下文只有在函数被调用时才会产生,而<strong>作用域在编写代码时就已经确定了,即在函数定义时就已经产生.作用域共有n+1个,其中n为定义函数的个数,1为全局作用域</strong></p><h2 id="上下文和作用域的区别"><a href="#上下文和作用域的区别" class="headerlink" title="上下文和作用域的区别"></a>上下文和作用域的区别</h2><p>区别一</p><p>​    *全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时就已经确定了,而不是函数调用时</p><p>​    *全局执行上下文环境是在全局作用域之后,js代码马上执行之前创建</p><p>​    *函数执行上下文环境是在调用函数时,函数体代码执行之前创建</p><p>区别二</p><p>​    *作用域是静态的,只要函数定义好了就一直存在,且不会再变化</p><p>​    *上下文环境是动态的,调用函数时创建,函数调用结束时上下文环境就会被释放</p><p>联系</p><p>​    *执行上下文环境是从属于所在作用域</p><p>​    *全局上下文环境==&gt;全局作用域</p><p>​    *函数上下文环境==&gt;对应的函数使用域</p><h1 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span>&#125;(); <span class="comment">//SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure><p>这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的<code>function</code>关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();<span class="comment">//SyntaxError: Unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* code */</span>&#125;</span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在Javascript里，圆括号不能<strong>包含</strong>声明。因为这点，当圆括号为了包裹函数碰上了 <code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。<strong>注意理解</strong>这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p><ul><li><strong>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</strong></li><li><strong>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</strong></li></ul><h1 id="bind函数实现"><a href="#bind函数实现" class="headerlink" title="bind函数实现"></a>bind函数实现</h1><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><p>首先第一个功能在于传入的第一个参数改变this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回了一个函数</span></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo); </span><br><span class="line"></span><br><span class="line">bindFoo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟传入第一个参数改变this指向</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">newThis</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> self.apply(newThis)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line">bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind2函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.habit);</span><br><span class="line"><span class="built_in">console</span>.log(obj.friend);</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">that.status = <span class="string">&#x27;pending&#x27;</span><span class="comment">//三种状态,初始为pending状态</span></span><br><span class="line">that.data = <span class="literal">undefined</span><span class="comment">//给promise对象指定一个用于存储结果数据的属性</span></span><br><span class="line">that.callbacks = []<span class="comment">//每个元素的结构:&#123;onResolved()&#123;&#125;,onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//因为状态只能又pending-&gt;resolved或者由pending-&gt;rejected</span></span><br><span class="line"><span class="comment">//所以要判断状态,当多次调用resolve时,直接返回</span></span><br><span class="line"><span class="keyword">if</span>(that.status!==<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为resolved</span></span><br><span class="line">that.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="comment">//保存value数据</span></span><br><span class="line">that.data = value</span><br><span class="line"><span class="comment">//如果有待执行的callback函数,立即异步执行回调</span></span><br><span class="line"><span class="keyword">if</span>(that.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//放入队列里执行所有成功的回调</span></span><br><span class="line"><span class="comment">//加上setTimeout是为了使里面的代码异步执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">that.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span>=&gt;</span>&#123;</span><br><span class="line">callbacksObj.onResolved(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="comment">//因为状态只能又pending-&gt;resolved或者由pending-&gt;rejected</span></span><br><span class="line"><span class="comment">//所以要判断状态,当多次调用reject时,直接返回</span></span><br><span class="line"><span class="keyword">if</span>(that.status!==<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为rejected</span></span><br><span class="line">that.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="comment">//保存value数据</span></span><br><span class="line">that.data = reason</span><br><span class="line"><span class="comment">//如果有待执行的callback函数,立即异步执行回调</span></span><br><span class="line"><span class="keyword">if</span>(that.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//放入队列里执行所有成功的回调</span></span><br><span class="line"><span class="comment">//加上setTimeout是为了使里面的代码异步执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">that.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span>=&gt;</span>&#123;</span><br><span class="line">callbacksObj.onRejected(reason)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//立即同步执行excutor</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">excutor(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line"><span class="comment">//当执行器中直接抛异常时,promise对象变为reject</span></span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">onResolved</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment"> * 指定成功和失败的回调代码</span></span><br><span class="line"><span class="comment"> * 返回一个新的promise对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当then中的回调函数不是函数时(比如then中什么都没有写,实现then的传透传递,直接返回数据,将数据传递到下一个then中)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">onResolved = <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> that.data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">onRejected = <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> that.data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">result,resolve,reject</span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// let result = onResolved(value)</span></span><br><span class="line"><span class="comment">//处理返回的是一个新的promise的情况</span></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设当前状态还是pending状态,将回调函数保存起来</span></span><br><span class="line"><span class="keyword">if</span>(that.status === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">that.callbacks.push(&#123;</span><br><span class="line"><span class="comment">//压入回调栈中的函数也要有可能错,和下面的一样,只不过这是加到了回调栈中,执行的时间不一样而已</span></span><br><span class="line"><span class="comment">//所以压入回调栈中的函数也是要进行捕获异常的操作</span></span><br><span class="line"><span class="attr">onResolved</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onResolved(value),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = onResolved(value)</span><br><span class="line"><span class="comment">//处理返回的是一个新的promise的情况</span></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">onRejected</span>: <span class="function"><span class="params">reaseon</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onRejected(reaseon),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = onRejected(reaseon)</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(that.status === <span class="string">&#x27;resolved&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//假设当前状态是resolved状态,异步执行成功的回调函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onResolved(that.data),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当onResolved报错时要进行相应捕获并处理(比如onResolved函数输出了未定义的变量)</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//result存储当前promise执行then后的值,并且默认返回一个成功状态promise</span></span><br><span class="line"><span class="keyword">let</span> result = onResolved(that.data)</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line"><span class="built_in">console</span>.log(result.then(resolve,reject))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(that.status === <span class="string">&#x27;rejected&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//假设当前状态是rejected状态,异步执行失败的回调函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onRejected(that.data),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//result存储当前promise执行then后的值,并且默认返回一个成功状态promise</span></span><br><span class="line"><span class="keyword">let</span> result = onRejected(that.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reaseon</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Promise = <span class="built_in">Promise</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2021/04/30/ES6/"/>
      <url>/2021/04/30/ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，<strong>但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</strong></p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。另外，**<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。两个作用域中的i互不影响**</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h3 id="let不存在变量提升"><a href="#let不存在变量提升" class="headerlink" title="let不存在变量提升"></a>let不存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，**变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>**。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p><strong>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。<strong>所以在<code>let</code>声明变量前，对<code>tmp</code>的进行操作的区域则为暂时性死区(TDZ)</strong></p><p><strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，<strong>块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</strong></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><p><strong><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。<code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</strong></p><p><strong><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</strong>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p><p>因此已经被const定义好的对象和数据,可以进行增加删除属性的操作,但是不能让其指向另一个数组.</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ES6声明变量六种方法"><a href="#ES6声明变量六种方法" class="headerlink" title="ES6声明变量六种方法"></a>ES6声明变量六种方法</h2><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">et [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><p>可以传入默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而<strong>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。</strong></p><h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><p>字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>使用参数默认值时，函数不能有同名参数。</p><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p><h3 id="默认值结合结构"><a href="#默认值结合结构" class="headerlink" title="默认值结合结构"></a>默认值结合结构</h3><p>下面是另一个解构赋值默认值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<strong>函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</strong></p><p>作为练习，请问下面两种写法有什么差别？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure><h3 id="默认参数的位置"><a href="#默认参数的位置" class="headerlink" title="默认参数的位置"></a>默认参数的位置</h3><p>提供默认参数的参数最好设置在末尾,否则一些情况下会报错,比如下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p><p>如果此时，全局变量<code>x</code>不存在，就会报错。</p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p><p>如果写成下面这样，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p><p><strong>下面是一个更复杂的例子。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，该变量与第一个参数<code>x</code>由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p><p>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p><p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h2 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">...a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params">&#123;a, b&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数有几个使用注意点。</p><p>（1）箭头函数没有自己的<code>this</code>对象（详见下文）。</p><p>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，最重要的是第一点。<strong>对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。</strong>也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s1: &#x27;</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s2: &#x27;</span>, timer.s2), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p><p>总之，箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p><p>请问下面的代码之中，<code>this</code>的指向有几个？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>答案是<code>this</code>的指向只有一个，就是函数<code>foo</code>的<code>this</code>，这是因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。所以不管怎么嵌套，<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的<code>this</code>都指向运行时所在的不同对象。</p><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p><strong>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">globalThis.s = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">s</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.s)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.m() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>obj.m()</code>使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给<code>obj.m</code>，这导致箭头函数内部的<code>this</code>指向全局对象，所以<code>obj.m()</code>输出的是全局空间的<code>21</code>，而不是对象内部的<code>42</code>。上面的代码实际上等同于下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">globalThis.s = <span class="number">21</span>;</span><br><span class="line">globalThis.m = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">s</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">m</span>: globalThis.m</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.m() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>由于上面这个原因，对象的属性建议使用传统的写法定义，不要用箭头函数定义。</p><p><strong>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="代替函数的apply方法"><a href="#代替函数的apply方法" class="headerlink" title="代替函数的apply方法"></a>代替函数的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p><p>ES5 只能用变通方法来复制数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p><p>扩展运算符提供了复制数组的简便写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6 引入了一种新的原始<strong>数据类型<code>Symbol</code>，表示独一无二的值。</strong></p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.toString() <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p><strong>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sym.description <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p>可以用传入数组的方法取出数组重复成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>set中认为两个对象总是不相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set的属性"><a href="#Set的属性" class="headerlink" title="Set的属性"></a>Set的属性</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><h3 id="Set的操作方法"><a href="#Set的操作方法" class="headerlink" title="Set的操作方法"></a>Set的操作方法</h3><p>操作方法主要是用于操作数据</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="Set遍历方法"><a href="#Set遍历方法" class="headerlink" title="Set遍历方法"></a>Set遍历方法</h3><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>(1)<code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>(2)forEach()</p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li><p>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p></li><li><p>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p></li><li><p>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p><p>典型的操作就是<code>in</code>运算符。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p></li><li><p>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p></li><li><p>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</p></li><li><p>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p></li><li><p>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p></li><li><p>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p></li><li><p>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p></li><li><p>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p></li><li><p>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p></li><li><p>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p></li><li><p>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/2021/04/16/Android/"/>
      <url>/2021/04/16/Android/</url>
      
        <content type="html"><![CDATA[<p>最近写了一个viewpaper+fragment实现底部导航的页面,记录一下</p><p>整体的效果大概是这样,通过页面下方的导航栏可以进行页面的跳转</p><p><img src="/2021/04/16/Android/devApp\blog\source\_posts\Android.assets\image-20210416134643199.png" alt="image-20210416134643199" style="zoom:50%;"><img src="/2021/04/16/Android/devApp\blog\source\_posts\Android.assets\image-20210416134737687.png" alt="image-20210416134737687" style="zoom:50%;"></p><h2 id="1导航界面"><a href="#1导航界面" class="headerlink" title="1导航界面"></a>1导航界面</h2><p>首先实现viewpaper,在activity_layout.xml中设计导航页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.zhihui.ZhihuiActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_radio_group&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;49dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;门户&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbMenhu&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbBaojing&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;报警&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbZhihui&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;智慧&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbWode&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;我的&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager.widget.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_viewpager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/main_radio_group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">androidx.viewpager.widget.ViewPager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2viewpaper的适配器"><a href="#2viewpaper的适配器" class="headerlink" title="2viewpaper的适配器"></a>2viewpaper的适配器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragmentPaperAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PAGE_NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_MENHU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_BAOJING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_ZHIHUI = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_WODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> MenhuFragment menhuFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> BaojingFragment baojingFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ZhihuiFragment zhihuiFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> WodeFragment wodeFragment = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFragmentPaperAdapter</span><span class="params">(<span class="meta">@NonNull</span> FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        menhuFragment = <span class="keyword">new</span> MenhuFragment();</span><br><span class="line">        baojingFragment = <span class="keyword">new</span> BaojingFragment();</span><br><span class="line">        zhihuiFragment = <span class="keyword">new</span> ZhihuiFragment();</span><br><span class="line">        wodeFragment = <span class="keyword">new</span> WodeFragment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">            <span class="keyword">case</span> PAGE_MENHU: &#123;</span><br><span class="line">                <span class="keyword">return</span> menhuFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_BAOJING: &#123;</span><br><span class="line">                <span class="keyword">return</span> baojingFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_ZHIHUI: &#123;</span><br><span class="line">                <span class="keyword">return</span> zhihuiFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_WODE: &#123;</span><br><span class="line">                <span class="keyword">return</span> wodeFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PAGE_NUM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3fragment的layout文件"><a href="#3fragment的layout文件" class="headerlink" title="3fragment的layout文件"></a>3fragment的layout文件</h2><p>创建几个fragment的布局文件,我这里创建的是fragment_baojing.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;报警界面&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于四个都很类似,我就不再一一堆代码了</p><h2 id="4对fragment进行实现"><a href="#4对fragment进行实现" class="headerlink" title="4对fragment进行实现"></a>4对fragment进行实现</h2><p>创建BaojingFragment类继承Fragment类,重写onCreatView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaojingFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_baojing, container,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对自己定义的几个fragment都进行这样的实现</p><h2 id="5activity"><a href="#5activity" class="headerlink" title="5activity"></a>5activity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhihuiActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">ViewPager</span>.<span class="title">OnPageChangeListener</span>, <span class="title">RadioGroup</span>.<span class="title">OnCheckedChangeListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyFragmentPaperAdapter myFragPageAdapter;</span><br><span class="line">    <span class="keyword">private</span> ViewPager viewPager;</span><br><span class="line">    <span class="keyword">private</span> RadioGroup radioGroup;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_menhu;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_baojing;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_zhihui;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_wode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PAGE_NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_MENHU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_BAOJING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_ZHIHUI = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_WODE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_zhihui);</span><br><span class="line"></span><br><span class="line">        myFragPageAdapter=<span class="keyword">new</span> MyFragmentPaperAdapter(getSupportFragmentManager());</span><br><span class="line">        bindViews();</span><br><span class="line">        radioButton_zhihui.setChecked(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindViews</span><span class="params">()</span></span>&#123;</span><br><span class="line">        radioButton_menhu=findViewById(R.id.rbMenhu);</span><br><span class="line">        radioButton_baojing=findViewById(R.id.rbBaojing);</span><br><span class="line">        radioButton_zhihui=findViewById(R.id.rbZhihui);</span><br><span class="line">        radioButton_wode=findViewById(R.id.rbWode);</span><br><span class="line"></span><br><span class="line">        radioGroup=findViewById(R.id.main_radio_group);</span><br><span class="line">        radioGroup.setOnCheckedChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        viewPager= findViewById(R.id.main_viewpager);</span><br><span class="line">        viewPager.setAdapter(myFragPageAdapter);</span><br><span class="line">        viewPager.addOnPageChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        viewPager.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (viewPager.getCurrentItem())&#123;</span><br><span class="line">                <span class="keyword">case</span> PAGE_MENHU:</span><br><span class="line">                    radioButton_menhu.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_BAOJING:</span><br><span class="line">                    radioButton_baojing.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_ZHIHUI:</span><br><span class="line">                    radioButton_zhihui.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_WODE:</span><br><span class="line">                    radioButton_wode.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(RadioGroup group, <span class="keyword">int</span> checkedId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (checkedId)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbMenhu:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_MENHU);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbBaojing:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_BAOJING);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbZhihui:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_ZHIHUI);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbWode:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_WODE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue笔记</title>
      <link href="/2021/04/06/vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/06/vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE笔记"><a href="#VUE笔记" class="headerlink" title="VUE笔记"></a>VUE笔记</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在router文件夹下的index.js文件中引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;../components/User&#x27;</span></span><br></pre></td></tr></table></figure><p>接着创建路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过vue.use(插件)安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:About</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: routes,</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;history&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将router对象传入到vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>在main.js中引入并挂载</p><p>这样在需要进行跳转的地方使用router-link标签即可,用<strong>router-view标签接收</strong>该link传入的界面并显示</p><p>若想让项目运行直接进入首页则在routes加入一个router使其重定向到’/home’,如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:About</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="router-link标签的属性补充"><a href="#router-link标签的属性补充" class="headerlink" title="router-link标签的属性补充"></a>router-link标签的属性补充</h3><p>tag:router-link标签默认渲染成a标签,可以通过tag属性进行更改成button li等</p><p>replace:将跳转模式从pushState变成replaceState,即不可返回,只能点击进行跳转</p><p>active-class:当router-link被点击时该标签会处于活跃状态,自动带有class=”router-link-active”,这个class的名字可以通过active-class进行更改</p><h3 id="通过代码进行路由跳转"><a href="#通过代码进行路由跳转" class="headerlink" title="通过代码进行路由跳转"></a>通过代码进行路由跳转</h3><p>按钮添加点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toHome&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在methods中实现方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">toHome</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">toAbout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/about&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>this.$router获取到的是router中定义的大的router,即包括所有的routes</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>在创建路由的时候在路径后面拼接冒号和相应字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//记住冒号后面拼接的字段名称,要用到</span></span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/user/:userId&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用到路由的地方使用router-link标签,但是需要拼接data中的用户名,因此在to属性前加冒号进行绑定,将/user使用单引号括起来代表字符串,而后面拼接的userId则为绑定的data中userId的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">message</span>:<span class="string">&#x27;第一次尝试&#x27;</span>,</span><br><span class="line">    <span class="attr">userId</span>:<span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能动态路由到<a href="http://localhost:8080/user/zhangsan%E8%BF%99%E6%A0%B7%E7%9A%84url">http://localhost:8080/user/zhangsan这样的url</a></p><h3 id="动态路由传参"><a href="#动态路由传参" class="headerlink" title="动态路由传参"></a>动态路由传参</h3><h4 id="params方式"><a href="#params方式" class="headerlink" title="params方式"></a>params方式</h4><p>如果想在User界面使用userId则在User界面的添加computed</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  <span class="function"><span class="title">userId</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.userId</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中this.$route获取到的是当前活跃的route.接下载在界面中使用接收展示即可.</p><h4 id="query方式"><a href="#query方式" class="headerlink" title="query方式"></a>query方式</h4><p>配置路由的时候正常编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:About</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在router-link的to中传入对象,to前面需要加冒号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/about&#x27;,query:&#123;name:&#x27;fx&#x27;,age:23&#125;&#125;&quot;&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>这样传参方式的url为<a href="http://localhost:8080/about?name=fx&amp;age=23%E8%BF%99%E7%A7%8D%E5%BD%A2%E5%BC%8F">http://localhost:8080/about?name=fx&amp;age=23这种形式</a></p><p>在相应的about界面中可以以下面的方式取出参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;我是关于&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;$route.query&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;$route.query.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;$route.query.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果不使用router-link 而使用按钮的话,则在点击的方法里传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;toAbout&quot;&gt;关于按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">toAbout()&#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    path:&#x27;/about&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">      name:&#x27;fx&#x27;,</span><br><span class="line">      age:23</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h3><p>因为不进行懒加载的话会将所有的业务代码整合成一个js文件,在请求静态页面时可能时间请求的时间有点长导致页面中出现一段时间的空白现象,使用路由懒加载后将使用懒加载方式的每个页面抽离成另外的数个js文件,这样只有在需要的时候进行加载,不需要的时候不加载.</p><p>路由懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/About&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/User&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>/home/message 和 /home/news即一个大的路由下嵌套两个小的子路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:Home,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>:HomeNews</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;messages&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>:HomeMessage</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大的路由中使用children,数组中为子路由,其中<strong>子路由的path前不需要加/</strong></p><p>因为是首页的子路由,所以将router-view放在首页的组件中用来接收子路由的页面</p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>对全局的跳转进行监听,可以在监听函数中做一些事情</p><p>比如需求为跳转到任意界面时显示当前页面的title则可以使用导航守卫</p><p>首先在每个路由中添加meta数据,将title进行定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:Home,</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;首页&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:HomeNews</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;messages&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:HomeMessage</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:About,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;关于&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//记住冒号后面拼接的字段名称,要用到</span></span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/user/:userId&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: User,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;用户&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在route的配置文件中使用导航守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//从from跳转到to</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>router.beforeEach需要传入一个函数,必须带有to,from,next参数,可以使用箭头函数.其中to.meched是一个数组,数组中是定义的每个路由,其中的第一个为将要跳转的路由,再从这个路由中取出title.</p><p>next()函数是定义好的,必须执行.</p><h2 id="动态绑定style"><a href="#动态绑定style" class="headerlink" title="动态绑定style"></a>动态绑定style</h2><p>动态绑定style,这里需要父组件传入相应的样式,比如传入字体的颜色</p><p>首先在子组件中的props中定义用于接收父组件传入的参数activeColor,要求是String类型,默认为red(即当父组件没有传入activeColor时默认为红色)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="built_in">String</span>,</span><br><span class="line">  <span class="attr">activeColor</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">default</span>:<span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件中传入activeColor</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TabbarItem</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">active-color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/img/tabbar/mine.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/img/tabbar/fruit.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon-active&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;item-name&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TabbarItem</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子组件中动态绑定样式并加入计算属性activeStyle</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;activeStyle&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  <span class="function"><span class="title">isActive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$route.path.indexOf(<span class="built_in">this</span>.path)!== -<span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">activeStyle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isActive ? &#123;<span class="attr">color</span>:<span class="built_in">this</span>.activeColor&#125; : &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改文件夹别名"><a href="#更改文件夹别名" class="headerlink" title="更改文件夹别名"></a>更改文件夹别名</h2><p>一些常用的文件夹比如assets和components等中的文件在引用的时候需要../../../../很麻烦,所以可以更改别名直接使用</p><p>在项目的build文件夹下找到webpack.base.conf.js文件,找到下面的代码处进行更改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;assets&#x27;</span>:resolve(<span class="string">&#x27;src/assets&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;components&#x27;</span>:resolve(<span class="string">&#x27;src/components&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>alias即进行别名的设置,我这里设置了assets和components文件夹</p><p>这样在import时只需使用别名即可,但是注意如果是img标签中的src属性需要在前面加上~,如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/mine.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/fruit.png&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon-active&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="axios基本使用"><a href="#axios基本使用" class="headerlink" title="axios基本使用"></a>axios基本使用</h3><p>安装axios</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><p>引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用axios发送请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1/goods/detail&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>:&#123;</span><br><span class="line">    <span class="attr">goods_id</span>:<span class="number">1111</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios并发"><a href="#axios并发" class="headerlink" title="axios并发"></a>axios并发</h3><p>axios发送并发请求,当两个请求都拿到结果的时候再处理相应的事情</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1/goods/detail&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">      <span class="attr">goods_id</span>:<span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1/goods/detail&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">      <span class="attr">goods_id</span>:<span class="number">2222</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>上面的axios请求用的都是全局的axios和axios配置.但是相对于实际开发中的不同的请求会创建axios实例,并对每个实例进行相应的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance1 = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line">axiosInstance1(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;/goods/detail?goods_id=8888&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个axios实例</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance2 = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line">axiosInstance2(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;/goods/detail?goods_id=6666&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h3><p>新建request.js文件</p><p>第一种方法采用回调函数方式,编辑request.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种采用回调函数的方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,failure</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.创建axios实例</span></span><br><span class="line">  <span class="keyword">const</span> axios1 = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//2.发送网络请求</span></span><br><span class="line">  axios1(config).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    failure(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.封装request模块 用第一种回调的方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;/goods/detail?goods_id=6666&#x27;</span></span><br><span class="line">&#125;,<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二种方法采用promise,编辑request.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种采用promise的方式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1.创建axios实例</span></span><br><span class="line">    <span class="keyword">const</span> axios1 = axios.create(&#123;</span><br><span class="line">      <span class="attr">baseURL</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1&#x27;</span>,</span><br><span class="line">      <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.发送网络请求</span></span><br><span class="line">    axios1(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的地方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;/goods/detail?goods_id=6666&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建axios实例</span></span><br><span class="line">    <span class="keyword">const</span> axios1 = axios.create(&#123;</span><br><span class="line">      <span class="attr">baseURL</span>:<span class="string">&#x27;https://api-hmugo-web.itheima.net/api/public/v1&#x27;</span>,</span><br><span class="line">      <span class="attr">timeout</span>:<span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.axios拦截器</span></span><br><span class="line">    <span class="comment">//2.1请求拦截</span></span><br><span class="line">    axios1.interceptors.request.use(<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//请求成功时,config传来的是本次请求的一些配置,包括请求方法,url和header等</span></span><br><span class="line">      <span class="built_in">console</span>.log(config);</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//什么时候使用请求拦截器</span></span><br><span class="line">      <span class="comment">//1.比如检查config中的一些信息是否符合服务器的要求</span></span><br><span class="line">      <span class="comment">//2.比如每次发送请求时,都希望在界面中显示一个正在加载的图标</span></span><br><span class="line">      <span class="comment">//3.某些网络请求必须携带的一些信息(比如登录的token)</span></span><br><span class="line"></span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//请求失败时</span></span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//2.2响应拦截</span></span><br><span class="line">    axios1.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//成功响应返回的是响应的结果</span></span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.发送网络请求</span></span><br><span class="line">    axios1(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>一般情况下是在有异步操作时,使用Promise对异步操作进行封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//成功时回调resolve</span></span><br><span class="line">        resolve(<span class="string">&#x27;学习promise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//失败时回调reject</span></span><br><span class="line">        <span class="comment">// reject(&#x27;学习promise&#x27;)</span></span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>new Promise需要传入两个参数,一个为resolve,另一个为reject,这两个都是函数.</p><h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><p>pending 等待(比如网络请求需要一定的时间,这个过程为等待)</p><p>fulfill 完成(回调resolve函数)</p><p>reject 拒绝(回调reject函数)</p><h3 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;请求1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;18&#x27;</span>&#125;)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;请求2&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只有当promise.all中的所有promise都完成后才会执行then.其中then中的res是一个数组,是每个请求的结果.</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>vuex是一个状态管理工具,简单来说就是几个共享数据的存储中心,当许多组件都需要用一些数据的时候就可以把这些数据用vuex进行管理.</p><p>vuex的最重要的特点就是响应式.</p><p>主要管理哪些状态呢?</p><p>​    比如用户的登录状态,用户名称,头像,地理位置信息等</p><p>​    比如商品的收藏,购物车商品等</p><h3 id="vuex安装"><a href="#vuex安装" class="headerlink" title="vuex安装"></a>vuex安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><h3 id="vuex使用"><a href="#vuex使用" class="headerlink" title="vuex使用"></a>vuex使用</h3><p>在项目中新建一个store文件夹,并在store文件夹下新建index.js文件,内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.state 保存状态,在界面中使用的时候语法: $store.state.counter</span></span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">counter</span>:<span class="number">1000</span>,</span><br><span class="line">    <span class="attr">stus</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;curry&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">14</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;james&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">22</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">31</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//2.mutations 方法,可以对state中的数据进行修改操作(更改state的唯一方法就是提交mutation),其中的方法默认又一个state参数</span></span><br><span class="line">  <span class="comment">//但是在调用这些方法的时候不可以使用$store.mutations.方法名直接调用</span></span><br><span class="line">  <span class="comment">//而是使用commit  如this.$store.commit(&quot;increment&quot;)</span></span><br><span class="line">  <span class="comment">//2.1如果想要调用时传参的话语法为this.$store.commit(&quot;increment&quot;,num),其中num为自定义的参数,这个参数叫做payload载荷</span></span><br><span class="line">  <span class="comment">//这样在mutations里面的方法中,传入的第一个参数默认时state,第二个写num即可</span></span><br><span class="line">  <span class="comment">//比如下面的increase方法</span></span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.counter--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//比如加几需要通过调用传入</span></span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state,num</span>)</span>&#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//3.actions</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">//4.getters 相当于计算属性,其中的方法默认第一个参数为state,第二个为getters本身,不再接收其他参数</span></span><br><span class="line">  <span class="comment">//如果想要在调用时传参的话,可以返回一个带参数的函数</span></span><br><span class="line">  <span class="comment">//比如下面的getStu方法,用来获取比输入参数age年龄小的学生,在调用时使用$store.getters.getstu(20)即可</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">getStu</span>(<span class="params">state,getters</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.stus.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age&lt;age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>:&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>接下来在main.js中进行挂载</p><h3 id="vuex结构"><a href="#vuex结构" class="headerlink" title="vuex结构"></a>vuex结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  UPDATE</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.state 保存状态,在界面中使用的时候语法: $store.state.counter</span></span><br><span class="line">  <span class="attr">state</span>:&#123;</span><br><span class="line">    <span class="attr">counter</span>:<span class="number">1000</span>,</span><br><span class="line">    <span class="attr">stus</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;curry&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">14</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;james&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">22</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">31</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//2.mutations 方法,可以对state中的数据进行修改操作(更改state的唯一方法就是提交mutation),其中的方法默认又一个state参数</span></span><br><span class="line">  <span class="comment">//但是在调用这些方法的时候不可以使用$store.mutations.方法名直接调用</span></span><br><span class="line">  <span class="comment">//而是使用commit  如this.$store.commit(&quot;increment&quot;)</span></span><br><span class="line">  <span class="comment">//2.1如果想要调用时传参的话语法为this.$store.commit(&quot;increment&quot;,num),其中num为自定义的参数,这个参数叫做payload载荷</span></span><br><span class="line">  <span class="comment">//这样在mutations里面的方法中,传入的第一个参数默认时state,第二个写num即可</span></span><br><span class="line">  <span class="comment">//比如下面的increase方法</span></span><br><span class="line">  <span class="attr">mutations</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      state.counter--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//比如加几需要通过调用传入</span></span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state,num</span>)</span>&#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//响应式修改state</span></span><br><span class="line">    [UPDATE](state)&#123;</span><br><span class="line">      <span class="comment">//响应式的添加address属性</span></span><br><span class="line">      Vue.set(state.stus[<span class="number">0</span>],<span class="string">&quot;address&quot;</span>,<span class="string">&quot;遵化&quot;</span>)</span><br><span class="line">      <span class="comment">//响应式的删除address属性</span></span><br><span class="line">      <span class="comment">// Vue.delete(state.stus[0],&quot;address&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//3.actions 在这里进行异步操作,比如网络请求,里面的方法默认的参数为context,可以理解为等同于store</span></span><br><span class="line">  <span class="comment">//这样的话在页面中调用actions里面的方法时需要使用dispatch,如this.$store.dispatch(&quot;updateCounter&quot;)</span></span><br><span class="line">  <span class="comment">//这里和mutations中一样可以传参,即payload</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">updateCounter</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//这里进行对数据的更改,但是一定要通过提交mutation的方式,即commit</span></span><br><span class="line">        context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">4000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//4.getters 相当于计算属性,其中的方法默认第一个参数为state,第二个为getters本身,不再接收其他参数</span></span><br><span class="line">  <span class="comment">//如果想要在调用时传参的话,可以返回一个带参数的函数</span></span><br><span class="line">  <span class="comment">//比如下面的getStu方法,用来获取比输入参数age年龄小的学生,在调用时使用$store.getters.getstu(20)即可</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">getStu</span>(<span class="params">state,getters</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.stus.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age&lt;age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//5.modules 可以对state进行模块式的划分,在取出a的state中定义的name的时候语法 $store.state.a.name</span></span><br><span class="line">  <span class="attr">modules</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:&#123;</span><br><span class="line">      <span class="comment">//页面中取出这个模块里定义的name $store.state.a.name</span></span><br><span class="line">      <span class="attr">state</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;dddd&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//页面的方法中使用模块中mutations定义的方法 this.$store.commit(&quot;mutations中的方法名&quot;)</span></span><br><span class="line">      <span class="attr">mutations</span>:&#123;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//模块中action也是处理异步操作,里面的方法默认的参数是context,不过这个context能commit的方法自能是自身的mutations中的方法</span></span><br><span class="line">      <span class="comment">//context.也可以得到rootGetters和rootState</span></span><br><span class="line">      <span class="attr">actions</span>:&#123;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//模块中的getters有三个默认参数,前两个和大的store的getters一样,一个是state(自己的state),一个是getters自身.</span></span><br><span class="line">      <span class="comment">// 模块中特有的第三个是默认参数是rootState,即大的store中的state</span></span><br><span class="line">      <span class="attr">getters</span>:&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h3 id="vuex响应式规则"><a href="#vuex响应式规则" class="headerlink" title="vuex响应式规则"></a>vuex响应式规则</h3><p>规则:需要提前在store中初始化好所需的属性</p><p>响应式修改数据方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue.set(想要修改的数组或类,数组的下标或者类的属性名,修改后的内容)</span></span><br><span class="line"><span class="comment">//响应式修改state</span></span><br><span class="line">    <span class="function"><span class="title">updateStus</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//响应式的添加address属性</span></span><br><span class="line">      Vue.set(state.stus[<span class="number">0</span>],<span class="string">&quot;address&quot;</span>,<span class="string">&quot;遵化&quot;</span>)</span><br><span class="line">      <span class="comment">//响应式的删除address属性</span></span><br><span class="line">      Vue.delete(state.stus[<span class="number">0</span>],<span class="string">&quot;address&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="mutations类型"><a href="#mutations类型" class="headerlink" title="mutations类型"></a>mutations类型</h3><p>新建mutations-types.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE = <span class="string">&#x27;update&#x27;</span></span><br></pre></td></tr></table></figure><p>在App.vue中(即任何页面文件)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  UPDATE</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-types&quot;</span>;</span><br></pre></td></tr></table></figure><p>在页面的methods中使用时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.commit(UPDATE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  UPDATE</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在mutations的对应的方法</span></span><br><span class="line">[UPDATE](state)&#123;</span><br><span class="line">      <span class="comment">//响应式的添加address属性</span></span><br><span class="line">      Vue.set(state.stus[<span class="number">0</span>],<span class="string">&quot;address&quot;</span>,<span class="string">&quot;遵化&quot;</span>)</span><br><span class="line">      <span class="comment">//响应式的删除address属性</span></span><br><span class="line">      <span class="comment">// Vue.delete(state.stus[0],&quot;address&quot;)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="封装成优雅的目录组织"><a href="#封装成优雅的目录组织" class="headerlink" title="封装成优雅的目录组织"></a>封装成优雅的目录组织</h3><p>index.js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">&quot;./modules/moduleA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&quot;./mutations&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&quot;./actions&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&quot;./getters&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> state =&#123;</span><br><span class="line">  <span class="attr">counter</span>:<span class="number">1000</span>,</span><br><span class="line">  <span class="attr">stus</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;curry&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>:<span class="number">14</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;james&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>:<span class="number">22</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>:<span class="number">31</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  <span class="attr">modules</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>将mutations,getters,actions和modules都抽离出去然后导入</p><p>如mutations如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;UPDATE&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">    state.counter++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">    state.counter--</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//比如加几需要通过调用传入</span></span><br><span class="line">  <span class="function"><span class="title">increase</span>(<span class="params">state,num</span>)</span>&#123;</span><br><span class="line">    state.counter += num</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//响应式修改state</span></span><br><span class="line">  [UPDATE](state)&#123;</span><br><span class="line">    <span class="comment">//响应式的添加address属性</span></span><br><span class="line">    Vue.set(state.stus[<span class="number">0</span>],<span class="string">&quot;address&quot;</span>,<span class="string">&quot;遵化&quot;</span>)</span><br><span class="line">    <span class="comment">//响应式的删除address属性</span></span><br><span class="line">    <span class="comment">// Vue.delete(state.stus[0],&quot;address&quot;)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的也类似,最后的store目录结构如下图(忽略index-copy.js)</p><img src="/2021/04/06/vue%E7%AC%94%E8%AE%B0/devApp\blog\source\_posts\vue笔记.assets\image-20210425161523128.png" alt="image-20210425161523128" style="zoom:50%;"><h2 id="开发项目"><a href="#开发项目" class="headerlink" title="开发项目"></a>开发项目</h2><p>1对项目目录结构进行划分</p><h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>1 app.message修改数据,vue内部是如何监听message数据的改变</p><p>​    Object.defineProperty 监听对象属性的改变</p><p>2 当数据发生改变时,vue时如何知道要通知哪些人,界面发生刷新</p><p> 发布订阅者模式</p><h1 id="vue官方文档笔记"><a href="#vue官方文档笔记" class="headerlink" title="vue官方文档笔记"></a>vue官方文档笔记</h1><h2 id="计算属性vs方法"><a href="#计算属性vs方法" class="headerlink" title="计算属性vs方法"></a>计算属性vs方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>计算后的message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>调用方法后的message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="attr">reversedMessage</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。<strong>只在相关响应式依赖发生改变时它们才会重新求值</strong>。<strong>这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</strong></p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong>。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p><h2 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h2><p>不同的是带有 <strong><code>v-show</code> 的元素始终会被渲染并保留在 DOM</strong> 中。<code>v-show</code> 只是简单地切换元素的 **CSS property <code>display</code>**。</p><p><strong><code>v-if</code></strong> 是“真正”的条件渲染，因为它会确保<strong>在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建</strong>。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p><strong>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</strong></p><h2 id="钩子函数-生命周期"><a href="#钩子函数-生命周期" class="headerlink" title="钩子函数(生命周期)"></a>钩子函数(生命周期)</h2><p><code>beforeCreate()</code> 在实例创建之间执行，数据未加载状态</p><p><code>created()</code> 在实例创建、数据加载后，能初始化数据，<code>dom</code>渲染之前执行</p><p><code>beforeMount()</code> 虚拟<code>dom</code>已创建完成，在数据渲染前最后一次更改数据</p><p><code>mounted()</code> 页面、数据渲染完成，真实<code>dom</code>挂载完成</p><p><code>beforeUpadate()</code> 重新渲染之前触发</p><p><code>updated()</code> 数据已经更改完成，<code>dom</code> 也重新 <code>render</code> 完成,更改数据会陷入死循环</p><p><code>beforeDestory()</code> 和 <code>destoryed()</code> 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行</p><h2 id="访问父组件实例"><a href="#访问父组件实例" class="headerlink" title="访问父组件实例"></a>访问父组件实例</h2><p>this.$parent</p><p>可以通过这种方法取出父组件的数据或者方法</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><code>provide</code> 选项允许我们指定我们想要提供给后代组件的数据/方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件中通过provide提供</span></span><br><span class="line"><span class="attr">provide</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">posts</span>: <span class="built_in">this</span>.posts</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在子组件中通过inject注入</span></span><br><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;posts&#x27;</span>],</span><br></pre></td></tr></table></figure><p>使用的时候用法和props一样</p><p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的 property</li><li>后代组件不需要知道被注入的 property 来自哪里</li></ul><hr><p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的 property 是<strong>非响应式的</strong>。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E6%A0%B9%E5%AE%9E%E4%BE%8B">使用 <code>$root</code></a>做这件事都是不够好的。如果想要提供响应式的话可以提供this,这样this中的data和props等均是响应式的,也就能够响应式.</p><hr><h2 id="路由Hash和History"><a href="#路由Hash和History" class="headerlink" title="路由Hash和History"></a>路由Hash和History</h2><p>Hash 丑,无法使用锚点定位</p><p>History 需要后端配合,IE9不兼容(可使用强制刷新处理)</p><p><img src="/2021/04/06/vue%E7%AC%94%E8%AE%B0/devApp\myblog\source_posts\vue笔记.assets\image-20210518093857934.png" alt="image-20210518093857934"></p><p>前面的几种操作会触发源代码中的updateRoute,再由updateRoute里面去改变响应式数据,响应式数据改变了之后会自动触发router-view的更新</p><h2 id="单页面应用-SPA"><a href="#单页面应用-SPA" class="headerlink" title="单页面应用(SPA)"></a>单页面应用(SPA)</h2><p>缺点: 不利于SEO(服务器渲染SSR解决),首屏加载时间长(预渲染解决)</p><h2 id="vue如何追踪变化"><a href="#vue如何追踪变化" class="headerlink" title="vue如何追踪变化"></a>vue如何追踪变化</h2><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><img src="/2021/04/06/vue%E7%AC%94%E8%AE%B0/devApp\myblog\source\_posts\vue笔记.assets\image-20210518143956099.png" alt="image-20210518143956099" style="zoom: 33%;"><p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一行代码</title>
      <link href="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(FirstActivity.<span class="keyword">this</span>,<span class="string">&quot;您点击了这个按钮&quot;</span>,Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure><p>第一个参数：上下文</p><p>第二个参数：现实的内容</p><p>第三个参数：显示时常</p><h3 id="获取layout中的组件"><a href="#获取layout中的组件" class="headerlink" title="获取layout中的组件"></a>获取layout中的组件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.mybutton);</span><br></pre></td></tr></table></figure><p>需要事先在layout中定义id为mybutton的按钮。</p><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示intent跳转secondActivity</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式intent</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个intent只能指定一个action，但是能指定多个category</span></span><br><span class="line">intent.addCategory(<span class="string">&quot;com.example.activitytest.MY_CATEGORY&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更多的隐式Intent</span></span><br><span class="line"><span class="comment">//打开系统自带浏览器访问百度</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;http://www.baidu.com&quot;</span>));</span><br><span class="line"><span class="comment">//拨号</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;tel:10086&quot;</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>在第一层活动中使用putExtra方法将数据存在Intent中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//传递数据给下一个活动</span><br><span class="line">String data= &quot;传递的数据&quot;;</span><br><span class="line">Intent intent = new Intent(FirstActivity.this,SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;data&quot;,data);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>在第二层活动中取出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//接收上一层活动传过来的数据</span><br><span class="line">Intent intent = getIntent();//获取用于启动第二层活动的Intent</span><br><span class="line">String data = intent.getStringExtra(&quot;data&quot;);//获取第一层传入的数据</span><br><span class="line">Log.d(&quot;SecondActivity&quot;, data);</span><br></pre></td></tr></table></figure><h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>在上一层活动中使用startActivityForResult()方法来跳转到下一个活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受下一层活动传回来的数据</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line"><span class="comment">//第二个参数为requescode，用来判断是从哪个活动中传来的数据</span></span><br><span class="line">startActivityForResult(intent,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在下一层活动中传递数据到上一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递数据到上一层</span></span><br><span class="line">Button button = (Button) findViewById(R.id.mybutton2);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(<span class="string">&quot;data_return&quot;</span>,<span class="string">&quot;这是第二层向第一层传递的数据&quot;</span>);</span><br><span class="line">        <span class="comment">//第一个参数为resulcode</span></span><br><span class="line">        setResult(RESULT_OK,intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为在上一层活动中使用startActivityForResult()方法来启动到下一个活动，在下一个活动销毁时会自动调用上一个活动的onActivityResult()方法，因此需要在上一层活动中重写这个方法来获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过requestCode判断是否为第二层传入的数据</span></span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK)&#123;</span><br><span class="line">                String resultData = data.getStringExtra(<span class="string">&quot;data_return&quot;</span>);</span><br><span class="line">                Log.d(TAG, resultData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h4><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201202153001306.png" alt="image-20201202153001306" style="zoom: 33%;"><h4 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h4><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201202153442928.png" alt="image-20201202153442928" style="zoom:50%;"><h4 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h4><p>共有四种启动模式:standard,singleTop,singleTask,</p><p>standard:默认的启动模式,当当前活动启动的任然是当前活动时,<strong>不管返回栈是否存在</strong>这个活动,每次启动都会创建该活动一个新的实例.</p><p>singleTop:在启动活动时发现返回栈的<strong>栈顶</strong>已经是该活动,则认为可以直接使用,而不会再创建新的活动.但如果此时这个活动不在栈顶,则会再创建该活动的一个新的实例.</p><p>singleTask:当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在<strong>返回栈</strong>中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并<strong>把在这个活动之上的所有活动统统出栈</strong>，如果没有发现就会创建一个新的活动实例。</p><p>singleInstance:不同于以上3种启动模式，指定为singleInstance模式的活动会<strong>启用一个新的返回栈</strong>来管理这个活动(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。那么这样做有什么意义呢?想象以下场景，假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢?使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题,<strong>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动,都共用的同一个返回栈，也就解决了共享活动实例的问题</strong>。</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><p>首先在activity_main.xml中添加LIstView组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/list&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure><p>然后在activity中添加数据,ListView中的数据不能直接传入,需要使用适配器传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data = &#123; <span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;watermelon&quot;</span> ,</span><br><span class="line">            <span class="string">&quot;Pear&quot;</span>,<span class="string">&quot;Grape&quot;</span>,<span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>,<span class="string">&quot;Mango&quot;</span>,<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> ,<span class="string">&quot;watermelon&quot;</span>,<span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span> , <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ArrayAdapter arrayAdapter = <span class="keyword">new</span> ArrayAdapter(MainActivity.<span class="keyword">this</span>,android.R.layout.simple_list_item_1,data);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list);</span><br><span class="line">        listView.setAdapter(arrayAdapter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用ArrayAdapter适配器,有多种构造方法,这里共有三个参数,依次传人当前上下文、ListView子项布局的 id，以及要适配的数据。注意，我们使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。这样适配器对象就构建好了。然后调用setAdapter方法传入适配器.</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播分类:</p><p>标准广播（Normal broadcasts ）:是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</p><p>有序广播(Ordered broadcasts ):则是一种同步执行的广播，在广播发出之后，同-时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><h4 id="SharedPerferences"><a href="#SharedPerferences" class="headerlink" title="SharedPerferences"></a>SharedPerferences</h4><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201207140333584.png" alt="image-20201207140333584" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.save);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SharedPreferences.Editor editor = getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE).edit();</span><br><span class="line">        editor.putString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        editor.putInt(<span class="string">&quot;age&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        editor.apply();</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;保存成功&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201207140451502.png" alt="image-20201207140451502" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button button1 = (Button) findViewById(R.id.read);</span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE);</span><br><span class="line">        String name = sharedPreferences.getString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = sharedPreferences.getInt(<span class="string">&quot;age&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;姓名是:&quot;</span>+name+<span class="string">&quot;年龄是:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Litepal操纵数据库"><a href="#Litepal操纵数据库" class="headerlink" title="Litepal操纵数据库"></a>Litepal操纵数据库</h4><h5 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h5><p>1.首先再build.gardle中引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.litepal.android:core:1.5.0&#x27;</span></span><br></pre></td></tr></table></figure><p>2.在main中新建一个assets目录,在assets目录下新建一个litepal.xml文件,内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">&quot;BookStore&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于设定所有的映射模型,即你定义数据库表的类名路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">&quot;com.fx.sqlitetest.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.修改AndroidManifest.xml中的代码,让litepal的所有正常工作</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208134121215.png" alt="image-20201208134121215" style="zoom: 50%;"><p>即在application中添加android:name=”org.litepal.LitePalApplication</p><p>下面就可以使用啦</p><p>4.创建新的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fx.sqlitetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.litepal.crud.DataSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">DataSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二步的mapping中映射这个类然后进行任意数据库操作就可以自动创建相应的表和属性啦</p><p>如在主活动中使用Connector.getDatabase();</p><p>如果想要添加一个类就新建然后再mapping中设置映射,再将版本号更改成更高一级就好啦!</p><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">       Button button = (Button) findViewById(R.id.button);</span><br><span class="line">       button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">               Book book1 = new Book();</span><br><span class="line">               book1.setName(&quot;水浒传&quot;);</span><br><span class="line">               book1.setAuthor(&quot;梁朝伟&quot;);</span><br><span class="line">               book.save();</span><br><span class="line">               </span><br><span class="line">               //这是更高级一些的更新方法,即对书名字为三国演义,作者为不知道的书进行更新</span><br><span class="line">               //book1.updateAll(&quot;name = ? and author = ?&quot;,&quot;三国演义&quot;,&quot;不知道&quot;);</span><br><span class="line">               </span><br><span class="line">               List&lt;Book&gt; bookList = DataSupport.findAll(Book.class);</span><br><span class="line">               //使用循环并利用日志打印所有值</span><br><span class="line">               for (Book book : bookList) &#123;</span><br><span class="line">                   Log.d(&quot;Data&quot;, book.getName());</span><br><span class="line">                   Log.d(&quot;Data&quot;, book.getAuthor());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSupport.deleteAll(Book.class,<span class="string">&quot;name=?&quot;</span>,<span class="string">&quot;水浒传&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Book&gt; bookList = DataSupport.findAll(Book.class);</span><br><span class="line">   <span class="comment">//使用循环并利用日志打印所有值</span></span><br><span class="line">   <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">       Log.d(<span class="string">&quot;Data&quot;</span>, book.getName());</span><br><span class="line">       Log.d(<span class="string">&quot;Data&quot;</span>, book.getAuthor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的高级查询方式</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208135619931.png" alt="image-20201208135619931" style="zoom:50%;"><h3 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h3><h4 id="Adroid权限"><a href="#Adroid权限" class="headerlink" title="Adroid权限"></a>Adroid权限</h4><p>权限分为普通权限和危险权限,普通权限会进行自动授权,危险权限则需要用户授权,其中危险权限包括如下:</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208140648039.png" alt="image-20201208140648039" style="zoom:50%;"><h5 id="拨打电话"><a href="#拨打电话" class="headerlink" title="拨打电话"></a>拨打电话</h5><p>在Mainfest中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure><p>修改mainactivity中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Button button = (Button)findViewById(R.id.button);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.CALL_PHONE)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                <span class="comment">//拨打电话的权限未被授予</span></span><br><span class="line">                ActivityCompat.requestPermissions(</span><br><span class="line">                        MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> String[] &#123;Manifest.permission.CALL_PHONE&#125;,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//拨打电话的权限被授予则进行拨打</span></span><br><span class="line">                call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拨打电话的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">&quot;tel:10086&quot;</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length&gt;<span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>]==PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                call();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;您未授权&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h4><p>以访问联系人为例,大部分之前都涉及了,直接堆代码了</p><p>首先赋予权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主活动中代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayAdapter&lt;String&gt; arrayAdapter;</span><br><span class="line">    List&lt;String&gt; contactList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ListView contactsView = (ListView)findViewById(R.id.myList);</span><br><span class="line">        arrayAdapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,contactList);</span><br><span class="line">        contactsView.setAdapter(arrayAdapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.READ_CONTACTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            readContacts();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readContacts</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cursor c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(c.moveToNext())&#123;</span><br><span class="line">                    String name = c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));</span><br><span class="line">                    String number = c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">                    contactList.add(name+<span class="string">&quot;\n&quot;</span>+number);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                arrayAdapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                c.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(grantResults.length&gt;<span class="number">0</span>&amp;&amp;grantResults[<span class="number">0</span>]==PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    readContacts();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;您没有授予权限&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要观察readContacts()方法.</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/devApp\blog\source\_posts\第一行代码.assets\image-20201209123305891.png" alt="image-20201209123305891" style="zoom:50%;"><h3 id="使用网络技术"><a href="#使用网络技术" class="headerlink" title="使用网络技术"></a>使用网络技术</h3><h4 id="使用okhttp"><a href="#使用okhttp" class="headerlink" title="使用okhttp"></a>使用okhttp</h4><p>在build.gradle的dependencies中加载依赖</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttp</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:3.14.2&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okio:okio:1.17.4&#x27;</span></span><br></pre></td></tr></table></figure><p>并build.gradle的android中添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/devApp\blog\source\_posts\第一行代码.assets\image-20201210103636399.png" alt="image-20201210103636399" style="zoom: 33%;"><p>赋予权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布局文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/send&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;发送http请求&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/scrollView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/resText&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主活动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TextView resText;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    Button button = (Button)findViewById(R.id.send);</span><br><span class="line">    resText = (TextView)findViewById(R.id.resText);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            sendHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendHttpRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;https://api-hmugo-web.itheima.net/api/public/v1/goods/detail?goods_id=1&quot;</span>).build();</span><br><span class="line">                Response response = client.newCall(request).execute();</span><br><span class="line">                String responseData = response.body().string();</span><br><span class="line">                showResponse(responseData);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String responseData)</span></span>&#123;</span><br><span class="line">    runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在这里进行ui操作,结果将显示到界面上</span></span><br><span class="line">            resText.setText(responseData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要在showResponse()方法中调用runOnUiThread()这个方法呢?因为在<strong>android中是不允许在子线程中进行ui操作的</strong>,需要通过调用这个方法切换到主线程,然后再更新ui元素.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2021/04/02/%E5%89%91%E6%8C%87offer/"/>
      <url>/2021/04/02/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>①举几个简单的具体例子让自己理解问题</p><p>②试着用图形表示抽象的数据结构</p><p>③试着把复杂的问题分解成若干的简单的子问题.(递归,分治法,动态规划)</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>①数组中的数字如果不存在重复的话,那么正常排序后数字i应该在下标为i的地方,可以根据这个对数组中数字的位置进行交换,从而发现重复.(剑指 Offer 03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a> )</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2020/11/17/css/"/>
      <url>/2020/11/17/css/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>优先级的规则<br>    内联样式，优先级1000<br>    id选择器，优先级100<br>    类和伪类，优先级10<br>    元素选择器，优先级1<br>    通配*，优先级0<br>    继承的样式，没有优先级</p><h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><p>长度单位</p><h3 id="像素px"><a href="#像素px" class="headerlink" title="像素px"></a>像素px</h3><p>​        像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的但是这些像素点，是不能直接看见。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。</p><h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比%"></a>百分比%</h3><p>​        也可以将单位设置为一个百比的形式，这样浏览器将会根据其父元素的样式来计算该值。使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变在我们创建一个自适应的页面时，经常使用百分比作为单位</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>​    em和百分比类似，它是相对于当前元素的字体大小来计算的</p><p>​    1em = 1font-size</p><h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口的宽度,100vm就是整个视口的宽度.</p><p>vm和百分比的区别:vm永远都相对于整个视口,而百分比参照的会随父元素的变化而改变</p><h2 id="垂直外边距的重叠"><a href="#垂直外边距的重叠" class="headerlink" title="垂直外边距的重叠"></a>垂直外边距的重叠</h2><p>在网页中<strong>相邻的垂直方向</strong>的外边距会发生外边距的重叠</p><h3 id="兄弟外边距折叠"><a href="#兄弟外边距折叠" class="headerlink" title="兄弟外边距折叠"></a>兄弟外边距折叠</h3><p>所谓的兄弟外边距重叠指垂直方向上兄弟元素之间的相邻外边距会取最大值而不是取和</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;up&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#up</span>,<span class="selector-id">#bottom</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#up</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="comment">/* 设置margin-bottom和margin-right会移动相邻的元素,自身不移动 */</span></span></span><br><span class="line"><span class="css"><span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#bottom</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="comment">/* 设置margin-top和margin-left会移动自身元素,相邻元素不移动 */</span></span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码对上面的div设置了margin-bottom,对下面的元素设置了margin-top.相邻的垂直方向的外边距会发生外边距的重叠,外边距重叠指兄弟元素之间的相邻外边距会取最大值,所以两个div的距离仍然是100,而不是200如下</p><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602134028697.png" alt="image-20210602134028697" style="zoom:25%;"><p>如果两个外边距全是正数,则取两个数的和</p><p>如果两个外边距一正一负,则取两个数的和</p><p>如果两个外边距全是负数,则取两个数绝对值大的那个</p><h3 id="父子外边距折叠"><a href="#父子外边距折叠" class="headerlink" title="父子外边距折叠"></a>父子外边距折叠</h3><p>如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素(上外边距)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码只给里面的子元素加了上外边距 但是效果如下,外面的父元素也随之移动</p><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602140713028.png" alt="image-20210602140713028" style="zoom:25%;"><p>解决办法:</p><p>(1)对父元素使用内边距</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;<span class="comment">/*将父元素高度减去多余的高度*/</span></span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">padding-top</span>: <span class="number">100px</span>; <span class="comment">/*对父元素使用内边距*/</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602141639336.png" alt="image-20210602141639336" style="zoom:25%;"><p>(2)给外边距加boder</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">199px</span>;<span class="comment">/*将父元素的高度减去boder的宽度*/</span></span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border-top</span>: <span class="number">1px</span> <span class="number">#00FFFF</span> solid;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">99px</span>;<span class="comment">/*子元素外边距减去boder的宽度*/</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)使用伪元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.inner</span><span class="selector-pseudo">::before</span>&#123;<span class="comment">/*伪元素*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>:table;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="内联元素和块元素盒子模型"><a href="#内联元素和块元素盒子模型" class="headerlink" title="内联元素和块元素盒子模型"></a>内联元素和块元素盒子模型</h2><ul><li><p>内联元素不能设置width和height</p></li><li><p>内联元素可以设置水平方向的内边距；也可以设置<strong>垂直方向的内边距</strong>，但是<strong>不会影响页面的布局</strong>，即若内联元素下方有其他元素，上方的内联元素内边距过大时会覆盖下方的元素。而块元素则会将下面的元素往下面挤。</p></li><li><p>内联元素可以设置边框，但是<strong>垂直的边框不会影响页面的布局</strong>。</p></li><li><p>内联元素可以设置外边距；<strong>垂直方向的外边距不会影响页面的布局</strong>。水平方向上会影响并且不会产生外边距重叠</p></li></ul><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>将一个内联元素变成块元素，通过display样式可以修改元素的类型<br>可选值:</p><ul><li>inline:可以将一个元素作为内联元素显示</li><li>block:可以将一个元素设置块元素显示</li><li>inline-block:将一个元素转换为行内块元素， 可以使一个元素既有行内元素的特点又有块元素的特点：既可以设置宽高，又不会独占一行</li><li>none:不显示元素，并且元素不会在页面中继续占有位置</li></ul><h2 id="visibility：hidden和display：none的区别"><a href="#visibility：hidden和display：none的区别" class="headerlink" title="visibility：hidden和display：none的区别"></a>visibility：hidden和display：none的区别</h2><p>visibility<br>    可以用来设置元素的隐藏和显示的状态<br>    可选值:<br>    visible默认值，元素默认会在页面显示<br>    hidden元素会隐藏不显示<br><strong>使用visibility:hidden;隐藏的元素虽然不会在页面中显示，但是它的位置会依然保持</strong></p><p><strong>display:none ;使用该方式隐藏的元素，不会在页面中显示，并且不再占据页面的位置</strong></p><h2 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h2><p>box-sizing属性</p><p>​    可选值:</p><p>​        content-box    默认值,宽度和高度指定的是内容区</p><p>​        border-box    宽度和高度设置的是可见框的大小,即内容区+内边距+边框</p><h2 id="轮廓阴影和圆角"><a href="#轮廓阴影和圆角" class="headerlink" title="轮廓阴影和圆角"></a>轮廓阴影和圆角</h2><p>outline属性用来设置元素的轮廓线,用法和border一样,区别是轮廓线不会影响可见框的大小,不会影响其他元素的位置</p><p>box-shadow用来设置元素的阴影效果,也不会影响页面的布局</p><p>​    第一个值:水平偏移量,设置阴影的水平位置,正值向右移动,负值向左移动</p><p>​    第二个值:垂直偏移量,设置阴影的垂直位置,正值向下移动,负值向上移动</p><p>​    第三个值:阴影的模糊半径,值越大,阴影越模糊</p><p>​    第四个值,阴影的颜色</p><p>border-radius属性用来设置圆角,设置圆角的半径大小,第一个值为水平方向的半径,第二个值为垂直方向的半径</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>设置了浮动后,元素水平布局的等式不再适用</p><p>浮动的特点:</p><p>​    (1)元素设置了float后会脱离文档流,所以元素下面的还在文档流中的元素会自动向上移动</p><p>​    (2)浮动元素会向父元素的左侧或右侧移动,默认不会从<strong>父元素内容区中</strong>移出</p><p>​    (3)浮动元素不会超过它前面的其他浮动元素,也不会覆盖其它浮动元素</p><p>​    (4)如果浮动元素的上边是一个没有浮动的块元素,则浮动元素无法上移</p><p>​    (5)当不设置浮动时,一个div会自动设置margin-right的值来使其内容区的宽度等于父元素的宽度</p><p>设置了浮动后,元素水平布局的等式不再适用</p><p>浮动的其他特点</p><p>​    (1)浮动元素不会覆盖文字,文字会自动环绕在浮动元素周围(可以利用这个来实现文字环绕图片的效果)</p><p>脱离文档流的特点:</p><p>​    块元素</p><p>​    (1)块元素不再独占一行</p><p>​    (2)脱离文档流后,块元素的宽度和高度默认被内容撑开</p><p>​    行内元素</p><p>​    行内元素脱离文档流后会变成块元素,特点和块元素一样</p><h2 id="高度塌陷和BFC"><a href="#高度塌陷和BFC" class="headerlink" title="高度塌陷和BFC"></a>高度塌陷和BFC</h2><p>高度塌陷:想要使父元素的高度随着子元素的高度改变,即被子元素撑开,从而不设置父元素的具体高度.在这种情况下,子元素使用浮动属性,子元素会脱离文档流,导致无法撑起父元素的高度从而导致高度塌陷.父元素高度丢失之后会导致下面的元素下移,影响页面布局</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>block formatting context 块级格式化环境</p><p>BFC是css中的一个隐含的属性,可以为一个元素开启BFC,该元素会变成一个独立的布局区域</p><p>元素开启BFC后的特点:</p><ul><li>开启BFC后的元素不会被浮动元素覆盖</li><li>开启BFC的元素子元素和父元素外边距不会重叠</li><li>可以包含浮动的子元素</li></ul><p>开启BFC的方法:</p><ul><li><p>设置父元素为浮动(不推荐)</p></li><li><p>将父元素设置为行内块元素(不推荐)这种方法会使行宽不再自动扩大,而是子元素的宽度撑开的大小</p></li><li><p>将父元素的overflow设置为一个非visible的值</p><p>这是常用的方式,父元素overflow:hidden开启</p></li></ul><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>如果我们不希望某个元素因为其他元素浮动的影响而改变位置,可以通过clear属性</p><p>可选值:</p><ul><li>left 清楚左侧浮动元素对当前元素的影响</li><li>right 清除右侧浮动元素对当前元素的影响</li><li>both 清楚两侧中最大影响的那侧</li></ul><p>原理:设置清楚浮动以后,浏览器会自动为元素添加一个<strong>上外边距</strong>,使其位置不受影响</p><h3 id="解决高度塌陷最终方案"><a href="#解决高度塌陷最终方案" class="headerlink" title="解决高度塌陷最终方案"></a>解决高度塌陷最终方案</h3><p>可以在父元素的最下面加一个空的div 标签,设置clear属性,从而撑起父元素,这种方法相当于用html解决css的问题,下面使用伪元素的方式以纯css方式解决.</p><p><strong>使用伪元素选择器</strong>,对父元素使用伪元素选择器相当于在父元素的最后添加一个元素设置其样式.这个伪元素默认为行内元素.下面为示例,其中box1为父元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:block;<span class="comment">/*将伪元素转换为块元素*/</span></span><br><span class="line"><span class="attribute">clear</span>:both;<span class="comment">/*设置clear属性使其不受浮动元素影响,从而撑起父元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个既解决高度塌陷,又解决外边距重叠的方法,其中设置父元素的类为clearfix</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>:table;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position可选值:</p><pre><code>- static 默认值,元素是静止的,没有开启定位- relative 相对定位- absolute 绝对定位- fixed 固定定位- sticky 粘滞定位</code></pre><p>对于开启的定位的元素,可以设置z-index设置元素的层级.如果都不设置z-index的话,则靠下的元素层级更高.</p><p>祖先元素的层级再高也不会覆盖后代元素.</p><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>开启后设置偏移量只会影响自己的位置,不影响其他元素</p><p>特点:</p><ul><li>开启后如果不设置偏移量,<strong>页面内得所有元素不会发生任何变化</strong></li><li>相对定位参照与元素在文档流中得位置进行定位得,即<strong>相对于自己本身位置得左上角</strong></li><li>相对定位会提升元素得层级,高于页面中其他元素.(即如果和其他元素重叠,会覆盖其他元素)</li><li>相对定位不会脱离文档流,不会改变元素的性质,即块级元素还是块级元素,行内还是行内</li></ul><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>特点</p><ul><li><p>开启绝对定位后,如果不设置偏移量,<strong>自身元素得位置不会发生变化</strong></p></li><li><p><strong>元素会从文档流中脱离</strong></p></li><li><p>绝对定位会改变元素的性质,块级元素变成行内元素,块得宽高被内容撑开</p></li><li><p>会使元素提升一个层级</p></li><li><p><strong>开启了绝对定位后整个div盒子的宽度要加上left和right</strong></p><ul><li><p>水平方向上,当发生过度约束时,如果9个值中没有auto,则会自动调整right,如果有auto的话,会自动调整auto的值</p><p>可以设置auto的值:margin,width,left,right</p></li><li><p>垂直方向上,等式也必须要满足,这样也<strong>可以用上下外边距都设置为auto,top和bottom都设置为0的方式来使元素垂直居中.但是在非绝对定位时不可以.</strong></p></li></ul></li><li><p>绝对定位参照包含块进行定位,即<strong>相对于离他最近的开启了定位的祖先元素</strong>,如果所有的祖先元素都没有开启定位,则相对于根元素</p><p>包含块:</p><ul><li><p>正常情况下</p><p>包含块就是当前元素<strong>最近的祖先块元素</strong></p></li><li><p>绝对定位包含块</p><p>包含块是离他最近的开启了定位的祖先元素</p></li></ul></li></ul><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>固定定位也是一种绝对定位,大部分特点都和绝对定位一样</p><p>唯一不同的是固定定位永远参考与浏览器的视口进行定位(视口只有浏览器窗口大小,例如网页侧边的广告)</p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>和relative相对定位和相似,不同的是粘滞定位可以在元素到达某个位置时将其固定</p><h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><p>line-height</p><p>行高指的是文字占有的实际高度,可以设置具体的大小(px em),也可以设置整数指定行高是字体大小的倍数,行高会在字体框的上下平均分配,也经常用来设置行间距</p><h2 id="字体居中"><a href="#字体居中" class="headerlink" title="字体居中"></a>字体居中</h2><p>text-align 文字的水平对齐</p><p>可选值:</p><ul><li>left</li><li>right</li><li>center 居中对齐</li><li>justify 两端对齐</li></ul><p>vertical-align文字的垂直对齐方式</p><p>可选值:</p><ul><li>baseline 默认值 基线对齐</li><li>top </li><li>bottom</li><li>middle 居中对齐(和x的中线对齐</li></ul><h2 id="文字超出显示省略号"><a href="#文字超出显示省略号" class="headerlink" title="文字超出显示省略号"></a>文字超出显示省略号</h2><p>white-space 设置网页如何处理文字的空白区域</p><p>可选值:</p><ul><li>normal 正常,即如果文字需要换行的时候,一个单词盛不下会换行</li><li>nowrap 不换行,一行中显示所有文字,会自动撑开div的宽度</li><li>pre 保留空白 即文字在html中是什么样式就显示什么样式,会保留空格和回车</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文字超出显示省略号*/</span></span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line">text-flow:ellipsis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹性盒flex"><a href="#弹性盒flex" class="headerlink" title="弹性盒flex"></a>弹性盒flex</h2><h3 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h3><p>​    display:flex;</p><p>flex-direction 指定容器中弹性元素的排列方式,可选值:</p><ul><li>row 默认值,弹性元素在容器中水平排列(左向又),主轴自左向右</li><li>row-reverse 水平排列,从右向左</li><li>column 纵向排列(自上向下)</li><li>column-reverse 纵向自下向上</li></ul><p>flex-wrap 设置弹性元素在容器横向装不下的时候是否自动换行</p><ul><li>nowrap 默认值 元素不会自动换行</li><li>wrap 元素沿着辅轴方向自动换行</li><li>wrap-reverse 元素沿着辅轴反方向换行</li></ul><p>justify-content 主轴上的元素如何排列,主轴空白空间的分布</p><ul><li>flex-start 元素沿着主轴的起边排列,即从左开始</li><li>flex-end 元素沿着主轴终边排列</li><li>center 元素居中排列</li><li>space-around 容器中的空白分布到元素两侧(这样会使中间的元素空隙大一些,因为中间的元素空隙为左边元素分配到的加上右边元素分配到的)</li><li>space-between 空白均匀分布到元素中间,两边不再有空白</li><li>space-evenly 空白分布到元素单侧</li></ul><p>align-items 元素在辅轴上如何对齐</p><ul><li>stretch 默认值将元素的长度设置成相同的值,使其填满整个容器(每一行的高度相同,第一行和第二行不一定相同)</li><li>flex-start 元素不会拉伸,沿着辅轴的垂直方向起边对齐</li><li>flex-start 元素不会拉伸,沿着辅轴的垂直方向终边对齐</li><li>center</li></ul><p>align-content 辅轴空白空间的分布</p><ul><li>center 所有元素都在中间,上下空白空间相等</li></ul><h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>flex-grow 当父元素有多余空间时,子元素如何伸展,父元素的剩余空间会按照比例进行分配,默认是0</p><p>​    例如父元素宽度为 300,两个子元素宽度分别为100,此时父元素剩余100的宽度,为子元素分别设置flex-grow:1;和flex-grow:2;则父元素剩余的100宽度会按1:2的比例分配给两个子元素,使两个子元素盛满整个父元素</p><p>flex-shrink 当父元素的空间不足以容纳所有的子元素时,如何对子元素进行收缩</p><p>flex-basis 设置元素在主轴上的长度</p><p>flex 前三个属性的缩写,顺序:增长 缩减 基础.</p><p>align-self 用来覆盖当前弹性元素上的align-items,即不再受容器中的align-items属性约束,使用自己的设置的在辅轴上的对齐方式</p><p>order 指定弹性元素的排列顺序,传入整数数值,数值越小越靠前</p><h2 id="像素-移动端适配"><a href="#像素-移动端适配" class="headerlink" title="像素(移动端适配)"></a>像素(移动端适配)</h2><p>可以通过meta标签来设置视口大小,由此来调整像素比</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;200px&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>视口大小调整<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的设置意思是使浏览器的视口为200px(css像素),假如移动端的屏幕宽度为750px(物理像素),那么像素比就为200”750</p><p>每一款移动设备设计时,都会有一个最佳像素比,将像素比设置为最佳像素比的视口大小,我们称其为完美视口.下面是适用于任何设备达到最佳像素比的设置方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="文字垂直居中"><a href="#文字垂直居中" class="headerlink" title="文字垂直居中"></a>文字垂直居中</h3><p>设置行高与外面包裹文字的元素高度相等,可以实现文字垂直居中的效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序</title>
      <link href="/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><h2 id="列表循环"><a href="#列表循环" class="headerlink" title="列表循环"></a>列表循环</h2><p>1 wx:for=”“  wx:for-item=”循环项的名称”  wx:for-index=”循环项的索引”</p><p>2 wx:key=”唯一的值”用来提高列表渲染的性能</p><p>​    1 wx:key 绑定一个普通的字符串的时候,那么这个字符串名称肯定是循环数组中的对象的唯一属性</p><p>​    2 wx:key=”*this” 表示这个数组是一个普通数组,”*this” 就是循环项.比如[1,2,3,52]</p><h2 id="对象循环"><a href="#对象循环" class="headerlink" title="对象循环"></a>对象循环</h2><p>1 wx:for=”“  wx:for-item=”对象的值”  wx:for-index=”对象的属性”</p><h1 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h1><p>例如需求为文本框中的内容发生改变,下面的view 中的数据也随之发生改变</p><p>首先在data中定义num=0之后编辑wxml文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleInput&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  &#123;&#123;num&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中bindinput作用是监听文本框发生改变,接下来在js文件中编写handleInput方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleInput</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">num</span>: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小程序中修改数据的语法为this.setData({ }).其中e中包含传入的文本框中的值</p><h1 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h1><h2 id="自定义组件的基本使用"><a href="#自定义组件的基本使用" class="headerlink" title="自定义组件的基本使用"></a>自定义组件的基本使用</h2><p>在项目中新建components文件夹,在components文件夹下新建tabs文件夹,在tabs文件夹下新建components命名为Tabs,这样自定义组件就建好了</p><p>需要使用自定义组件的时候只需在响应界面的json中添加响应的组件和路径比如下面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Tabs&quot;</span>:<span class="string">&quot;../../components/tabs/Tabs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在页面的wxml文件中使用命名的组件作为标签即可,如<Tabs></Tabs></p><h2 id="tabbar实例"><a href="#tabbar实例" class="headerlink" title="tabbar实例"></a>tabbar实例</h2><p>接下来展示一个tabbar 的实例,实现结果如图</p><img src="/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/devApp\blog\source\_posts\小程序.assets\image-20210422135024938.png" alt="image-20210422135024938" style="zoom: 33%;"><p>首先在Tabs.js中定义tabbar的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    tabs:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        title:<span class="string">&quot;首页&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        title:<span class="string">&quot;购物车&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">3</span>,</span><br><span class="line">        title:<span class="string">&quot;我的&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来编辑wxml界面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;handleTap&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中bindtap是用来绑定点击事件,data-index是需要传递给绑定事件的参数,当点击时可以在e中获取,详细请看下面的handleTap方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleTap</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = e.currentTarget.dataset.index;</span><br><span class="line">      <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">      tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        tabs</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来修改样式文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tabs-item</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title-item</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父向子传递数据"><a href="#父向子传递数据" class="headerlink" title="父向子传递数据"></a>父向子传递数据</h2><p>父组件(页面)向子组件(自定义组件)传递数据,需要通过标签属性进行传递</p><p>比如上面的tabbar实例,若其他界面也需要用到这个tabbar,但是样式不变,里面的每一项的标题需要改变.这样就可以将标题的数据存在父组件中,然后在子组件中进行接收</p><p>在父组件,即任意的page的js的data中定义tabs数组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    msg:<span class="string">&quot;这是页面二&quot;</span>,</span><br><span class="line">    tabs:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        title:<span class="string">&quot;首页&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        title:<span class="string">&quot;购物车&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">3</span>,</span><br><span class="line">        title:<span class="string">&quot;我的&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再在本页面的wxml使用子组件的地方传出数据,使用标签,名称自定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在Tabs组件的js中接收数据.父向子传递数据,在子组件中的js文件的properties中接收</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    tabs:&#123;</span><br><span class="line">      type:Array,</span><br><span class="line">      value:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是tabs这组数据就可以当作Tabs组件自己的数据进行使用</p><h2 id="子向父传递数据"><a href="#子向父传递数据" class="headerlink" title="子向父传递数据"></a>子向父传递数据</h2><p>进行如上的更改后看起来是没有问题,但是想一想,Tabs组件对点击事件进行处理,即改变数组中被点击的isActive的属性的时候,是将父组件传递的tabs数组当作自己的数据进行更改了.也就是说相当于Tabs组件复制了一份tabs数组对其进行操作,然而父组件中的源数据(也就是父组件中的tabs数组)并没有被更改.</p><p>这时需要在Tabs组件(也就是子组件)中向父组件(也就是page页面)传递一个被点击的页面的index参数,即子向父传递数据,从而在父组件中对源数据(也就是父组件中的tabs数组)进行更改.</p><p>子组件向父组件传递数据使用this.triggerEvent(“父组件自定义事件的名称”,要传递的参数).</p><p>所以更改Tabs组件的js中handleTap方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleTap</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = e.currentTarget.dataset.index;</span><br><span class="line">      <span class="built_in">this</span>.triggerEvent(<span class="string">&quot;itemChange&quot;</span>,index);</span><br><span class="line">      <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">      tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        tabs</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来需要回到父组件中,在父组件的标签上加入一个自定义事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">binditemChange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>binditemChange即”bind”拼接上this.triggerEvent(“itemChange”,index)传入的自定义事件名称.这样就可以在父组件的handleItemChange方法中处理Tabs传进来的数据了</p><p>在父组件的js中定义handleItemChange方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleItemChange</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = e.detail.index;</span><br><span class="line">    <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">    tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样下来就完成了子向父传递数据,并对父组件中的数组进行操作.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解TCP/IP</title>
      <link href="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
      <url>/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/</url>
      
        <content type="html"><![CDATA[<h4 id="分层参考模型"><a href="#分层参考模型" class="headerlink" title="分层参考模型"></a>分层参考模型</h4><p>ISO制定的OSI参考模型，分成了七层。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201031142356957.png" alt="da"></p><p>在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。上下层之间进行交互时所遵循的约定叫做“接口”。同一层之间的交互所遵循的约定叫做“协议。</p><h5 id="各层的功能"><a href="#各层的功能" class="headerlink" title="各层的功能"></a>各层的功能</h5><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201031144647886.png" alt="asda"></p><h5 id="网络层和数据链路层的区别"><a href="#网络层和数据链路层的区别" class="headerlink" title="网络层和数据链路层的区别"></a>网络层和数据链路层的区别</h5><p>网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p><h4 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h4><h5 id="1、面向有连接型和面向无连接型"><a href="#1、面向有连接型和面向无连接型" class="headerlink" title="1、面向有连接型和面向无连接型"></a>1、面向有连接型和面向无连接型</h5><p>面向无连接型包括以太网、UDP等协议。</p><p>面向有连接型包括ATM、帧中继、TCP等协议。</p><h5 id="2、电路交换和分组交换"><a href="#2、电路交换和分组交换" class="headerlink" title="2、电路交换和分组交换"></a>2、电路交换和分组交换</h5><p>在分组交换中，由<strong>分组交换机(路由器)<strong>连接通信线路。分组交换的大致处理过程是:发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，</strong>缓存到自己的缓冲区</strong>，然后再转发给目标计算机。因此，分组交换也有另一个名称:蓄积交换。路由器接收到数据以后会按照顺序缓存到相应的队列当中，再以<strong>先进先出的顺序将它们逐一发送出去</strong>。</p><h5 id="3、根据接收端数量分类"><a href="#3、根据接收端数量分类" class="headerlink" title="3、根据接收端数量分类"></a>3、根据接收端数量分类</h5><p>单播 广播 多播 任播</p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>MAC地址和IP地址在标识一个通讯主体时虽然都具有唯一性，但是只有IP地址具有层次性。</p><h4 id="网络的构成要素"><a href="#网络的构成要素" class="headerlink" title="网络的构成要素"></a>网络的构成要素</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201103150203879.png" alt="image-20201103150203879"></p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201103150226220.png" alt="image-20201103150226220"></p><h5 id="传输速率和吞吐量"><a href="#传输速率和吞吐量" class="headerlink" title="传输速率和吞吐量"></a>传输速率和吞吐量</h5><p>​        在数据传输的过程中，两个<strong>设备之间</strong>数据流动的物理速度称为<strong>传输速率</strong>。单位为bps (Bits Per Second,每秒比特数)。从严格意义上讲，<strong>各种传输媒介中信号的流动速度是恒定的。因此，即使数据链路的传输速率不相同，也不会出现传输的速度忽快忽慢的情况</strong>“。传输速率高也不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。以我们生活中的道路交通为例，低速数据链路就如同车道较少无法让很多车同时通过的情况。与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。传输速率又称作带宽( Bandwidth)。带宽越大网络传输能力就越强。</p><p>​        此外，<strong>主机之间</strong>实际的传输速率被称作<strong>吞吐量</strong>。其单位与带宽相同,都是bps (Bits Per Second)。<strong>吞吐量这个词不仅街量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额(不含报文首部，只计算数据字段本身)等信息</strong>。</p><h5 id="传输设备"><a href="#传输设备" class="headerlink" title="传输设备"></a>传输设备</h5><p>1、中继器：物理层</p><p>①物理层面上延长网络的设备，但不能无限延长。负责对减弱的信号进行<strong>放大和发送</strong>。</p><p>②只负责将电信号转换为光信号，因此<strong>不能在传输速率不同的媒介中转发</strong>。也<strong>不负责判断数据是否发生错误</strong>。</p><p>③集线器可以看成多口中继器，每个端口都可以成为一个中继器。</p><p>2、网桥（2层交换机）：数据链路层</p><p>●网桥根据数据帧的内容转发数据给相邻的其他网络<br>●网桥<strong>没有连接网段个数的限制</strong><br>●网桥基本只用于连接相同类型的网络。但是有时也可以连接<strong>传输速率不同</strong>的网络。</p><p>①数据链路的数据帧有一数据位叫做FCS，用以校验数据是否正确送达目的地。网桥通过检查这个域的值来<strong>丢弃损坏的数据</strong>。</p><p>②网桥还能通过地址自学机制和过滤功能<strong>控制网络流量</strong>。</p><p>③以太网等网络中经常使用的交换集线器(Hub”)，现在基本也属于网桥的一种。交换集线器中连接电缆的每个端口都能提供类似网桥的功能。</p><p>④自学式网桥。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201103164819940.png" alt="image-20201103164819940"></p><p>3、路由器（3层交换机）：网络层</p><p>网桥是根据MAC地址进行处理，而路由器是根据IP地址进行处理</p><p>4、网关</p><p>网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。它与4~7层交换机一样都是处理传输层及以上的数据，但是<strong>网关不仅转发数据还负责对数据进行转换</strong>，它通常会使用一个表示层或应用层网关，<strong>在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><p>MAC地址长48比特</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201106102737993.png" alt="image-20201106102737993"></p><h5 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h5><p>在这种方式下，设备之间使用同一个载波信道进行发送和接收，为此基本上采用半双工通信方式，并对介质进行访问控制。</p><p>共享介质型网络有两种介质访问控制方式：①争用方式②令牌传递方式</p><h6 id="争用方式（CSMA载波监听多路访问）"><a href="#争用方式（CSMA载波监听多路访问）" class="headerlink" title="争用方式（CSMA载波监听多路访问）"></a>争用方式（CSMA载波监听多路访问）</h6><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201106103313606.png" alt="dasd"></p><p>CSMA/CD是一种CSMA改良的方式，其工作原理如下</p><ul><li>如果载波信道上没有数据流动，则任何站都可以发送数据。</li><li>检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立即释放载波信道。</li><li>放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</li></ul><h6 id="令牌传递方式"><a href="#令牌传递方式" class="headerlink" title="令牌传递方式"></a>令牌传递方式</h6><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/image-20201106104106797.png" alt="dawdw"></p><p>优点：①不会有冲突②每个站都有通过平等循环获得令牌的机会，因此即使网络拥堵也不会导致性能下降。</p><p>缺点：数据链路的利用率达不到100%。</p><h5 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h5><p>每个站直连交换机，由交换机负责转发数据帧，全双工通信。</p><p>缺点：一旦交换机发生故障，与之相连的所有计算机将无法通信。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解http</title>
      <link href="/2020/11/07/%E5%9B%BE%E8%A7%A3http/"/>
      <url>/2020/11/07/%E5%9B%BE%E8%A7%A3http/</url>
      
        <content type="html"><![CDATA[<p><img src="http%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="http"></p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p><h4 id="各种协议与HTTP的关系"><a href="#各种协议与HTTP的关系" class="headerlink" title="各种协议与HTTP的关系"></a>各种协议与HTTP的关系</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201022135638710.png" alt="image-20201022135638710"></p><h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>​        统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。<br>​        拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。<br>​        现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。<br>​        那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p><p>​        可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：身份证号：1234567来标识他。不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而<strong>URL就是用定位的方式实现的URI</strong>。</p><p>​        回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。<br>​        对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了<a href="https://link.zhihu.com/?target=http://741236985.html">http://741236985.html</a>，那感觉叫成URI更为合适，不过这样子的话还得想办法找到这个资源咯…</p><h4 id="HTTP1-1请求方法"><a href="#HTTP1-1请求方法" class="headerlink" title="HTTP1.1请求方法"></a>HTTP1.1请求方法</h4><p>GET(获取资源)</p><p>POST(传输实体主体)</p><p>HEAD(获取报文头部)</p><p>PUT(传输文件)</p><p>DELETE(删除文件)</p><p>OPTIONS(询问支持的方法)</p><p>TRACE(追踪路径)：用来确认链接过程中发生的一系列操作</p><p>CONNECT(要求用隧道协议连接代理)      CONNECT 代理服务器名:端口号 HTTP版本</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201024125744129.png" alt="image-20201024125744129"></p><h4 id="请求报文和响应报文的结构"><a href="#请求报文和响应报文的结构" class="headerlink" title="请求报文和响应报文的结构"></a>请求报文和响应报文的结构</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201106225158985.png" alt="图"></p><p>请求行</p><p>包含用于请求的方法，请求url和HTTP版本</p><p>状态行</p><p>包含表明响应结果的状态码，原因短语和HTTP版本</p><p>首部字段</p><p>包含表示请求和响应的各种条件和属性的各类首部</p><p>一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部</p><h4 id="HTTP是无状态协议，不对之前的请求和响应状态进行管理。于是添加可Cookie进行状态管理"><a href="#HTTP是无状态协议，不对之前的请求和响应状态进行管理。于是添加可Cookie进行状态管理" class="headerlink" title="HTTP是无状态协议，不对之前的请求和响应状态进行管理。于是添加可Cookie进行状态管理"></a>HTTP是无状态协议，不对之前的请求和响应状态进行管理。于是添加可Cookie进行状态管理</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-2020.png" alt="图"></p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201024131944288.png" alt="image-20201024131944288"></p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201024131944288.png" alt="da"></p><p>Cookie会根据服务器端的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存这个Cookie，当下次客户端再对服务端发送请求时，客户端会自动再请求报文中加入Cookie值然后发送出去。</p><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201024142856776.png" alt="image-20201024142856776"></p><h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><p>200 ok 表示请求在服务器端被正常处理了</p><p>204 No Content:请求处理成功，但没有资源可以返回。一般在只需要客户端往服务器端发送信息，而服务器端不需要对客户端发送新的信息内容的情况下使用。</p><p>206 Partial Content:该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content- Range指定范围的实体内容。</p><h5 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h5><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><p>301 Moved Permanently ：永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p><p>302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户(本次)能使用新的URI访问。</p><p>303 See Other:该状态码表示由于请求对应的资源存在着另一个URI,<strong>应使用GET方法</strong>定向获取请求的资源。<strong>303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</strong>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另-一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p><p>304 Not Modified :该状态码表示客户端发送附带条件的请求”时，<strong>服务器端允许请求访问资源，但未满足条件的情况</strong>。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在3XX类别中，但是和重定向没有关系。</p><p>307 Temporary Redirect ：临时重定向。</p><h5 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h5><p>400 Bad Request：表示请求报文中存在语法错误</p><p>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证(BASIC认证，DIGEST认证)的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p><p>403 Forbidden：表明请求资源的访问被服务器拒绝了，未获得文件系统的访问授权，访问权限出现某些问题(从未授权的发送源IP地址试图访问)等列举的情况都可能是发生403的原因。</p><p>404 Not Found：服务器上无法找到请求的资源。</p><h5 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h5><p>500 Internal Server Error：该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p><h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>HTTP主要有这些不足，例举如下<br>●通信使用<strong>明文(不加密)</strong>,内容可能会被窃听<br>●不验证<strong>通信方的身份</strong>，因此有可能遭遇伪装<br>●无法证明<strong>报文的完整性</strong>，所以有可能已遭篡改</p><p>HTTPS：把添加了加密处理和认证等机制的HTTP称为HTTPS。与SSL或TLS组合使用的HTTP被称为HTTPS ( HTTP Secure,超文本传输安全协议)或HTTP over SSL。即通过SSL( Secure Socket Layer,安全套接层)加密HTTP的通信内容。SSL不仅提供加密处理，还是用了一种证书的手段用于确定通信方。还能对报文进行完整性保护。</p><p>HTTPS并非是应用层的一-种新协议。只是HTTP通信接口部分用SSL ( Secure Socket Layer )和TLS ( Transport Layer Security)协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS,其实就是身披SSL协议这层外壳的HTTP。</p><h5 id="HTTPS的加密机制"><a href="#HTTPS的加密机制" class="headerlink" title="HTTPS的加密机制"></a>HTTPS的加密机制</h5><p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</p><p>过程：</p><p>①使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥</p><p>②确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201026131022322.png" alt="image-20201026131022322"></p><h5 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h5><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201026135254930.png" alt="image-20201026135254930"></p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201026135327753.png" alt="image-20201026135327753"></p><h5 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h5><p>①因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</p><p>SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU<br>及内存等资源，导致处理速度变慢。</p><p>②除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构(CA)购买。</p><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>Ajax ( Asynchronous JavaScript and XML，异步JavaScript与XML技术)是-一种有效利用JavaScript和DOM ( Document Object Model,文档对象模型)的操作，以达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。</p><p>而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax仍未解决HTTP协议本身存在的问题。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201027102018309.png" alt="image-20201027102018309"></p><h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。<br>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身存在的问题。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3http/image-20201027102150924.png" alt="image-20201027102150924"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记1</title>
      <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/"/>
      <url>/2020/09/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h3 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h3><p>​        在面试题中经常会出现这样一个题目，给一个数组，其中含有N个非负元素，让你求出数组中出现次数超过一半的数字。</p><p>​        看到这个问题我们首先想到的可能是暴力的解法，那就是将数组排个序，输出中间的元素就行了，因为如果出现次数超过一半的话排完序后中间的那个元素肯定是我们需要求的值。</p><p>​        这样做的话排序的时间复杂度一般来说是O(NlogN)，那么有没有时间复杂度为n的算法呢？</p><p>​        投票算法。核心就是<strong>对拼消耗</strong>。</p><p>​        玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。最后能剩下的必定是自己人。（在某乎上看到的通俗解释）</p><p>​        下面进行举例，找出数组中的主要元素，数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>]; <span class="comment">//假设第一个数即为核心元素</span></span><br><span class="line">        <span class="keyword">int</span> account = <span class="number">1</span>;  <span class="comment">//设定一个计数器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==ans)&#123;</span><br><span class="line">                account++; <span class="comment">//如果相等，计数器加一</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                account--;   <span class="comment">//如果不相等，计数器减一</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(account == <span class="number">0</span>)&#123;   <span class="comment">//若计数器等于零，则从下一个数从新开始</span></span><br><span class="line">                ans = nums [i+<span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">                account = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>1、位运算右移一位可代替除以2，左移一位可代替乘2。</p><p>2、对n做右移运算时，一定要考虑到n为负数时的特殊情况。</p><p>3、判断一个数的最后一位是不是1，只需与1做位与运算，若结果为1则最后一位是1，若结果为0则最后一位为0</p><p>4、判断n的奇偶性可以将n和1做位与运算，若结果为1则n为奇数，若结果为0，则n为偶数。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>*双指针,设置一个pre和cur分别指向前一个节点和当前节点(例如反转链表)</p><p>*设置标记,遍历过的节点添加tag属性为true(如判断链表是否有环)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目部署到服务器流程</title>
      <link href="/2020/05/08/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/05/08/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="一-安装JDK"><a href="#一-安装JDK" class="headerlink" title="一 安装JDK"></a>一 安装JDK</h4><h5 id="1-下载64位版本的jdk"><a href="#1-下载64位版本的jdk" class="headerlink" title="1 下载64位版本的jdk"></a>1 下载64位版本的jdk</h5><p>jdk-8u171-linux-x64.tar.gz下载到本地,用xftp传到/usr/local/java中</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2 解压"></a>2 解压</h5><p>tar -xzvf jdk-8u171-linux-x64.tar.gz</p><h5 id="3-配置系统环境变量"><a href="#3-配置系统环境变量" class="headerlink" title="3 配置系统环境变量"></a>3 配置系统环境变量</h5><p>vim /etc/profile  进入对文件的编写，将下面的添加到文件的最后</p><p>JAVA_HOME=/usr/local/java/jdk1.8<br>JRE_HOME=/usr/local/java/jdk1.8/jre<br>PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>export JAVA_HOME JRE_HOME PATH CLASSPATH</p><p>添加后按esc，输入  ：wq   保存并退出编辑。</p><p>source /etc/profile   使配置生效</p><h5 id="4-查看版本"><a href="#4-查看版本" class="headerlink" title="4 查看版本"></a>4 查看版本</h5><p>java -version    查看java版本</p><p>成功！</p><h4 id="二-安装tomcat"><a href="#二-安装tomcat" class="headerlink" title="二 安装tomcat"></a>二 安装tomcat</h4><h5 id="1-下载tomcat"><a href="#1-下载tomcat" class="headerlink" title="1 下载tomcat"></a>1 下载tomcat</h5><p><a href="http://tomcat.apache.org/download-70.cgi">http://tomcat.apache.org/download-70.cgi</a><br>选择core下面的tar.gz包下载</p><h5 id="2上传和安装"><a href="#2上传和安装" class="headerlink" title="2上传和安装"></a>2上传和安装</h5><p>用xftp传到/usr/local/tomcat中</p><h5 id="3-解压"><a href="#3-解压" class="headerlink" title="3 解压"></a>3 解压</h5><p>tar -zxvf apache-tomcat-8.0.33.tar.gz     //解压</p><p>cp -R apache-tomcat-8.0.33 /usr/local/tomcat    //移动和重命名</p><h5 id="4-启动和测试"><a href="#4-启动和测试" class="headerlink" title="4 启动和测试"></a>4 启动和测试</h5><p>./startup.sh  //<strong>在tomcat的bin目录下执行此命令，显示下面的信息</strong></p><p>Using CATALINA_BASE:   /usr/local/tomcat<br>Using CATALINA_HOME:   /usr/local/tomcat<br>Using CATALINA_TMPDIR: /usr/local/tomcat/temp<br>Using JRE_HOME:        /usr/java/jdk1.7.0_67<br>Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar<br>Tomcat started.</p><h5 id="5-设置自动启动"><a href="#5-设置自动启动" class="headerlink" title="5 设置自动启动"></a>5 设置自动启动</h5><p>设置tomcat开机自启</p><p>1、进入编辑<br>vi /etc/rc.d/rc.local<br>2、打开后在最底部复制下面<br>export JDK_HOME=/usr/java/jdk1.6.0_41<br>export JAVA_HOME=/usr/java/jdk1.6.0_41<br>/uer/local/tomcat/bin/startup.sh<br>3、重启服务器，试试能不能访问。<br>Tips:<br>如果JDK和Tomcat安装的目录不跟上面的一样，请修改相应路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发送邮件</title>
      <link href="/2020/05/01/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2020/05/01/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>开发时经常会用到发送邮件或者发送短信来进行验证码验证用户身份。本文介绍如何发送验证码。</p><p>先扔结构和代码！！！！！！</p><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2配置"><a href="#2配置" class="headerlink" title="2配置"></a>2配置</h4><p>首先在resources中新建xml文件命名为applicationContext-mail.xml内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaMailSender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- smtp:发送邮件的协议 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;protocol&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smtp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 邮件服务器的地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smtp.qq.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 端口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;465&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 邮箱用户名字,必须与发件人一致 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;991773829@qq.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个密码不是邮箱登录的密码,是你开启SMTP后台给你发送的面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;rqbmidklfqhsbcdc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaMailProperties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 开启认证,会校验发件人是否为邮箱的用户 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;mail.smtp.auth&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 采用ssl安全方式 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testSend&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fuxing.redlearn.util.TestSend&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaMailSender&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;javaMailSender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2设置发送默认"><a href="#2设置发送默认" class="headerlink" title="2设置发送默认"></a>2设置发送默认</h4><p>新建类，命名TestSend代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fuxing.redlearn.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.MessagingException;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String from;    <span class="comment">//发件人邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String receive; <span class="comment">//收件人邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String cord;    <span class="comment">//验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(String from)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceive</span><span class="params">(String receive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receive = receive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCord</span><span class="params">(String cord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cord = cord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJavaMailSender</span><span class="params">(JavaMailSender javaMailSender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.javaMailSender = javaMailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建邮件</span></span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        <span class="comment">// 邮件包装工具</span></span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</span><br><span class="line">        <span class="comment">// 发件人</span></span><br><span class="line">        helper.setFrom(<span class="string">&quot;991773829@qq.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 收件人</span></span><br><span class="line">        helper.setTo(receive);</span><br><span class="line">        <span class="comment">// 邮件标题</span></span><br><span class="line">        helper.setSubject(<span class="string">&quot;Mail Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//生成验证码</span></span><br><span class="line"><span class="comment">        int cord = CordUtil.getCord();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邮件内容</span></span><br><span class="line">        helper.setText(<span class="string">&quot;你要是收到了这封邮件,代表测试成功!!!验证码:&quot;</span> + cord);</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4生成验证码和发送"><a href="#4生成验证码和发送" class="headerlink" title="4生成验证码和发送"></a>4生成验证码和发送</h4><p>创建CordUtil类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fuxing.redlearn.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.MessagingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CordUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成六位数验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cord = (<span class="keyword">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>);</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) ((Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>));</span><br><span class="line">        <span class="keyword">return</span> cord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送邮件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String receive, String cord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ClassPathXmlApplicationContext conf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext-mail.xml&quot;</span>);</span><br><span class="line">            TestSend ts = (TestSend) conf.getBean(<span class="string">&quot;testSend&quot;</span>);</span><br><span class="line">            ts.setReceive(receive);</span><br><span class="line">            ts.setCord(cord);</span><br><span class="line">            ts.sendMail();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5发送"><a href="#5发送" class="headerlink" title="5发送"></a>5发送</h4><p>接下来在需要用到的地方用CordUtil.sendMail()即可，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送验证码</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/sendMail&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (userService.getMails().contains(userDTO.getMail())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Json.fail(<span class="string">&quot;此邮箱已经被注册&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CordUtil.sendMail(userDTO.getMail(), <span class="string">&quot;hahahhahah&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Json.success(<span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Json.fail(<span class="string">&quot;出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复试算法</title>
      <link href="/2020/03/15/%E5%A4%8D%E8%AF%95%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/15/%E5%A4%8D%E8%AF%95%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>考研复试的算法像比于找工作时的算法较为简单。</p><h4 id="求反序数"><a href="#求反序数" class="headerlink" title="求反序数"></a>求反序数</h4><p>例如1234的反序数为4321(其中的思路也可以用来拆分各位数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">​<span class="keyword">int</span> revx = <span class="number">0</span>;</span><br><span class="line">​<span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">​revx *=<span class="number">10</span>;</span><br><span class="line">​revx += x%<span class="number">10</span>;</span><br><span class="line">​x /= <span class="number">10</span>;</span><br><span class="line">​&#125;</span><br><span class="line">​<span class="keyword">return</span> revx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找的前提是待查找数组有序，所以若给出的是无序数组，可先用sort函数对所给数组进行排序。代码中假设arr[]为带查找数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> target)</span></span>&#123; <span class="comment">//n为待查找数组中元素个数，target为想要查找的数</span></span><br><span class="line">    <span class="keyword">int</span> left= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>; <span class="comment">//取数组中最中间的数为二分查找的开始点</span></span><br><span class="line">        <span class="keyword">if</span>(arr[middle] &lt; target)&#123; <span class="comment">//中间位置的数小于待查找的数，说明在右部</span></span><br><span class="line">            left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle]&gt;target)&#123;<span class="comment">//中间位置的数大于待查找的数，说明在左部</span></span><br><span class="line">            right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查找成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约瑟夫问题变体（队列）"><a href="#约瑟夫问题变体（队列）" class="headerlink" title="约瑟夫问题变体（队列）"></a>约瑟夫问题变体（队列）</h4><p>当用到循环队列模拟求解时，可以把queue队首元素弹出队列后在插入队尾，实现循环效果。</p><p>如从第P个小孩开始报数，则令编号为P的小孩在队首，P之前的小孩依次插入队尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p;++i)&#123;</span><br><span class="line">    children.<span class="built_in">push</span>(children.<span class="built_in">front</span>()); <span class="comment">//将队首的小孩插入队尾</span></span><br><span class="line">    children.<span class="built_in">pop</span>(); <span class="comment">//队首出队</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从第P个小孩开始依次报数（上面代码已经实现把第P个小孩放在队首开始报数），让报到m的小孩出队，则令前m-1个小孩依次从新插入队尾，这样之后排在队首的则是报数为m的小孩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m<span class="number">-1</span>;++i)&#123;</span><br><span class="line">    children.<span class="built_in">push</span>(children.<span class="built_in">front</span>());</span><br><span class="line">    children.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时排在队首的即为报数为m的小孩，令其出队即可。</p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>十进制转为二进制，只需将数字n不断进行对2取模和对2整除运算便可得到各个位数的值。但需要注意的是此时求出来的数位顺序是反向的，因为需要逆序输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; binary; <span class="comment">//创建一个向量用来存储余数</span></span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)&#123; <span class="comment">//将余数存入向量中</span></span><br><span class="line">binary.<span class="built_in">push_back</span>(n%<span class="number">2</span>);</span><br><span class="line">    n/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=binary.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123; <span class="comment">//逆向输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,binary[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 复试算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后恢复MySQL</title>
      <link href="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/"/>
      <url>/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/</url>
      
        <content type="html"><![CDATA[<p><strong>此方法只有在装MySQL时没有装到C盘中时适用</strong></p><p>本人由于考研加之电脑太垃圾就重装了一下系统，很多东西都需要从新配置，所以遇到很多坑，比如接下来的MySQL！！！！！！！！</p><h4 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1.配置环境变量"></a>1.配置环境变量</h4><p>这个应该都知道</p><p>①. 和其实环境变量的配置方法一样，我们打开环境变量配置窗口（组合键win+Pause -&gt; 更改设置 -&gt; 系统属性里选择“高级” -&gt; 环境变量）</p><p>②. 选中系统变量中的“path”，编辑path值，新建输入mysql安装目录下的bin文件夹所在路径：D:\proApp\MySQL\bin，保存退出</p><p><strong>注意：把上面的路径改为你自己电脑中的安装路径</strong></p><p>但把这个做完后我以为就完成了，自信的在cmd中输入mysql -u root -p，结果报错：启动MySQL报错:ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)</p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/mysql4.jpg"><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/mysql4.jpg" alt="alt"></p><h4 id="2-找到安装MySQL的文件夹中的my-ini文件"><a href="#2-找到安装MySQL的文件夹中的my-ini文件" class="headerlink" title="2.找到安装MySQL的文件夹中的my.ini文件"></a>2.找到安装MySQL的文件夹中的my.ini文件</h4><p>在[mysqld]下更改basedir和datadir。basedir改为MySQL安装的位置，datadir改为MySQL目录下的data文件夹，比如我的。</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql1.jpg"></p><h4 id="3-管理员身份打开cmd安装mysql"><a href="#3-管理员身份打开cmd安装mysql" class="headerlink" title="3.管理员身份打开cmd安装mysql"></a>3.管理员身份打开cmd安装mysql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install mysql</span><br></pre></td></tr></table></figure><p>可能提示已经安装：The service already exists!，由于本机中已经安装了mysql服务，所以没关系，继续！</p><p>启动MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>这时应该已经能成功启动了，是不是很激动！</p><h4 id="4-进入mysql"><a href="#4-进入mysql" class="headerlink" title="4.进入mysql"></a>4.进入mysql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>这应该每个人都很熟悉，但是别以为成功了，这时你输入密码会发现以前的密码已经失效，接下来就是重设密码。</p><h4 id="5-设置权限认证跳过"><a href="#5-设置权限认证跳过" class="headerlink" title="5.设置权限认证跳过"></a>5.设置权限认证跳过</h4><p>还是在my.ini文件中的[mysqld]下加上 skip-grant-tables，这样就能跳过密码输入，不需要密码就能进入MySQL。</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql2.png"></p><h4 id="6-重启MySQL"><a href="#6-重启MySQL" class="headerlink" title="6.重启MySQL"></a>6.重启MySQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>如图</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql3.jpg"></p><p>重启后， 以 mysql -u root -p 登陆<br>会发现我们可以不需要密码就可以登陆</p><h4 id="7-重设密码"><a href="#7-重设密码" class="headerlink" title="7.重设密码"></a>7.重设密码</h4><h5 id="首先先选择-mysql-数据库"><a href="#首先先选择-mysql-数据库" class="headerlink" title="首先先选择 mysql 数据库"></a>首先先选择 mysql 数据库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><h5 id="然后更新-password"><a href="#然后更新-password" class="headerlink" title="然后更新 password"></a>然后更新 password</h5><p>①.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string = password ( &#x27;新密码&#x27; ) where user = &#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>②.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user  set Password=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><h4 id="8-在-my-ini-文件中去掉-加上的-skip-grant-tables，重启-mysql-服务，以新密码登陆就大功告成了！"><a href="#8-在-my-ini-文件中去掉-加上的-skip-grant-tables，重启-mysql-服务，以新密码登陆就大功告成了！" class="headerlink" title="8.在 my.ini 文件中去掉 加上的 skip-grant-tables，重启 mysql 服务，以新密码登陆就大功告成了！"></a>8.在 my.ini 文件中去掉 加上的 skip-grant-tables，重启 mysql 服务，以新密码登陆就大功告成了！</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 重装系统后的坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
