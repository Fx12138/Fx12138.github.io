<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS实现几种排序</title>
      <link href="/2022/04/24/JS%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/04/24/JS%E5%AE%9E%E7%8E%B0%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序运用了分而治之的思想,分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p><p>​        （1）在数据集之中，选择一个元素作为”基准”（pivot,一般选择中间的值）。</p><p>　　（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</p><p>　　（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line">        <span class="keyword">let</span> nums = [-<span class="number">14</span>, -<span class="number">10</span>, -<span class="number">8</span>, -<span class="number">6</span>, -<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> nums &#125;</span><br><span class="line">            <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)<span class="comment">//基准的位置</span></span><br><span class="line">            <span class="keyword">var</span> pivot = nums.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]<span class="comment">//基准的值</span></span><br><span class="line">            <span class="keyword">var</span> left = []</span><br><span class="line">            <span class="keyword">var</span> right = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class="line">                    left.push(nums[i])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right.push(nums[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(quickSort(nums));</span><br></pre></td></tr></table></figure><p>空间复杂度：O(1)<br>时间复杂度：最好O(nlog²n)，最坏O(nlog²n)，平均O(nlogn)<br>使用场景：数据量大于1000<br>稳定性：不稳定。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul><li>比较相邻元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡</span></span><br><span class="line"><span class="keyword">let</span> nums1 = [<span class="number">23</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">11</span>, <span class="number">65</span>, <span class="number">76</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = nums[j]</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>]</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(nums);<span class="comment">//一次循环后最大的数在最后一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(nums1));</span><br></pre></td></tr></table></figure><p>空间复杂度：因为只涉及到交换，只需要常量级的临时空间，所以空间复杂度为O(1)<br>时间复杂度：最好O(n)，最坏O(n²)，平均O(n²)<br>使用场景：数据量小于1000<br>稳定性：稳定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/"/>
      <url>/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的缓存"><a href="#浏览器的缓存" class="headerlink" title="浏览器的缓存"></a>浏览器的缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>检查强缓存，这个阶段<strong>不需要</strong>发送HTTP请求。</p><p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。在早期，也就是<code>HTTP/1.0</code>时期，使用的是<strong>Expires</strong>，而<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。过期了就得向服务端发请求。</p><p>缺点:<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在HTTP1.1中，采用了一个非常关键的字段：<code>Cache-Control</code>。采用过期时长来控制缓存，对应的字段是<strong>max-age</strong>。除了max-age还可以配合一下字段</p><p><strong>public</strong>: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<code>代理服务器</code>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</p><p><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</p><p><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</p><p><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。</p><p>值得注意的是，当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p><p>当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——<strong>协商缓存</strong>了。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。</p><h3 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h3><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p><p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p><p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p><ul><li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li><li>否则返回304，告诉浏览器直接用缓存。</li></ul><h3 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<code>响应头</code>把这个值给浏览器。</p><p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<strong>If-None-Match</strong>这个字段的内容，并放到请求头中，然后发给服务器。</p><p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对: - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。 - 否则返回304，告诉浏览器直接用缓存。</p><p>如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker 主要用在离线缓存</li><li>Memory Cache 内存缓存</li><li>Disk Cache 磁盘缓存</li><li>Push Cache 推送缓存</li></ul><p>主要策略如下： 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存.内存使用率比较高的时候，文件优先进入磁盘</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用 - 如果强缓存可用，直接使用 - 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段检查资源是否更新 - 若资源更新，返回资源和200状态码 - 否则，返回304，告诉浏览器直接从缓存获取资源</p><h1 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h1><ul><li><strong>浏览器进程</strong>：主要负责tab页的管理。</li><li><strong>浏览器渲染进程</strong>：负责页面的渲染，每个tab页都会有浏览器渲染进程</li><li><strong>GPU进程</strong>：主要用于3D绘制，例如使用canvas进行3D绘图</li><li><strong>插件进程</strong>：插件运行在插件进程，每个不同的插件都会运行在一个新的进程</li></ul><h1 id="输入url到页面呈现"><a href="#输入url到页面呈现" class="headerlink" title="输入url到页面呈现"></a>输入url到页面呈现</h1><h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><ol><li>构建请求</li><li>查找强缓存 如果命中则直接使用</li><li>DNS解析 得到域名对应的ip地址,浏览器提供了<strong>DNS数据缓存功能</strong>。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 <code>DNS解析</code>。</li><li>建立TCP连接 </li><li>发送http请求</li><li>响应http 响应完成之后要判断<code>Connection</code>字段, 如果请求头或响应头中包含<strong>Connection: Keep-Alive</strong>，表示建立了持久连接，这样<code>TCP</code>连接会一直保持，之后请求统一站点的资源会复用这个连接。</li></ol><h2 id="解析渲染篇"><a href="#解析渲染篇" class="headerlink" title="解析渲染篇"></a>解析渲染篇</h2><ol><li>解析HTML，生成DOM树</li><li>解析css，生成渲染树(包含width,颜色等) CSSOM tree</li><li>将HTML DOM树与CSS规则树结合,生成生成Render tree</li><li>布局Render树（layout/reflow），负责各元素大小、位置的计算</li><li>绘制Render树（painting），绘制页面像素信息</li><li>浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上</li></ol><h1 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h1><h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><p>重排也叫回流</p><p>简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生<code>回流</code>的过程。</p><p>有以下的操作会触发回流:</p><ol><li>一个 DOM 元素的几何属性变化，常见的几何属性有<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>left</code>、<code>top</code>、<code>border</code> 等等, 这个很好理解。</li><li>使 DOM 节点发生<code>增减</code>或者<code>移动</code>。</li><li>读写 <code>offset</code>族、<code>scroll</code>族和<code>client</code>族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li><li>调用 <code>window.getComputedStyle</code> 方法。</li></ol><p>过程:如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致<code>重绘</code>(<code>repaint</code>)。</p><p>由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程只会出发计算css样式并绘制</p><p>重绘不一定导致回流，但回流一定发生了重绘。</p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>还有一种情况，是直接合成。比如利用 CSS3 的<code>transform</code>、<code>opacity</code>、<code>filter</code>这些属性就可以实现合成的效果，也就是大家常说的<strong>GPU加速</strong>。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li>避免频繁使用 style，而是采用修改<code>class</code>的方式。</li><li>使用<code>createDocumentFragment</code>进行批量的 DOM 操作。</li><li>对于 resize、scroll 等进行防抖/节流处理。</li><li>添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于<code>tranform</code>, 任何可以实现合成效果的 CSS 属性都能用<code>will-change</code>来声明。这行代码能够开启 GPU 加速页面渲染，从而大大降低了 CPU 的负载压力，达到优化页面渲染性能的目的</li></ol><h1 id="js和css阻塞"><a href="#js和css阻塞" class="headerlink" title="js和css阻塞"></a>js和css阻塞</h1><p>load事件：load 应该仅用于检测一个完全加载的页面 当一个资源及其依赖资源已完成加载时，将触发load事件。也就是说，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。</p><p>DOMContentLoaded事件：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。也就是说，DOM 树已经构建完毕就会触发 DOMContentLoaded 事件。</p><h2 id="js阻塞了什么"><a href="#js阻塞了什么" class="headerlink" title="js阻塞了什么"></a>js阻塞了什么</h2><ul><li>js是否会阻塞dom树构建</li></ul><p>因为js在执行的过程中可能会操作DOM，发生回流和重绘，所以GUI渲染线程与JS引擎线程是互斥的。</p><p>在解析HTML过程中，如果遇到 script 标签，渲染线程会暂停渲染过程，将控制权交给 JS 引擎。内联的js代码会直接执行，如果是js外部文件，则要下载该js文件，下载完成之后再执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染线程，继续 DOM 的解析。</p><p>因此，<strong>js会阻塞DOM树的构建</strong>。</p><ul><li>是否会阻塞页面的显示呢？</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码,页面中会先显示hello world,然后遇到script标签则导致阻塞渲染,运行js代码,js代码完成后会再显示hello world2</p><p>js不会阻塞位于它之前的dom元素的渲染。现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有DOM解析完成后才布局渲染树。而是当js阻塞发生时，会将已经构建好的DOM元素渲染到屏幕上，减少白屏的时间。</p><p>这也是为什么我们会将script标签放到body标签的底部，因为这样就不会影响前面的页面的渲染。</p><h2 id="css阻塞了什么"><a href="#css阻塞了什么" class="headerlink" title="css阻塞了什么"></a>css阻塞了什么</h2><p>当我们解析 HTML 时遇到 link 标签或者 style 标签时，就会计算样式，构建CSSOM。</p><p><strong>css不会阻塞dom树的构建，但是会阻塞页面的显示</strong>。</p><ul><li>会不会阻塞DOM树的构建</li></ul><p><strong>css不会阻塞dom树的构建.但是浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容</strong>。即便 DOM 已经解析完毕了，只要 CSSOM 不没构建好，页面也不会显示内容。</p><p>只有当我们遇到 link 标签或者 style 标签时，才会构建CSSOM，所以如果 link 标签之前有dom元素，会加载css发生阻塞,如下面的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样做会导致一个问题，就是页面闪烁，在css被加载之前，浏览器按照默认样式渲染 <div class="woo-spinner-filled">hello world</div>，当css加载完成，会为该div计算新的样式，重新渲染，出现闪烁的效果。</p><p>为了避免页面闪烁，通常 link 标签都放在head中。</p><p>下面的代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码,DOMContentLoaded事件会在30ms左右就完成,也就是说DOM树会在30ms就构建完成,但是在30ms时页面此时依然是空白;而loaded事件会在2.92s发生,并且页面才出现内容.也就是说这时候资源全部加载完毕.由此可见,在head中的link标签加载css较费时,但是不会阻塞DOM树的构建,会阻塞页面的渲染.</p><ul><li>css会不会阻塞后面js执行</li></ul><p>答案是会.</p><p>JS 的作用在于修改，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。当在JS中访问了CSSDOM中某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行JS脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://h5.sinaimg.cn/m/weibo-pro/css/chunk-vendors.d6cac585.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;woo-spinner-filled&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a test&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子，就会发现等css加载完成后，才会在控制台打印“this is a test”。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>(1)js</p><ul><li>js既会阻塞dom树的构建,也会阻塞页面的渲染</li></ul><p>(2)css</p><ul><li><p>css不会阻塞dom树的构建(DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析)</p></li><li><p><strong>style不会</strong>阻塞页面的渲染(dom会先展示但是没有任何样式,当加载完css后才显示样式,因此会造成<strong>闪屏现象</strong>)</p></li><li><p><strong>link会</strong>阻塞页面的渲染(dom树解析完也不会进行任何渲染,当加载完link后才显示合并cssom一起显示,因此会造成<strong>白屏现象</strong>)</p></li><li><p>css会阻塞后面js的执行</p></li></ul><p>(3)link和@import的区别</p><ul><li>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；</li><li><strong>加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载</strong>；因此可能造成闪屏现象</li><li>link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；</li><li>可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="对称和非对称加密结合"><a href="#对称和非对称加密结合" class="headerlink" title="对称和非对称加密结合"></a>对称和非对称加密结合</h2><p>演示一下整个流程： 1. 浏览器向服务器发送<code>client_random</code>和加密方法列表。 2. 服务器接收到，返回<code>server_random</code>、加密方法以及公钥。 3. 浏览器接收，接着生成另一个随机数<code>pre_random</code>, 并且用公钥加密，传给服务器。(敲黑板！重点操作！) 4. 服务器用私钥解密这个被加密后的<code>pre_random</code>。</p><p>现在浏览器和服务器有三样相同的凭证:<code>client_random</code>、<code>server_random</code>和<code>pre_random</code>。然后两者用相同的加密方法混合这三个随机数，生成最终的<code>密钥</code>。</p><p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用<code>对称加密</code>。</p><p>缺点:尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p><h2 id="添加数字证书"><a href="#添加数字证书" class="headerlink" title="添加数字证书"></a>添加数字证书</h2><p>添加了<code>数字证书认证</code>的步骤。其目的就是让服务器证明自己的身份。为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫<code>CA</code>(<code>Certificate Authority</code>), 认证通过后 CA 会给服务器颁发<strong>数字证书</strong>。</p><p>这个数字证书有两个作用: 1. 服务器向浏览器证明自己的身份。 2. 把公钥传给浏览器。</p><p>这个验证的过程发生在什么时候呢？</p><p>当服务器传送<code>server_random</code>、加密方法的时候，顺便会带上<code>数字证书</code>(包含了<code>公钥</code>), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p><h2 id="HTTPS加解密过程"><a href="#HTTPS加解密过程" class="headerlink" title="HTTPS加解密过程"></a>HTTPS加解密过程</h2><img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220525213117645.png" alt="image-20220525213117645" style="zoom:80%;"><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>在JavaScript中，数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中。</p><ul><li>基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的</li><li>引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。</li></ul><p>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是<code>操作系统自动分配和释放回收的</code></p><p>由于堆内存所存大小不固定，系统<code>无法自动释放回收</code>，所以需要<code>JS引擎来手动释放这些内存</code></p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。上例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; <span class="comment">// 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 </span></span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; <span class="comment">// A 的引用个数变为 2</span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 1</span></span><br><span class="line">obj2 = <span class="number">0</span>; <span class="comment">// A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>但是引用计数有个最大的问题： 循环引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p><p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。</p><p>标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。</p><h2 id="V8的垃圾回收算法"><a href="#V8的垃圾回收算法" class="headerlink" title="V8的垃圾回收算法"></a>V8的垃圾回收算法</h2><p>那么问题来了，对于存活周期短的，回收掉就算了，但对于存活周期长的，多次回收都回收不掉，明知回收不掉，却还不断地去做回收无用功，那岂不是很消耗性能？</p><p>对于这个问题，V8做了<strong>分代回收</strong>的优化方法，通俗点说就是：<strong>V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方</strong></p><p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用<code>Scavenge</code>算法进行垃圾回收，<code>Scavenge</code>算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。</p><p><code>Scavange算法</code>将新生代堆分为两部分，分别叫<code>from-space</code>和<code>to-space</code>，工作方式也很简单，就是将<code>from-space</code>中存活的活动对象复制到<code>to-space</code>中，并将这些对象的内存有序的排列起来，然后将<code>from-space</code>中的非活动对象的内存进行释放，完成之后，将<code>from space</code> 和<code>to space</code>进行互换，这样可以使得新生代中的这两块区域可以重复利用。</p><img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133234703.png" alt="image-20220530133234703" style="zoom: 33%;"><p>新生代中的对象什么时候变成老生代的对象？</p><p>在新生代中，还进一步进行了细分。分为<code>nursery子代</code>和<code>intermediate子代</code>两个区域，一个对象第一次分配内存时会被分配到新生代中的<code>nursery子代</code>，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到<code>intermediate子代</code>，在经过下一次垃圾回收，如果这个对象还在新生代中，<code>副垃圾回收器</code>会将该对象移动到老生代中，这个移动的过程被称为<code>晋升</code></p><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>老生代里，回收算法不宜使用<code>Scavenge算法</code>，为啥呢，有以下原因：</p><ul><li><code>Scavenge算法</code>是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低</li><li><code>Scavenge算法</code>是以空间换时间的算法，老生代是内存很大的空间，如果使用<code>Scavenge算法</code>，空间资源非常浪费，得不偿失啊。。</li></ul><p>所以老生代里使用了<code>Mark-Sweep算法(标记清理)</code>和<code>Mark-Compact算法(标记整理)</code></p><h4 id="Mark-Sweep-标记清理"><a href="#Mark-Sweep-标记清理" class="headerlink" title="Mark-Sweep(标记清理)"></a>Mark-Sweep(标记清理)</h4><p><code>Mark-Sweep</code>分为两个阶段，标记和清理阶段，之前的<code>Scavenge算法</code>也有标记和清理，但是<code>Mark-Sweep算法</code>跟<code>Scavenge算法</code>的区别是，后者需要复制后再清理，前者不需要，<code>Mark-Sweep</code>直接标记活动对象和非活动对象之后，就直接执行清理了。</p><ul><li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li><li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象</li></ul><img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133626739.png" alt="image-20220530133626739" style="zoom: 33%;"><p>由上图，我想大家也发现了，有一个问题：清除非活动对象之后，留下了很多<code>零零散散的空位</code>。</p><h4 id="Mark-Compact-标记整理"><a href="#Mark-Compact-标记整理" class="headerlink" title="Mark-Compact(标记整理)"></a>Mark-Compact(标记整理)</h4><p>这个时候<code>Mark-Compact算法</code>出现了，他是<code>Mark-Sweep算法</code>的加强版，在<code>Mark-Sweep算法</code>的基础上，加上了<code>整理阶段</code>，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存</p><img src="/2022/04/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%A7%E8%83%BD/devApp\myblog\source\_posts\浏览器性能\image-20220530133811523.png" alt="image-20220530133811523" style="zoom:33%;"><h3 id="全停顿-Stop-The-World"><a href="#全停顿-Stop-The-World" class="headerlink" title="全停顿(Stop-The-World)"></a>全停顿(Stop-The-World)</h3><p>说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，<code>垃圾回收优先于代码执行</code>，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为<code>全停顿</code></p><p>由于新生代空间小，并且存活对象少，再配合<code>Scavenge算法</code>，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了<code>卡顿现象</code>。</p><h3 id="Orinoco优化"><a href="#Orinoco优化" class="headerlink" title="Orinoco优化"></a>Orinoco优化</h3><p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决<code>全停顿问题</code>，它提出了<code>增量标记、懒性清理、并发、并行</code>的优化方法。</p><h4 id="增量标记-Incremental-marking"><a href="#增量标记-Incremental-marking" class="headerlink" title="增量标记(Incremental marking)"></a>增量标记(Incremental marking)</h4><p>咱们前面不断强调了<code>先标记，后清除</code>，而增量标记就是在<code>标记</code>这个阶段进行了优化。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：<code>标记一点，JS代码运行一段</code>，从而提高效率</p><h4 id="惰性清理-Lazy-sweeping"><a href="#惰性清理-Lazy-sweeping" class="headerlink" title="惰性清理(Lazy sweeping)"></a>惰性清理(Lazy sweeping)</h4><p>增量标记只是针对<code>标记</code>阶段，而惰性清理就是针对<code>清除</code>阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就<code>延迟了清理</code>，让JS代码先执行，或者<code>只清理部分垃圾</code>，而不清理全部。这个优化就叫做<code>惰性清理</code></p><p>整理标记和惰性清理的出现，大大改善了<code>全停顿</code>现象。但是问题也来了：增量标记是<code>标记一点，JS运行一段</code>，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成<code>对象引用改变，标记错误</code>现象。这就需要使用<code>写屏障</code>技术来记录这些引用关系的变化</p><h4 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h4><p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行<code>写屏障</code>操作。</p><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p><h2 id="V8当前的垃圾回收机制"><a href="#V8当前的垃圾回收机制" class="headerlink" title="V8当前的垃圾回收机制"></a>V8当前的垃圾回收机制</h2><p>2011年，V8应用了<code>增量标记机制</code>。直至2018年，Chrome64和Node.js V10启动<code>并发标记（Concurrent）</code>，同时在并发的基础上添加<code>并行（Parallel）技术</code>，使得垃圾回收时间大幅度缩短。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/31/vue%E9%83%A8%E7%BD%B2%E5%88%B0nginx/"/>
      <url>/2022/03/31/vue%E9%83%A8%E7%BD%B2%E5%88%B0nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><h2 id="安装nginx所需环境"><a href="#安装nginx所需环境" class="headerlink" title="安装nginx所需环境"></a>安装nginx所需环境</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc<span class="literal">-c</span>++  </span><br><span class="line">yum install <span class="literal">-y</span> pcre pcre<span class="literal">-devel</span>  </span><br><span class="line">yum install <span class="literal">-y</span> zlib zlib<span class="literal">-devel</span>  </span><br><span class="line">yum install <span class="literal">-y</span> openssl openssl-<span class="literal">-devel</span> </span><br></pre></td></tr></table></figure><h2 id="下载tar-gz安装包和解压"><a href="#下载tar-gz安装包和解压" class="headerlink" title="下载tar.gz安装包和解压"></a><strong>下载tar.gz安装包和解压</strong></h2><p>官网：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html </a>  这里本人下载的是 nginx-1.14.2.tar.gz</p><p>上传的目录是在/usr/local下, cd 到/usr/local 目录，解压命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nginx-1.14.2.tar.gz</span><br></pre></td></tr></table></figure><p>我们进入到cd nginx-1.14.2到下去配置。</p><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>依次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="查看安装目录"><a href="#查看安装目录" class="headerlink" title="查看安装目录"></a>查看安装目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><p>可以看到我安装目录是在/usr/local/nginx/ </p><h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line"></span><br><span class="line">//接着执行</span><br><span class="line">./nginx </span><br></pre></td></tr></table></figure><p>输入我们的服务器ip地址：如图成功了</p><img src="/2022/03/31/vue%E9%83%A8%E7%BD%B2%E5%88%B0nginx/Users\F\AppData\Roaming\Typora\typora-user-images\image-20220331155849675.png" alt="image-20220331155849675" style="zoom:67%;"><h1 id="部署vue项目"><a href="#部署vue项目" class="headerlink" title="部署vue项目"></a>部署vue项目</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过该命令将vue项目打包 生成dist</span><br><span class="line">npm run bulid</span><br></pre></td></tr></table></figure><h2 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h2><p>打开nginx下conf文件夹下的nginx.conf文件，在这里进行nginx的核心配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8089; //nginx的访问端口，改完后即通过此端口访问项目</span><br><span class="line">        server_name  localhost;//这个保持不变即可</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.html;//划重点，这一步能使用户访问Vue时刷新界面不至于404，即是正常的实现了vue的history路由功能</span><br><span class="line">            root   /usr/local/nginx/html/dist;//将默认访问根节点定位到项目目录，即是我们之前拷贝过来的Vue项目。</span><br><span class="line"></span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        autoindex_exact_size off;   //文件大小从KB开始显示</span><br><span class="line">            charset utf-8;          //显示中文</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; //允许来自所有的访问地址</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, PUT, POST, DELETE, OPTIONS&#x27;; //支持请求方式</span><br><span class="line">            add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Content-Type,*&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    location /api&#123;//配置代理，和开发时的devServer中配置保持一致即可，如有多个即配置多个location</span><br><span class="line">           rewrite ^/api/(.*)$ /$1 break;</span><br><span class="line">           include uwsgi_params;</span><br><span class="line">           proxy_set_header   Host             $host;</span><br><span class="line">           proxy_set_header   x-forwarded-for  $remote_addr;</span><br><span class="line">           proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">           proxy_pass  http://127.0.0.1:8080; // 接口地址，如果在同一个服务器上，可以直接这样写,后面端口号写接口的端口号</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把dist文件夹放入"><a href="#把dist文件夹放入" class="headerlink" title="把dist文件夹放入"></a>把dist文件夹放入</h2><img src="/2022/03/31/vue%E9%83%A8%E7%BD%B2%E5%88%B0nginx/Users\F\AppData\Roaming\Typora\typora-user-images\image-20220331160200848.png" alt="image-20220331160200848" style="zoom: 80%;"><p>放入到上面配置的红色箭头位置</p><h2 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h2><p>然后 ./nginx -s reload  重新加载配置一下nginx.conf 文件</p><p>然后访问 ip地址:上面配置的端口号  就可以了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jsDOM编程艺术</title>
      <link href="/2022/01/04/jsDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
      <url>/2022/01/04/jsDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h1><ul><li>getElementById</li><li>getElementsByTagName</li><li>getElementsByClassName</li></ul><h2 id="获取其他元素"><a href="#获取其他元素" class="headerlink" title="获取其他元素"></a>获取其他元素</h2><ul><li>element.childNodes属性 所有的子元素,是一个数组</li><li>parentNode属性 获取父元素</li><li>lastChild属性 获取当前元素的最后一个子元素</li><li>nextSibling属性 获取当前元素的后一个兄弟元素</li></ul><h1 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h1><p>object.getAttribute()</p><p>object.setAttribute()</p><h1 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h1><p>onclick</p><p>window.onload,在页面加载时执行</p><p>​    <code>window.onload = 函数名;</code></p><p>​    文档将被加载到一个浏览器窗口里，document对象又是 window对象的一个属性。当window对象触发onload事件时，document对象已经存在。</p><h1 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h1><h2 id="nodeValue属性"><a href="#nodeValue属性" class="headerlink" title="nodeValue属性"></a>nodeValue属性</h2><p>用来获取和修改文本节点的文本,但是获取文本时包含在&lt;P元素里的文本是另一种节点，它是平元素的第一个子节点。因此，你想要得到的其实是它的第一个子节点的nodeValue属性值。</p><p>node.childNodes[0].nodeValue</p><h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><h2 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h2><p>appendChild</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">node.appendChild(newDiv)</span><br></pre></td></tr></table></figure><h2 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h2><p>document.createTextNode</p><p>上面创建了元素节点p标签,但是并不包含文本,需要创建文本节点并插入到p标签中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newP = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">node.appendChild(newDiv)</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;这是文本&#x27;</span>)</span><br><span class="line">newP.appendChild(text)</span><br></pre></td></tr></table></figure><h1 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h1><h2 id="在已有元素前插入"><a href="#在已有元素前插入" class="headerlink" title="在已有元素前插入"></a>在已有元素前插入</h2><p>父节点.insertBefore(新元素,目标元素)</p><h1 id="元素style"><a href="#元素style" class="headerlink" title="元素style"></a>元素style</h1><p>node.style可以获取元素的css样式,但是<strong>只能获取到内嵌样式</strong></p><p>通过node.style.color可以获取字体颜色,但是font-family不能通过这种方式直接获取,因为中间的连字符 - 和js中的减号相同,</p><p>node.style.font-family会报错.应该使用下面的方法,使用驼峰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.style.fontFamily</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2021/11/19/webpack/"/>
      <url>/2021/11/19/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="提取css成单独文件"><a href="#提取css成单独文件" class="headerlink" title="提取css成单独文件"></a>提取css成单独文件</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="comment">//提取css单独打包</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;css/build.css&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="comment">// &#x27;style-loader&#x27;, </span></span><br><span class="line">                    <span class="comment">//取代style-loader 作用:提取js中css成单独的文件</span></span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="comment">//将css文件整合到js文件中</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//css兼容性处理:postcss-loader postcss-preset-env</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h1 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CssMinimizerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> CssMinimizerWebpackPlugin()</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h1 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h1><p>将js文件中es6打包转为所有浏览器都能识别的es5</p><p>安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-d</span> babel<span class="literal">-loader</span> @babel/core @babel/p<span class="built_in">reset-env</span></span><br></pre></td></tr></table></figure><ul><li>babel-loader 在webpack里应用babel解析es6的桥梁</li><li>@babel/core babel核心模块</li><li>@babel/preset-env babel预设,一组babel插件的集合</li></ul><p>初次之外 还需要regeneratorRuntime插件,这是webpack打包生成的全局辅助函数,由babel生成,用于兼容async/await语法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个包中包含了regeneratorRuntime,运行时寻妖</span></span><br><span class="line">npm install @babel/runtime <span class="literal">-d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个插件会在需要regeneratorRuntime的地方自动require导包,编译时需要</span></span><br><span class="line">npm install @babel/plugin<span class="literal">-transform</span><span class="literal">-runtime</span> <span class="literal">-d</span></span><br></pre></td></tr></table></figure><p>最终在webpack.config.js中配置为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">           <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">           exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">           use: &#123;</span><br><span class="line">               <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">               <span class="attr">options</span>: &#123;</span><br><span class="line">                   <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">                   <span class="attr">plugins</span>: [</span><br><span class="line">                       [</span><br><span class="line">                           <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span></span><br><span class="line">                       ]</span><br><span class="line">                   ]</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h1><p>用来获得更小的bundle,使bundle按需加载或者并行加载,常用的有三种方法</p><h2 id="入口起点"><a href="#入口起点" class="headerlink" title="入口起点"></a>入口起点</h2><p>使用entry配置手动的分离代码</p><p>缺点:如果是多个入口,那么每个入口中共享的文件会分别在每个包里重复去打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">another</span>: <span class="string">&#x27;./src/another.js&#x27;</span><span class="comment">//这是另一个单独的js文件单独打包</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.js&#x27;</span>,  <span class="comment">//打包后文件名称</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),    <span class="comment">//打包后文件存储地址</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">//是否自动删除之前旧的打包文件</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">assetModuleFilename</span>: <span class="string">&#x27;image/[contenthash][ext]&#x27;</span>,    <span class="comment">//定义资源模块的导出位置</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>这样会生成两个打包文件, index.bundle.js 和 another.bundle.js</p><h2 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h2><p>使用Entry dependencies 或者 SplitChunksPlugin 去重和分离代码</p><h3 id="Entry-dependencies"><a href="#Entry-dependencies" class="headerlink" title="Entry dependencies"></a>Entry dependencies</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>:&#123;</span><br><span class="line">            <span class="attr">import</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">            <span class="attr">dependOn</span>:<span class="string">&#x27;shared&#x27;</span><span class="comment">//共享下面定义的重复模块,并生成一个shared.bundle.js</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">another</span>:&#123;</span><br><span class="line">            <span class="attr">import</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">            <span class="attr">dependOn</span>:<span class="string">&#x27;shared&#x27;</span><span class="comment">//共享下面定义的重复模块,并生成一个shared.bundle.js</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">shared</span>:<span class="string">&#x27;less&#x27;</span><span class="comment">//这样上面两个打包时如果都用到了less模块就会共享</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>比如两个js文件均引入了less模块:import less from ‘less’,如果普通的打包方式两个打包后的文件分别大小,分别为1.32M 和 1.2M.如下</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211119155403269.png" alt="image-20211119155403269"></p><p>如果改为这种防止重复的方法则共有三个打包文件,如下</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211119155530856.png" alt="image-20211119155530856"></p><p>其中shared.bundle.js是打包共享模块的打包文件,另外两个明显缩小</p><h3 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">another</span>: <span class="string">&#x27;./src/another.js&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样会自动抽离公共模块生成额外两个打包文件</p><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2><p>通过模块的内联函数调用来分离代码.使用了async提供的import的函数</p><p>新建一个async-module.js文件,如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样写的目的是为了让import帮助我们去抽离出一个单独的lodash文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//import 返回的是一个promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">&#x27;lodash&#x27;</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">        element.innerHTML = _join([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;webpack&quot;</span>], <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.appendChild(element)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>webpack.config.js如下,仅仅使用最简单的方式打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>在index.js中引入async-module.js</p><p>这样打包后会单独分离出一个lodash的打包文件</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211122094729606.png" alt="image-20211122094729606"></p><p>动态导入和前面的静态方法可以一起使用</p><h2 id="动态导入的应用"><a href="#动态导入的应用" class="headerlink" title="动态导入的应用"></a>动态导入的应用</h2><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>又称为按需加载.懒加载是动态导入代码分离方法的一种应用</p><p>因为有一些模块应用的很少,或者根本不会被引用.所以这些时候可以在需要的是在才对这些模块进行加载,从而得到优化</p><p>新建一个math.js文件如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.js中新增一个按钮,用来加载math.js并调用其中的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">button.textContent = <span class="string">&quot;点击执行10+10&quot;</span></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./math&#x27;</span>).then(<span class="function">(<span class="params">&#123; add &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样可以自定义生成的打包文件的名称,这样math文件打包出来的名字为math.bundle.js</span></span><br><span class="line"><span class="comment">//button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//    import(/*webpackChunkName:&#x27;math&#x27;*/&#x27;./math&#x27;).then((&#123; add &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//        console.log(add(10, 10));</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line"><span class="comment">//&#125;)</span></span><br></pre></td></tr></table></figure><p>这样打包后会生成一个新的单独的math的打包文件,其中包含了math.js中定义的两个方法,从而在需要这个包的的时候才会去加载</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211122104318242.png" alt="image-20211122104318242"></p><p>这时在浏览器中初启动时并不会请求加载math打包的相关文件</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211122104521719.png" alt="image-20211122104521719"></p><p>当点击按钮后</p><p><img src="/2021/11/19/webpack/devApp\myblog\source_posts\webpack\image-20211122104640941.png" alt="image-20211122104640941"></p><p>这时才会去请求加载math的打包文件</p><h3 id="预获取和预加载"><a href="#预获取和预加载" class="headerlink" title="预获取和预加载"></a>预获取和预加载</h3><p>预获取</p><p>在下一个页面即将用到的资源可以在父页面中进行预加载,他会在父页面所有其他资源加载完毕后,在浏览器网络空闲时进行下载.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样可以自定义生成的打包文件的名称,这样math文件打包出来的名字为math.bundle.js</span></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="comment">/*webpackChunkName:&#x27;math&#x27;,webpackPrefetch:true*/</span><span class="string">&#x27;./math&#x27;</span>).then(<span class="function">(<span class="params">&#123; add &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>预加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这样可以自定义生成的打包文件的名称,这样math文件打包出来的名字为math.bundle.js</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">    import(/*webpackChunkName:&#x27;math&#x27;,webpackPreload:true*/&#x27;./math&#x27;).then((&#123; add &#125;) =&gt; &#123;</span><br><span class="line">        console.log(add(10, 10));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在资源上添加预先加载的注释，你指明该模块需要立即被使用。<strong>异步chunk</strong>会和<strong>父级chunk</strong>并行加载。如果<strong>父级chunk</strong>先下载好，页面就已可显示了，同时等待<strong>异步chunk</strong>的下载。这能大幅提升性能。</p><h1 id="拆分配置文件及合并"><a href="#拆分配置文件及合并" class="headerlink" title="拆分配置文件及合并"></a>拆分配置文件及合并</h1><p>新建config文件夹</p><p>新建webpack.config.common.js这里面写开发环境和生产环境公共的配置</p><p>不同的是:</p><ul><li>output中的filename:在开发环境中由于不需要浏览器的缓存功能,所以不需要每次更新打包文件都更改打包名称,所以在开发环境中固定打包名称,在生产环境中加入hash使每次更新打包文件都声称新的不同的名称,触发浏览器更新缓存</li><li>output中的publicPath:在开发环境中只用于测试,无需设置公共路径.但是在生产环境中需要设置公共路径localhost:8080/</li><li>devtool:在开发环境中需要堆代码进行调试,查找报错位置,需要devtool直接定位到错误位置</li><li>devServer:在开发环境中要自动生成html文件并在修改代码时是页面自动更新,即npx webpack-dev-server</li><li>mode:模式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loader: 1下载 2使用(配置loader)</span></span><br><span class="line"><span class="comment"> * plugins: 1下载 2引入 3使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; node &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="attr">another</span>: <span class="string">&#x27;./src/another.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//中间的contenthash是因为浏览器会有缓存功能,而每次更新打包后名字不变的话会浏览器会认为没有更新</span></span><br><span class="line">        <span class="comment">//从而浏览及会继续使用缓存中的文件,不会进行更新</span></span><br><span class="line">        <span class="comment">//使用contenthash会让每次打包的文件根据内容生成hash从而改变文件名</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),    <span class="comment">//打包后文件存储地址</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">//是否自动删除之前旧的打包文件</span></span><br><span class="line">        <span class="attr">assetModuleFilename</span>: <span class="string">&#x27;image/[contenthash][ext]&#x27;</span>,    <span class="comment">//定义资源模块的导出位置</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插件的配置</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">//自动打包生成html文件,并</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,   <span class="comment">//以此文件为模板从而引入入口文件打包后所有资源</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;app.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>  <span class="comment">//设置script在哪个位置插入</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin()</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loader的配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">//处理图片资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,   <span class="comment">//匹配哪些文件(此处是处理后缀名为png的文件)</span></span><br><span class="line">                <span class="comment">//这个type共有三种可选</span></span><br><span class="line">                <span class="comment">//1.asset/resource是将图片地址转为打包的图片在打包后目录中的url</span></span><br><span class="line">                <span class="comment">//2.asset/inline是将图片地址转为base64处理的地址</span></span><br><span class="line">                <span class="comment">//3.asset/resource用于导出资源的源代码,一般用于text</span></span><br><span class="line">                type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">                <span class="attr">generator</span>: &#123;</span><br><span class="line">                    <span class="attr">filename</span>: <span class="string">&#x27;image/[contenthash].[ext]&#x27;</span>   <span class="comment">//定义打包后的图片路径,优先级高于上面output中assetModuleFilename</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//处理less样式资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,  <span class="comment">//打包样式资源</span></span><br><span class="line">                <span class="comment">//要使用多个loader做处理用use,使用单个loader就能处理的话用loader就行</span></span><br><span class="line">                use: [</span><br><span class="line">                    <span class="comment">//use数组中loader执行顺序:从右到左,从下到上 依次执行</span></span><br><span class="line">                    <span class="comment">//创建style标签,将js中的样式资源插入进去,添加到header中生效</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="comment">//将css文件变成commonjs模块加载js中,里面内容是样式字符串</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="comment">//将less文件编译成css文件</span></span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">//打包样式资源</span></span><br><span class="line">                use: [</span><br><span class="line">                    <span class="comment">//use数组中loader执行顺序:从右到左,从下到上 依次执行</span></span><br><span class="line">                    <span class="comment">//创建style标签,将js中的样式资源插入进去,添加到header中生效</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="comment">//将css文件打包变成commonjs模块加载js中,里面内容是样式字符串</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.png$/</span>,   <span class="comment">//匹配哪些文件(此处是处理后缀名为png的文件)</span></span><br><span class="line">                type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">                <span class="attr">generator</span>: &#123;</span><br><span class="line">                    <span class="attr">filename</span>: <span class="string">&#x27;image/[contenthash][ext]&#x27;</span>   <span class="comment">//定义打包后的图片路径,优先级高于上面output中assetModuleFilename</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">                        <span class="attr">plugins</span>: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span></span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="comment">// chunks: &#x27;all&#x27;</span></span><br><span class="line">            <span class="comment">//缓存组,上面输出中使每个文件打包后名称都进行更新</span></span><br><span class="line">            <span class="comment">//但是想某些单独抽离出去的模块并不会被修改,第三方库,比如lodash</span></span><br><span class="line">            <span class="comment">//这种情况下希望浏览器只加载一次,以后都用缓存的中这些模块</span></span><br><span class="line">            <span class="comment">//在这里配置缓存组</span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">vendors</span>: &#123;</span><br><span class="line">                    <span class="attr">test</span>: <span class="string">&#x27;/[\\/]node_modules[\\/]/&#x27;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建webpack.config.dev.js 这里配置开发环境中需要的特有配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;js/[name].js&#x27;</span>,  <span class="comment">//打包后文件名称</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;inline-source-map&#x27;</span>,   <span class="comment">//开发时报错直接定位到报错的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动化 自动编译 自动打开浏览器 自动刷洗浏览器</span></span><br><span class="line">    <span class="comment">//特点 只会在内存中打包,不回有任何输出</span></span><br><span class="line">    <span class="comment">//启动指令:npx webpack-dev-server</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="comment">//启动gzip压缩</span></span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//端口号</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">        <span class="attr">static</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建webpack.config.pro.js 这里配置生产环境中需要的特有配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//中间的contenthash是因为浏览器会有缓存功能,而每次更新打包后名字不变的话会浏览器会认为没有更新</span></span><br><span class="line">        <span class="comment">//从而浏览及会继续使用缓存中的文件,不会进行更新</span></span><br><span class="line">        <span class="comment">//使用contenthash会让每次打包的文件根据内容生成hash从而改变文件名</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash].js&#x27;</span>,  <span class="comment">//打包后文件名称</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;localhost:8080/&#x27;</span>,   <span class="comment">//公共路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载webpack-merge包用于合并配置</p><p>新建webpack.config.js文件,在其中对命令进行判断,从而决定怎么合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.common&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> productionConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.pro&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> developmentConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> env.development:</span><br><span class="line">            <span class="keyword">return</span> merge(commonConfig, developmentConfig)</span><br><span class="line">        <span class="keyword">case</span> env.production:</span><br><span class="line">            <span class="keyword">return</span> merge(commonConfig, productionConfig)</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;没有匹配到env环境&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在package.json中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;npx webpack server -c ./config/webpack.config.js --env development&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npx webpack -c ./config/webpack.config.js --env production&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h1><p>webpack内置source-map,由于浏览器加载的是打包好的bundle.js文件,所以在报错定位时查看到的也是bundle文件.上面也已经用到了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;inline-source-map&#x27;</span>,   <span class="comment">//开发时报错直接定位到报错的位置</span></span><br></pre></td></tr></table></figure><p>source-map有好多种可选值,当不设置的时候默认为eval</p><ul><li>eval    将每一个module封装到eval里包裹 起来执行,并且会在末尾加注释//@sourceURL</li><li>source-map 生成source-map 的打包文件</li></ul><h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动化 自动编译 自动打开浏览器 自动刷洗浏览器</span></span><br><span class="line">   <span class="comment">//特点 只会在内存中打包,不回有任何输出</span></span><br><span class="line">   <span class="comment">//启动指令:npx webpack-dev-server</span></span><br><span class="line">   <span class="attr">devServer</span>: &#123;</span><br><span class="line">       <span class="attr">static</span>: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">       <span class="comment">//启动gzip压缩(使打包文件从服务器传到浏览器是经过压缩的,提高速度)</span></span><br><span class="line">       <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="comment">//端口号</span></span><br><span class="line">       <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">       <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">       <span class="comment">//添加响应头</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">           <span class="string">&#x27;X-Access-Token&#x27;</span>: <span class="string">&#x27;abc123&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//配置代理</span></span><br><span class="line">       <span class="attr">proxy</span>: &#123;</span><br><span class="line">           <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:9000&#x27;</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//当我们的应用是个SPA(单页面应用),当路由到/some时,此时刷新页面可能会报错</span></span><br><span class="line">       <span class="attr">historyApiFallback</span>:<span class="literal">true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="优化开发环境"><a href="#优化开发环境" class="headerlink" title="优化开发环境"></a>优化开发环境</h1><h2 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h2><h3 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h3><p>每个文件都会被rules中的所有loader匹配处理,使用oneOf则在oneOf中的loader只会匹配一个,提高构建速度.但是注意不能有两个配置处理同一类型的文件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//loader的配置</span></span><br><span class="line">        <span class="attr">module</span>: &#123;</span><br><span class="line">            <span class="attr">rules</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">oneOf</span>: [</span><br><span class="line">                        <span class="comment">//处理图片资源</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,   <span class="comment">//匹配哪些文件(此处是处理后缀名为png的文件)</span></span><br><span class="line">                            <span class="comment">//这个type共有三种可选</span></span><br><span class="line">                            <span class="comment">//1.asset/resource是将图片地址转为打包的图片在打包后目录中的url</span></span><br><span class="line">                            <span class="comment">//2.asset/inline是将图片地址转为base64处理的地址</span></span><br><span class="line">                            <span class="comment">//3.asset/resource用于导出资源的源代码,一般用于text</span></span><br><span class="line">                            type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">                            <span class="attr">generator</span>: &#123;</span><br><span class="line">                                <span class="attr">filename</span>: <span class="string">&#x27;image/[contenthash].[ext]&#x27;</span>   <span class="comment">//定义打包后的图片路径,优先级高于上面output中assetModuleFilename</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">//处理less样式资源</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,  <span class="comment">//打包样式资源</span></span><br><span class="line">                            <span class="comment">//要使用多个loader做处理用use,使用单个loader就能处理的话用loader就行</span></span><br><span class="line">                            use: [</span><br><span class="line">                                <span class="comment">//use数组中loader执行顺序:从右到左,从下到上 依次执行</span></span><br><span class="line">                                <span class="comment">//创建style标签,将js中的样式资源插入进去,添加到header中生效</span></span><br><span class="line">                                <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                                <span class="comment">//将css文件变成commonjs模块加载js中,里面内容是样式字符串</span></span><br><span class="line">                                <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                                <span class="comment">//将less文件编译成css文件</span></span><br><span class="line">                                <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                            ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">//打包样式资源</span></span><br><span class="line">                            use: [</span><br><span class="line">                                <span class="comment">//use数组中loader执行顺序:从右到左,从下到上 依次执行</span></span><br><span class="line">                                <span class="comment">//创建style标签,将js中的样式资源插入进去,添加到header中生效</span></span><br><span class="line">                                <span class="comment">// &#x27;style-loader&#x27;,</span></span><br><span class="line">                                <span class="comment">//取代style-loader 作用:提取js中css成单独的文件</span></span><br><span class="line">                                MiniCssExtractPlugin.loader,</span><br><span class="line">                                <span class="comment">//将css文件打包变成commonjs模块加载js中,里面内容是样式字符串</span></span><br><span class="line">                                <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                            ],</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">test</span>: <span class="regexp">/\.png$/</span>,   <span class="comment">//匹配哪些文件(此处是处理后缀名为png的文件)</span></span><br><span class="line">                            type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">                            <span class="attr">generator</span>: &#123;</span><br><span class="line">                                <span class="attr">filename</span>: <span class="string">&#x27;image/[contenthash][ext]&#x27;</span>   <span class="comment">//定义打包后的图片路径,优先级高于上面output中assetModuleFilename</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                            use: &#123;</span><br><span class="line">                                <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                                <span class="attr">options</span>: &#123;</span><br><span class="line">                                    <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">                                    <span class="attr">plugins</span>: [</span><br><span class="line">                                        [</span><br><span class="line">                                            <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span></span><br><span class="line">                                        ]</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure><h1 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h1><p>去除无用代码,即使引用了包但是没有使用也会自动去除.但是不能百分百的tree shaking</p><p>前提:必须使用ES6模块化,开启production环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mode:<span class="string">&#x27;production&#x27;</span>,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">usedExports</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><p>有些引入的包虽然没使用但是有用,而有些不是,使用sideEffects可以告诉webpack哪些包是必要的不能tree shaking.</p><p>在package.json中设置sideEffects,共有三个可选值</p><ul><li>true 我的所有代码都是有用的,不能随意去除</li><li>false 我所有的包都是没有用的,那么一些引入的包,但是代码中并没有使用的话就会被去除(比如引入的css)</li><li>[] 可以使用一个数组定义哪些有用,不能删除(如 sideEffects:[“*.css”] )</li></ul><h1 id="模块热替换-HMR-与热加载"><a href="#模块热替换-HMR-与热加载" class="headerlink" title="模块热替换(HMR)与热加载"></a>模块热替换(HMR)与热加载</h1><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>模块热替换会在应用程序运行过程中,替换,添加或删除模块,而<strong>无需重新加载整个页面</strong>.开启方式只需在devServer下配置hot:true即可.</p><p>比如当更改css文件的某一个背景颜色时,不开启热替换的话需要刷新页面才能显示新的页面.但是如果开启了热替换的话则无需刷新页面直接自动更新.</p><p>不过js文件即使开启了热替换也不能进行自动替换,仍会刷新界面才能展示新的效果.这时需要手动进行判断并配置</p><p>比如input.js如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>).innerHTML = <span class="string">&#x27;&lt;input type=&quot;text&quot; value=&quot;input1&quot;/&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>在入口文件中引入input.js,进行如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./input.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果在input.js中改变value的值的话,就能进行自动热替换了.vue中已经自动帮助我们做好了</p><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><p>文件更新时自动刷新服务和页面.新版的webpack-dev-server默认已经开启了热加载的功能,他对应的参数是devServer.liveReload,默认为true.注意:如果想要关掉他,要将liveReload设置为false的同时,也要关闭hot.</p><h1 id="模块解析-resolve"><a href="#模块解析-resolve" class="headerlink" title="模块解析(resolve)"></a>模块解析(resolve)</h1><p>在resolve中设置alias可以设置别名.extensions可以在当前路径中存在文件名相同,扩展名不同的文件,按照extensions配置的顺序优先解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="comment">//设置路径别名</span></span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//如果在当前路径中存在文件名相同,扩展名不同的文件</span></span><br><span class="line">        <span class="comment">//按照下面配置的顺序优先解析</span></span><br><span class="line">        <span class="attr">extensions</span>:[<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h1><p><code>externals</code> 配置选项提供了「从输出的 bundle 中排除依赖」的方法。</p><h1 id="多页面"><a href="#多页面" class="headerlink" title="多页面"></a>多页面</h1><h2 id="entry配置"><a href="#entry配置" class="headerlink" title="entry配置"></a>entry配置</h2><p>将部分不相关的js文件打包成一个文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">       <span class="attr">main</span>: [<span class="string">&#x27;./src/js/app.js&#x27;</span>, <span class="string">&#x27;./src/js/app2.js&#x27;</span>],</span><br><span class="line">       <span class="attr">another</span>: <span class="string">&#x27;./src/js/another.js&#x27;</span></span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>这样’./src/js/app.js’, ‘./src/js/app2.js’会打包到一个main.js中,而./src/js/another.js会在另一个中.</p><h2 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h2><p>HtmlWebpackPlugin中可以配置当前页面可以载入哪些chunk.这样打包好的html中只引入了main.js打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>:<span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">            <span class="comment">//根据上面入口中的配置选择需要载入的文件</span></span><br><span class="line">            <span class="attr">chunks</span>:[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><h2 id="多页面环境搭建"><a href="#多页面环境搭建" class="headerlink" title="多页面环境搭建"></a>多页面环境搭建</h2><p>主要是配置两个htmlwebpackplugin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;chanel1/index.html&#x27;</span>,</span><br><span class="line">            <span class="comment">//根据上面入口中的配置选择需要载入的文件</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index2.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;chanel2/index2.html&#x27;</span>,</span><br><span class="line">            <span class="comment">//根据上面入口中的配置选择需要载入的文件</span></span><br><span class="line">            <span class="attr">chunks</span>: [<span class="string">&#x27;another&#x27;</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><h1 id="渐进式网络应用程序-PWA"><a href="#渐进式网络应用程序-PWA" class="headerlink" title="渐进式网络应用程序(PWA)"></a>渐进式网络应用程序(PWA)</h1><p>共两步</p><h2 id="添加Workbox"><a href="#添加Workbox" class="headerlink" title="添加Workbox"></a>添加Workbox</h2><p>npm install workbox-webpack-plugin -d    安装workbox</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">skipWaiting</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><h2 id="在浏览器中注册Service-Worker"><a href="#在浏览器中注册Service-Worker" class="headerlink" title="在浏览器中注册Service-Worker"></a>在浏览器中注册Service-Worker</h2><p>在入口文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        navigator.serviceWorker.register(<span class="string">&#x27;/service-worker.js&#x27;</span>)</span><br><span class="line">            .then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;注册成功&#x27;</span>, registration);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">registrationError</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;注册失败&#x27;</span>, registrationError);</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这两步之后,就能实现即使服务器挂掉,静态页面仍能显示.</p><h1 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js总结</title>
      <link href="/2021/10/12/js%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/12/js%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE 事件流被称为事件冒泡，这是因为事件被定义为<strong>从最具体的元素（文档树中最深的节点）开始触 发，然后向上传播至没有那么具体的元素文档）</strong>。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获的意思是<strong>最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件</strong>。事件捕获实际上是为了在事件到达最终目标前拦截事件。</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流分为 3 个阶段：<strong>事件捕获</strong>、<strong>到达目标</strong>和<strong>事件冒泡</strong>。事件捕获最先发生， 为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个 阶段响应事件。</p><img src="/2021/10/12/js%E6%80%BB%E7%BB%93/devApp\myblog\source\_posts\js总结\image-20211012111120152.png" alt="image-20211012111120152" style="zoom: 33%;"><p>在 DOM 事件流中，实际的目标（div元素）在捕获阶段不会接收到事件。这是因为捕获阶段在到达img之前就结束了。下一阶段，即会在img元素上触发事件的“到达目标” 阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后，冒泡阶段开始，事件反向传播至文档。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原 因有很多。<strong>首先，每个函数都是对象，都占用内存空间，对象越多，性能越差</strong>。其次，<strong>为指定事件处理 程序所需访问 DOM 的次数会先期造成整个页面交互的延迟</strong>。</p><p><strong>事件委托利用事件冒泡，可以只使用一个事件 处理程序来管理一种类型的事件</strong>。例如，click 事件冒泡到 document。这意味着可以为整个页面指定 一个 onclick 事件处理程序，而不用为每个可点击元素分别指定事件处理程序。</p><p>事件委托的优点:</p><ul><li><p>document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。 </p></li><li><p>节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间。 </p></li><li><p>减少整个页面所需的内存，提升整体性能。</p></li></ul><h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><ol><li>所有任务都在主线程上执行，形成一个执行栈。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。</li><li><strong>主线程不断重复上面的第三步</strong>。</li></ol><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p><strong>宏任务(macrotask)：</strong>：</p><p>script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate</p><p><strong>微任务(microtask)：</strong></p><p>Promise、 MutaionObserver、process.nextTick(Node.js环境）</p><p>实例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>上面的示例中，第一次事件循环，整段代码作为宏任务进入主线程执行。</li><li>遇到了 setTimeout ，就会<strong>等到过了指定的时间后将回调函数放入到宏任务的任务队列中</strong>。</li><li>遇到 Promise，<strong>将 then 函数放入到微任务的任务队列中</strong>。</li><li><strong>整个事件循环完成之后，会去检测微任务的任务队列中是否存在任务，存在就执行</strong>。</li><li>第一次的循环结果打印为: 1,3,5,4。</li><li>接着再到宏任务的任务队列中按顺序取出一个宏任务到栈中让主线程执行，那么在这次循环中的宏任务就是 setTimeout 注册的回调函数，执行完这个回调函数，发现在这次循环中并不存在微任务，就准备进行下一次事件循环。</li><li>检测到宏任务队列中已经没有了要执行的任务，那么就结束事件循环。</li><li>最终的结果就是 1,3,5,4,2。</li></ul><h1 id="判断数组的六种方法"><a href="#判断数组的六种方法" class="headerlink" title="判断数组的六种方法"></a>判断数组的六种方法</h1><ul><li><strong>① instanceof 操作符判断</strong></li></ul><p>用法：arr instanceof Array<br>instanceof 主要是用来判断某个实例是否属于某个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是 instanceof 会有一个问题，<strong>它的问题在于假定只有一个全局执行的环境</strong>。如果网页中包含多个框架，那实际上就存在<strong>两个以上不同的全局执行环境</strong>，<strong>从而存在两个以上不同版本的Array构造函数</strong>。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。</p><ul><li><strong>②对象构造函数的constructor判断</strong></li></ul><p>用法：arr.constructor === Array<br>Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>③<strong>Array 原型链上的 isPrototypeOf</strong></li></ul><p>用法：Array.prototype.isPrototypeOf(arr)<br>Array.prototype  属性表示 Array 构造函数的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>④Object.getPrototypeOf</li></ul><p>用法：Object.getPrototypeOf(arr) === Array.prototype<br>Object.getPrototypeOf() 方法返回指定对象的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(arr) === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>⑤<strong>Object.prototype.toString</strong></li></ul><p>用法：Object.prototype.toString.call(arr) === ‘[object Array]’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>⑥<strong>Array.isArray</strong></li></ul><p>用法：Array.isArray(arr)<br>ES5中新增了Array.isArray方法,IE8及以下不支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><h2 id="比较let和var"><a href="#比较let和var" class="headerlink" title="比较let和var"></a>比较let和var</h2><p>let是块级作用域,var是全局作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出三个4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br></pre></td></tr></table></figure><p>因为var定义的i是全局作用域的,所以访问的一直都是全局作用域中的i</p><img src="/2021/10/12/js%E6%80%BB%E7%BB%93/devApp\myblog\source\_posts\js总结\image-20211014151927066.png" alt="image-20211014151927066" style="zoom:50%;"><p>但是let定义的是块级作用域,所以他访问自己块中的i,而访问不到全局作用域</p><p><img src="/2021/10/12/js%E6%80%BB%E7%BB%93/devApp\myblog\source\_posts\js总结\image-20211014152239685.png" alt="image-20211014152239685" style="zoom:50%;"><img src="/2021/10/12/js%E6%80%BB%E7%BB%93/devApp\myblog\source_posts\js总结\image-20211014153405807.png" alt="image-20211014153405807"></p><h2 id="用var模拟出块级作用域"><a href="#用var模拟出块级作用域" class="headerlink" title="用var模拟出块级作用域"></a>用var模拟出块级作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1 2 3</span></span><br></pre></td></tr></table></figure><p><img src="/2021/10/12/js%E6%80%BB%E7%BB%93/devApp\myblog\source_posts\js总结\image-20211014153405807.png" alt="image-20211014153405807"></p><p>var虽然没有块级作用域,但是他有函数作用域,每次循环创建一个函数,生成一个函数作用域,这样就和上面的let一样了用自己块中的i</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.<strong>函数执行上下文只有在函数被调用的时候才会产生函数执行上下文,并压入栈顶</strong>.<strong>执行上下文对象的个数为n+1,其中n为函数被调用的次数,1为全局上下文</strong></p><p>执行环境定义了变量或环境有权访问的其他数据,每个执行环境都有一个与之关联的变量对象,环境中定义的所有变量和函数都保存在这个对象中.每个函数都有自己的执行环境,当<strong>执行流</strong>进入一个函数时函数的环境就会被推到一个环境栈中,而在函数执行完后,栈将其环境弹出,将控制权返还给之前的执行环境.</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域相对于上下文而言,上下文只有在函数被调用时才会产生,而<strong>作用域在编写代码时就已经确定了,即在函数定义时就已经产生.作用域共有n+1个,其中n为定义函数的个数,1为全局作用域</strong></p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行时,会创建变量对象的一个作用域链,用途是保证对执行环境有权访问的变量的<strong>有序访问</strong>.作用域链的最前端始终都是当前执行代码所在环境的变量对象.作用域链的下一个变量对象来自包含环境的变量对象,一直到全局执行环境.</p><h2 id="执行上下文和作用域的区别"><a href="#执行上下文和作用域的区别" class="headerlink" title="执行上下文和作用域的区别"></a>执行上下文和作用域的区别</h2><p>区别一</p><p>​    *全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时就已经确定了,而不是函数调用时</p><p>​    *全局执行上下文环境是在全局作用域之后,js代码马上执行之前创建</p><p>​    *函数执行上下文环境是在调用函数时,函数体代码执行之前创建</p><p>区别二</p><p>​    *作用域是静态的,只要函数定义好了就一直存在,且不会再变化</p><p>​    *上下文环境是动态的,调用函数时创建,函数调用结束时上下文环境就会被释放</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p><p>在嵌套函数中, 如果一个内层函数引用外层及更外层的函数当中定义的变量, 那么这个函数拥有包含这些变量数据的闭包. 当该内层函数被返回出去的时候, 其作用域链不会被摧毁.</p><p>一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = &#123;</span><br><span class="line"><span class="attr">user</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line"><span class="attr">get</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = hd.get();</span><br><span class="line"><span class="built_in">console</span>.log(a());</span><br><span class="line"><span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure><p>上面的代码输出undefined,原因是a得到了一个函数,并打印a(),这里函数是在全局作用域中调用的,所以函数中的this就是全局作用域,不会去hd对象中找,所以输出的是undefined.可以改成箭头函数,如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = &#123;</span><br><span class="line"><span class="attr">user</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line"><span class="attr">get</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.user</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = hd.get();</span><br><span class="line"><span class="built_in">console</span>.log(a());</span><br><span class="line"><span class="comment">//输出张三</span></span><br></pre></td></tr></table></figure><p>这样可以正常输出张三,因为箭头函数的this指向离箭头函数最近的环境.</p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><p>b.isPrototypeOf(a)方法检测的是<strong>b是否在a的原型链上</strong>,即b是否是a原型链上的一份子.</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>b instanceof a 检测的是<strong>b这个构造函数的prototype</strong>是否在a的原型链上</p><h2 id="in与hasOwnProperty"><a href="#in与hasOwnProperty" class="headerlink" title="in与hasOwnProperty()"></a>in与hasOwnProperty()</h2><p>“name” in person 检测的是”name”属性<strong>是否是person中的属性或者person的原型链中的属性</strong>.</p><p>person.hasOwnProperty(“name”) 只是检测当前对象中是否有这个属性,不会攀至原型链.</p><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign方法当定义的对象只有基本数据类型时就是深拷贝,当有引用类型时就是浅拷贝,下面举例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当定义的对象只有基本类型时，该方法就是深拷贝。</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line">b.name = <span class="string">&quot;哇哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// b = &#123;name: &#x27;哇哈哈&#x27;, age: 18&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当定义的对象中有引用类型的时，该方法就是浅拷贝。</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">eat</span>:&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line">b.name = <span class="string">&quot;哇哈哈&quot;</span>;</span><br><span class="line">b.eat.type = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line">b.eat.price = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18, eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;30&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// b = &#123;name: &#x27;哇哈哈&#x27;, age: 18, eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;30&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="ES6中扩展运算符"><a href="#ES6中扩展运算符" class="headerlink" title="ES6中扩展运算符"></a>ES6中扩展运算符</h3><p>该方法和上述方法一样只能用于深拷贝第一层的值，当拷贝第二层的值时 仍是引用同一个内存地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line">b.name = <span class="string">&quot;哇哈哈&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// b = &#123;name: &#x27;哇哈哈&#x27;, age: 18&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------  分割线  -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">eat</span>:&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line">b.name = <span class="string">&quot;哇哈哈&quot;</span>;</span><br><span class="line">b.eat.type = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line">b.eat.price = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18, eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;30&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// b = &#123;name: &#x27;哇哈哈&#x27;, age: 18, eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;30&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype-slice-和-Array-prototype-concat"><a href="#Array-prototype-slice-和-Array-prototype-concat" class="headerlink" title="Array.prototype.slice() 和 Array.prototype.concat()"></a>Array.prototype.slice() 和 Array.prototype.concat()</h3><p>该方法只能用于深拷贝第一层的值，当拷贝第二层的值时仍是引用同一个内存地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浅拷贝会在栈中开辟一个新的内存空间，将原对象一级中的“基本数据类型”复制一份到新的内存空间，所以相互不影响。当对象中有“引用类型”时，它只能拷贝“引用类型”在堆内存中的地址,所以赋值后会影响原对象的值。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法可以实现深拷贝。 但是需要注意</span></span><br><span class="line"><span class="comment">//1：会忽略undefined，Symbol，函数。</span></span><br><span class="line"><span class="comment">//2：在处理new Date() 会出错</span></span><br><span class="line"><span class="comment">//3：循环引用会出错</span></span><br><span class="line"><span class="comment">//4：不能处理正则，拷贝的是一个空对象</span></span><br><span class="line"><span class="comment">//5：继承的属性会丢失</span></span><br><span class="line"><span class="comment">//一句话概括：可以转成 JSON 格式的对象才能使用这种方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">from</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">to</span>: <span class="built_in">Symbol</span>(<span class="string">&#x27;深圳&#x27;</span>),</span><br><span class="line">    <span class="attr">nums</span>: <span class="regexp">/&#x27;g&#x27;/</span>,</span><br><span class="line">    eat:&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">b.name = <span class="string">&quot;哇哈哈&quot;</span>;</span><br><span class="line">b.eat.type = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line">b.eat.price = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18, nums: /&#x27;g&#x27;/, fn: function()&#123;&#125;, eat:&#123; type: &#x27;苹果&#x27;, price: &#x27;18&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// b = &#123;name: &#x27;哇哈哈&#x27;, age: 18, nums: &#123;&#125;, eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;30&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="使用递归函数遍历"><a href="#使用递归函数遍历" class="headerlink" title="使用递归函数遍历"></a>使用递归函数遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个递归函数</span></span><br><span class="line">deepCopy = <span class="function">(<span class="params">source</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> targetObj = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;; <span class="comment">// 先判断是数组还是对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> keys <span class="keyword">in</span> source)&#123;  <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">if</span>(source.hasOwnProperty(keys))&#123;</span><br><span class="line">            <span class="keyword">if</span>(source[keys] &amp;&amp; <span class="keyword">typeof</span> source[keys] === <span class="string">&#x27;object&#x27;</span>)&#123; <span class="comment">// 如果值是对象，直接递归</span></span><br><span class="line">                targetObj[keys] = source[keys].constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">                targetObj[keys] = <span class="built_in">this</span>.deepCopy(source[keys]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果不是，就直接赋值</span></span><br><span class="line">                targetObj[keys] = source[keys];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;voledy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">eat</span>:&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">tt</span>:&#123;</span><br><span class="line">            <span class="attr">aaa</span>: <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">this</span>.deepCopy(a);</span><br><span class="line">b.eat.type = <span class="string">&#x27;西瓜&#x27;</span>;</span><br><span class="line">b.eat.tt.aaa = <span class="string">&#x27;666666&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a = &#123;name: &#x27;voledy&#x27;, age: 18,  eat:&#123; type: &#x27;苹果&#x27;, price: &#x27;18&#x27;, tt:&#123;aaa: 1000&#125;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// b = &#123;name: &#x27;voledy&#x27;, age: 18,  eat:&#123; type: &#x27;西瓜&#x27;, price: &#x27;18&#x27;, tt:&#123;aaa: 666&#125;&#125;&#125;;</span></span><br></pre></td></tr></table></figure><h1 id="伪数组转为数组的方法"><a href="#伪数组转为数组的方法" class="headerlink" title="伪数组转为数组的方法"></a>伪数组转为数组的方法</h1><p>假设这里有个伪数组：pagis</p><p>1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [].slice.call(pagis)</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr  = Array.prototype.slice.call(pagis);</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [],</span><br><span class="line">len1 = pagis.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">  arr1.push(pagis[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="built_in">Function</span>.prototype.call.bind(<span class="built_in">Array</span>.prototype.slice);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;类数组转换成数组：&#x27;</span>, func(pagis));</span><br></pre></td></tr></table></figure><p>5 解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> newArr = [...arguments];</span><br><span class="line">  <span class="built_in">console</span>.log(newArr);</span><br><span class="line">&#125;</span><br><span class="line">args(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">34</span>);</span><br></pre></td></tr></table></figure><p>6 Array.from</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> newArr2 = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(newArr2);</span><br><span class="line">&#125;</span><br><span class="line">args(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">34</span>);</span><br></pre></td></tr></table></figure><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><h2 id="普通函数调用"><a href="#普通函数调用" class="headerlink" title="普通函数调用"></a>普通函数调用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;globle&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name=<span class="string">&quot;xl&quot;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> person();  <span class="comment">//输出  window  globle</span></span><br></pre></td></tr></table></figure><p>全局直接调用函数,函数中的this指向window</p><h2 id="作为方法调用"><a href="#作为方法调用" class="headerlink" title="作为方法调用"></a>作为方法调用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;xl&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();  <span class="comment">//输出  xl</span></span><br><span class="line"><span class="comment">//这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> showNameA=person.showName;</span><br><span class="line">showNameA();    <span class="comment">//输出  XL</span></span><br><span class="line"><span class="comment">//这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window</span></span><br></pre></td></tr></table></figure><p>换种形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personA=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;xl&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personB=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;XL&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:personA.showName</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">personB.sayName();  <span class="comment">//输出 XL</span></span><br><span class="line"><span class="comment">//虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向B</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> personA = Person(<span class="string">&quot;xl&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(personA.name); <span class="comment">// 输出  undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);<span class="comment">//输出  xl</span></span><br><span class="line"><span class="comment">//上面代码没有进行new操作，相当于window对象调用Person(&quot;xl&quot;)方法，那么this指向window对象，并进行赋值操作window.name=&quot;xl&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">&quot;xl&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(personB.name);<span class="comment">// 输出 xl</span></span><br></pre></td></tr></table></figure><h2 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout"></a>settimeout</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;my name is &quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;,<span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">&quot;xl&quot;</span>);</span><br><span class="line">person.sayName()  <span class="comment">//输出  “my name is XL”;</span></span><br><span class="line"><span class="comment">//这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL </span></span><br></pre></td></tr></table></figure><p>那么如何才能输出<code>&quot;my name is xl&quot;</code>呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;my name is &quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>),<span class="number">50</span>)  <span class="comment">//注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">&quot;xl&quot;</span>);</span><br><span class="line">person.sayName(); <span class="comment">//输出 “my name is xl”;</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;xl&quot;</span>,</span><br><span class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;)(<span class="built_in">this</span>.showName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName();  <span class="comment">//输出 XL</span></span><br><span class="line"><span class="comment">//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;XL&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;xl&quot;</span>,</span><br><span class="line"><span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">   callback();</span><br><span class="line">&#125;)(<span class="built_in">this</span>.showName.bind(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName() ;  <span class="comment">//输出  &quot;xl&quot;</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><code>es6</code>里面<code>this</code>指向固定化，始终指向外部对象，因为箭头函数没有<code>this</code>,因此它自身不能进行<code>new</code>实例化,同时也不能使用<code>call, apply, bind</code>等方法来改变<code>this</code>的指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.seconds = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">setInterval</span>( <span class="function">() =&gt;</span> <span class="built_in">this</span>.seconds ++, <span class="number">1000</span>);</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(timer.seconds), <span class="number">3100</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"><span class="attr">sayThis</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">sayThis2</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//test</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">sayThis3</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//test</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//在匿名函数内,所以默认是window</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//箭头函数没有this,取定义所在位置this,就是匿名函数的this,为window</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">test.sayThis()<span class="comment">//window</span></span><br><span class="line">test.sayThis2()()<span class="comment">//test</span></span><br><span class="line">test.sayThis3()()()<span class="comment">//test window window</span></span><br></pre></td></tr></table></figure><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>在一段时间只执行一次,<strong>最后一次有效</strong>.控制次数</p><p>场景:</p><ul><li><p>搜索输入框（Autocomplete），当不再输入后的几百毫秒再去发送请求，减少服务器压力。</p></li><li><p>注册框(即时判断是否重复用户名)，或需要后台校验的文本输入框同理。</p></li><li><p>不停改变浏览器窗口大小会触发多次 resize 事件，引起浏览器的<a href="https://juejin.cn/post/6896243562225401869">重排</a>【关联概念(弱)】，消耗性能。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun, timeout</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fun.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> login = <span class="function"><span class="keyword">function</span> (<span class="params">e, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> loginDebounce = debounce(login, <span class="number">2000</span>)</span><br><span class="line">loading.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    loginDebounce(e, <span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>只在<strong>开始执行一次</strong>，未执行完成过程中触发的忽略，核心在于<code>开关锁</code>.总而言之<code>节流</code>就是在<strong>一段时间内不断操作而在你规定的时间内只执行一次的一种提高性能的方法</strong>.节流<strong>至少</strong>在<strong>每时间间隔内</strong> <strong>保证有规律地执行</strong>该功能。控制频率</p><p>场景:比如我们滚动鼠标滚轮监听滚动条位置，防止按钮多次点击等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        fun.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;被点击了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> clickDebounce = throttle(clickHandle, <span class="number">2000</span>)</span><br><span class="line">loading.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickDebounce)</span><br></pre></td></tr></table></figure><p>对于<code>防抖</code>和<code>节流</code>一个最主观的判断方法就是：在<code>10s</code>内你<strong>疯狂点击一个按钮</strong>，如果使用了<strong>防抖则会只执行一次</strong>，而你使用了<strong>节流则会每隔一段时间执行一次</strong>，这个时间可以自己来掌控。</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>它规定了<code>协议号-域名-端口号</code>这三者必须都<code>相同</code>才符合<code>同源策略</code>,如有有一个<code>不相同</code>，就会出现跨域问题，不符合<code>同源策略</code>导致的后果有</p><ul><li>1、<code>LocalStorge、SessionStorge、Cookie</code>等浏览器内存无法跨域访问</li><li>2、<code>DOM节点</code>无法跨域操作</li><li>3、<code>Ajax请求</code>无法跨域请求</li></ul><h2 id="跨域发生的时机"><a href="#跨域发生的时机" class="headerlink" title="跨域发生的时机"></a>跨域发生的时机</h2><p>请求发出去到后端，后端返回数据，在浏览器接收后端数据时被浏览器的跨域报错拦下来</p><h2 id="JSPON"><a href="#JSPON" class="headerlink" title="JSPON"></a>JSPON</h2><p>以下这三个标签<code>加载资源路径</code>是不受束缚的</p><ul><li>1、script标签：<code>&lt;script src=&quot;加载资源路径&quot;&gt;&lt;/script&gt;</code></li><li>2、link标签：<code>&lt;link herf=&quot;加载资源路径&quot;&gt;&lt;/link&gt;</code></li><li>3、img标签：<code>&lt;img src=&quot;加载资源路径&quot;&gt;&lt;/img&gt;</code></li></ul><p>JSONP通俗点说就是：利用script的src去发送请求，将一个方法名<code>callback</code>传给后端，后端拿到这个方法名，将所需数据，通过字符串拼接成新的字符串<code>callback(所需数据)</code>，并发送到前端，前端接收到这个字符串之后，就会自动执行方法<code>callback(所需数据)</code>。</p><p>缺点:JSONP的缺点就是，需要前后端配合，并且只支持<code>get请求方法</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端开发</title>
      <link href="/2021/09/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
      <url>/2021/09/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.超小屏幕下(手机) 小于768  布局容器宽度为100% */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">767px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.小屏幕下(平板) 大于等于768   布局容器宽度为750px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">768px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.中等屏幕下 992以上  布局容器宽度为970px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">992px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.大屏幕下 1200以上  布局容器宽度为1170px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>对于插入图片来说,市面上大多数的视网膜屏会自动放大图片css像素的两倍.按这个比例放大倍数会造成图片模糊.</p><p>解决方法:比如对于一张100*100的图片,手动设置他的宽高为原来的一半,即50 50这样他自动放大二倍就会编程原来的比例</p><p>或者切图切出一张二倍图,比如100*100的图片切出一个二倍的200 200这样设置宽高为100 100即可</p><h2 id="背景图片缩放"><a href="#背景图片缩放" class="headerlink" title="背景图片缩放"></a>背景图片缩放</h2><p>background-size</p><ul><li>数值 第一个参数为宽度,第二个参数为高度,空格隔开.如果只写一个就是宽度,高度等比例缩放</li><li>百分比 相对于父元素</li><li>cover 等比例扩大到足够大把背景区域填充满</li><li>contain 把图像等比例扩大到宽度或高度的最大值</li></ul><p>解决方法:比如对于一张100*100的图片,手动设置他的宽高为原来的一半,即50 50这样他自动放大二倍就会编程原来的比例</p><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="流式布局-百分比布局"><a href="#流式布局-百分比布局" class="headerlink" title="流式布局(百分比布局)"></a>流式布局(百分比布局)</h2><p>搭配max-width和min-width</p><p>参考DJ-Mobile 京东百分比布局</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><h2 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h2><p>为什么会有这种布局?</p><p>1页面布局文字能否随着屏幕大小变化而变化?</p><p>2流式布局和flex布局主要针对于宽度布局,那高度如何设置?</p><p>3怎么让屏幕发生变化的时候元素高度和宽度等比例缩放?</p><h3 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h3><p>先说一下em,em是<strong>父元素字体大小</strong>,举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">        font-size: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">        width: 10em;</span><br><span class="line">        height: 10em;</span><br><span class="line">        background-color: azure;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">  //body</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的页面p元素的大小就是长为120px,宽为120px</p><p>rem是相对于<strong>html元素的字体大小</strong>,即根元素</p><p>rem优点:可以通过改变html里面文字大小来改变页面中元素大小</p><h3 id="媒体查询-1"><a href="#媒体查询-1" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询可以根据不同的屏幕尺寸设置不同的样式</p><p>语法:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature)&#123;</span><br><span class="line">css-<span class="selector-tag">code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mediatype媒体类型</p><p>​    print 打印机  screen屏幕    </p><p>media feature 媒体特性</p><p>​    width 宽度  min-width最小宽度  max-width最大宽度</p><p>例子:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">800px</span>)&#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现当屏幕尺寸小于等于800像素的时候背景颜色为红色.</p><h4 id="媒体查询-rem"><a href="#媒体查询-rem" class="headerlink" title="媒体查询+rem"></a>媒体查询+rem</h4><p>根据屏幕大小设置不同的html字体大小,从而页面中的元素使用rem单位随着html中文字的大小而变化</p><h4 id="媒体查询引入资源"><a href="#媒体查询引入资源" class="headerlink" title="媒体查询引入资源"></a>媒体查询引入资源</h4><p>针对页面布局差异较大的时候,比如大屏时一行显示两个div,而屏幕小的时候需要换行显示,这种时候需要写两个css布局文件,根据屏幕大小改变时来展示不同的布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style320.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:320px)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style320.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:6400px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h3 id="css弊端"><a href="#css弊端" class="headerlink" title="css弊端"></a>css弊端</h3><ul><li>css需要书写大量看似没有逻辑的代码,冗余度高</li><li>不方便维护和扩展,不利于复用</li><li>css没有很好的计算能力</li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Leaner Style Sheets 是一门css扩展语言,也称为css预处理器</p><h4 id="less变量"><a href="#less变量" class="headerlink" title="less变量"></a>less变量</h4><p>再css种一些颜色和数值经常使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@变量名:值;</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量</span></span><br><span class="line"><span class="variable">@mainColor:</span>red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="variable">@mainColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>easy less插件,less文件保存自动生成css文件</p><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ul><li>后代</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="comment">//less嵌套 子元素的样式直接写道父元素里面就好了</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪类使用&amp;</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就相当于下面的css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h4><ul><li>运算符左右都要有空格隔开</li><li>两个数参与运算,有不同的单位,以第一个单位为准</li></ul><h2 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h2><ul><li>首先选一套标准尺寸,750为准</li><li>用屏幕尺寸除以划分的份数得到了html里面文字的大小.但是我们知道不同屏幕下得到的文字大小不一样</li><li>页面元素的rem值 = 页面元素值(px) / (屏幕宽度/划分的份数)</li></ul><p>页面元素的rem值=页面元素值(px) / (屏幕宽度/划分的份数)</p><p>屏幕宽度/划分的份数就是 html font-size的大小</p><h2 id="rem适配方案2"><a href="#rem适配方案2" class="headerlink" title="rem适配方案2"></a>rem适配方案2</h2><p>flexible.js+rem</p><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>利用媒体查询,通过改变布局容器的大小来适应不同的设备</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        <span class="selector-class">.container</span> &#123;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: aqua;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.超小屏幕下(手机) 小于768  布局容器宽度为100% */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">767px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.小屏幕下(平板) 大于等于768   布局容器宽度为750px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">768px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.中等屏幕下 992以上  布局容器宽度为970px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">992px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1.大屏幕下 1200以上  布局容器宽度为1170px */</span></span><br><span class="line">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css揭秘</title>
      <link href="/2021/08/02/css%E6%8F%AD%E7%A7%98/"/>
      <url>/2021/08/02/css%E6%8F%AD%E7%A7%98/</url>
      
        <content type="html"><![CDATA[<h1 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h1><h2 id="自适应椭圆"><a href="#自适应椭圆" class="headerlink" title="自适应椭圆"></a>自适应椭圆</h2><h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>到 border-radius，有一个鲜为人知的真相：它可以单独指定水平 和垂直半径，只要用一个斜杠（/）分隔这两个值即可。这个特性允许我 们在拐角处创建椭圆圆角.因此，如果我们有一个尺寸为 200px×150px 的元素，就可以把它圆角的两个半径值分别指定为元素宽高的 一半，从而得到一个精确的椭圆：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">100px</span> / <span class="number">75px</span>;</span><br></pre></td></tr></table></figure><p>但是，这段代码存在一个很大的缺陷：只要元素的尺寸发生变化， border-radius 的值就得跟着改。</p><p>其实，border-radius 这个属性还有另外 一个鲜为人知的真相，它不仅可以接受长度值，还可以接受百分比值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">50%</span></span><br></pre></td></tr></table></figure><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><h3 id="嵌套元素方案"><a href="#嵌套元素方案" class="headerlink" title="嵌套元素方案"></a>嵌套元素方案</h3><p>使用transform: skewX(-45deg);可以使图形倾斜,但是这会使里面的内容也倾斜.这时可以给里面的内容加一个div使其反方向倾斜就好了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#yolo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.button</span> &#123; <span class="attribute">transform</span>: <span class="built_in">skewX</span>(-<span class="number">45deg</span>); &#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.button</span> &gt; <span class="selector-tag">div</span> &#123; <span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">45deg</span>); &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="伪元素方案"><a href="#伪元素方案" class="headerlink" title="伪元素方案"></a>伪元素方案</h3><p>我们希望伪元素保持良好的灵活性，可以自动继承其宿主元素的尺寸， 甚至当宿主元素的尺寸是由其内容来决定时仍然如此。一个简单的办法是 给宿主元素应用 position: relative 样式，并为伪元素设置 position:  absolute，然后再把所有偏移量设置为零，以便让它在水平和垂直方向上都 被拉伸至宿主元素的尺寸。代码看起来是这样的.</p><p>用伪元素生成的方块是重叠在内容之上的，一旦给它设置背景， 就会遮住内容（参见图 3-16）。为了修复这个问题，我们可以给伪元素设置z-index: -1 样式，这样它的堆叠层次就会被推到宿主元素之后。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span>&#123;</span><br><span class="line"> <span class="attribute">position</span>: relative;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"> <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="attribute">position</span>: absolute;</span><br><span class="line"> <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h2><h3 id="基于变形的方案"><a href="#基于变形的方案" class="headerlink" title="基于变形的方案"></a>基于变形的方案</h3><p><strong>这种方法只适用于图片为正方形!!!!!!</strong></p><p>主要的思路与前一篇攻略“平行四边形”中讨论的第一个解决方案一 致：需要把图片用一个 </p><p> 包裹起来，然后对其应用相反的 rotate() 变形样式:</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>rotate(<em>angle</em>)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shapeBox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;bg.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.shapeBox</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.shapeBox</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>);</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是,这并不能达到我们所期望的效果,如下图,这会使内图形变为一个八角形,因为max-width: 100%这个属性.100% 会被解析为容器 （.picture）的边长。但是，我们想让图片的宽度与容器的对角线相等，而 不是与边长相等。因此，把 max-width 的值设置为142%</p><p><img src="/2021/08/02/css%E6%8F%AD%E7%A7%98/image-20210806134403770.png" alt="image-20210806134403770"></p><p>如果用 scale() 变形样式来把这个图片放大，实际上会更加合理</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.picture</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line"> <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line"> <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>) <span class="built_in">scale</span>(<span class="number">1.42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裁切路径方案"><a href="#裁切路径方案" class="headerlink" title="裁切路径方案"></a>裁切路径方案</h3><p> clip-path使用方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"> <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">50%</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">50%</span>,</span><br><span class="line"> <span class="number">50%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">50%</span>);</span><br><span class="line"> <span class="attribute">transition</span>: <span class="number">1s</span> clip-path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"> <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0</span> <span class="number">0</span>, <span class="number">100%</span> <span class="number">0</span>,</span><br><span class="line"> <span class="number">100%</span> <span class="number">100%</span>, <span class="number">0</span> <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2021/07/21/nodejs/"/>
      <url>/2021/07/21/nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h2 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h2><p>在一个文件中引用另一个文件的方式</p><p>在index.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载自己的文件,相对路径前必须加&#x27;./&#x27;,否则会认为是核心模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在a.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a文件被执行了&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输入命令node index.js后,运行index.js文件,会输出’a文件被执行了’</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>node中没有全局作用域,只有模块作用域,即变量只能在当前文件中使用.</p><h2 id="模块间的通信"><a href="#模块间的通信" class="headerlink" title="模块间的通信"></a>模块间的通信</h2><p>require方法有两个作用:</p><p>​    1.加载文件模块并执行里面的代码</p><p>​    2.拿到被加载文件模块导出的接口对象</p><p>在每个文件模块中都提供了一个对象exports,默认是一个空对象,require方法拿到的就是这个exports,我们要把所有需要被外部访问的成员挂载到这个exports里面.如:</p><p>在a.js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a文件被执行了&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="string">&#x27;a文件中的foo&#x27;</span></span><br></pre></td></tr></table></figure><p>在index.js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载自己的文件,相对路径前必须加&#x27;./&#x27;,否则会认为是核心模块</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>输入命令node index.js后,运行index.js文件,会输出’a文件被执行了’和{ foo: ‘a文件中的foo’ }</p><p>这样就能在index.js中取到a.js中的变量了</p><h1 id="http服务"><a href="#http服务" class="headerlink" title="http服务"></a>http服务</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这就是个服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听request请求事件</span></span><br><span class="line"><span class="comment">//当请求过来时,会自动触发request事件,然后执行回调函数</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// res.statusCode = 200</span></span><br><span class="line">    <span class="comment">//设置文件类型和编码方式,解决乱码问题</span></span><br><span class="line">    res.setHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/plain;charset=utf-8&quot;</span>)</span><br><span class="line">    <span class="comment">//响应内容</span></span><br><span class="line">    <span class="comment">// res.write(&#x27;hello my name is fx&#x27;)</span></span><br><span class="line">    <span class="comment">//响应完成后必须end,才表示告诉客户端,我的话说完了,可以传递给用户</span></span><br><span class="line">    <span class="comment">// res.end()</span></span><br><span class="line">    <span class="comment">//也可以发送响应数据同时结束响应</span></span><br><span class="line">    <span class="comment">// res.end(&#x27;hello my name is fx&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stu = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据不同的请求路径发送不同的响应结果</span></span><br><span class="line">    <span class="keyword">var</span> url = req.url</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="string">&#x27;/a&#x27;</span>) &#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(stu))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url == <span class="string">&#x27;/b&#x27;</span>) &#123;</span><br><span class="line">        res.end(<span class="string">&#x27;这是b页面&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">&#x27;没有找到&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听,启动服务</span></span><br><span class="line"><span class="comment">//回调函数是当服务启动后会调用这个函数</span></span><br><span class="line">server.listen(port, hostname, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器已经运行....&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><h2 id="router模块提取"><a href="#router模块提取" class="headerlink" title="router模块提取"></a>router模块提取</h2><p>除了入口文件外,新建一个router.js的文件用来管理路由.在router.js中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> router = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//一系列的此类路由</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;hello express哈哈哈哈哈&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>接下来在入口文件中接收并挂载即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema</span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost:27017/flower&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计集合结构</span></span><br><span class="line"><span class="keyword">var</span> roomSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    <span class="attr">roomId</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">roomInfo</span>: &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="built_in">Number</span>, <span class="comment">//开局状态,0未开局,1已开局,2比牌等待选择</span></span><br><span class="line">        <span class="attr">activeUser</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="attr">username</span>: <span class="built_in">String</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lastWinner</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="built_in">Number</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">coinPool</span>: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="attr">gamesNumber</span>: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="attr">bottomCoin</span>: <span class="built_in">Number</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">flowerUserList</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="attr">avatar</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">username</span>: <span class="built_in">String</span>,</span><br><span class="line">            <span class="attr">card</span>: [&#123;</span><br><span class="line">                <span class="attr">color</span>: <span class="built_in">String</span>,</span><br><span class="line">                <span class="attr">number</span>: <span class="built_in">Number</span>,</span><br><span class="line">                <span class="attr">name</span>: <span class="built_in">String</span>,</span><br><span class="line">                <span class="attr">order</span>: <span class="built_in">Number</span>,</span><br><span class="line">                <span class="attr">power</span>: <span class="built_in">Number</span>,</span><br><span class="line">                <span class="attr">path</span>: <span class="built_in">String</span>,</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="attr">cardType</span>: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="attr">coin</span>: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="attr">isDown</span>: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="attr">cardStatus</span>: <span class="built_in">Number</span>, <span class="comment">//是否看牌 0未看,1看了</span></span><br><span class="line">            <span class="attr">liveStatus</span>: <span class="built_in">Number</span>, <span class="comment">//是否弃牌或输 0输,1活着</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文档结构发布为模型</span></span><br><span class="line"><span class="keyword">const</span> flowerRoom = mongoose.model(<span class="string">&#x27;FlowerRoom&#x27;</span>, roomSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="keyword">const</span> room = <span class="keyword">new</span> flowerRoom(&#123;</span><br><span class="line">    <span class="attr">roomId</span>: <span class="number">111111</span>,</span><br><span class="line">    <span class="attr">roomInfo</span>: &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>, <span class="comment">//开局状态,0未开局,1已开局,2比牌等待选择</span></span><br><span class="line">        <span class="attr">activeUser</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lastWinner</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">coinPool</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">gamesNumber</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">bottomCoin</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">flowerUserList</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">avatar</span>:</span><br><span class="line">                <span class="string">&quot;https://img1.baidu.com/it/u=3583591450,2292153595&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&quot;</span>,</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&quot;等待玩家&quot;</span>,</span><br><span class="line">            <span class="attr">card</span>: [],</span><br><span class="line">            <span class="attr">cardType</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">coin</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">isDown</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">cardStatus</span>: <span class="number">0</span>, <span class="comment">//是否看牌 0未看,1看了</span></span><br><span class="line">            <span class="attr">liveStatus</span>: <span class="number">0</span>, <span class="comment">//是否弃牌或输 0输,1活着</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line">room.save().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;保存成功&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(flowerRoom.find());</span><br><span class="line"><span class="built_in">console</span>.log(flowerRoom.find(&#123; <span class="attr">roomId</span>: <span class="string">&quot;123456&quot;</span> &#125;));</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlowerRoom.remove(&#123; <span class="attr">roomId</span>: <span class="string">&quot;111111&quot;</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> node;前端;后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级程序设计(下)</title>
      <link href="/2021/07/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%8B/"/>
      <url>/2021/07/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>包括window对象,location对象,navigator对象,screen对象,history对象.</p><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性。也就是说， window.location 和 document.location 指向同一个对象。</p><p>location 对象不仅保存着当前加载文 档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息。</p><p><img src="/2021/07/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%B8%8B/image-20211013162903155.png" alt="image-20211013162903155"></p><h3 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h3><p>可以通过修改 location 对象修改浏览器的地址。<strong>最常见的是使用 assign()方法并传入一 个 URL.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果<strong>给 location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign()方法</strong>。比 如，下面两行代码都会执行与显式调用 assign()一样的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">&quot;http://www.wrox.com&quot;</span>; </span><br><span class="line">location.href = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>在以前面提到的方式修改 URL 之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退” 按钮时，就会导航到前一个页面。<strong>如果不希望增加历史记录，可以使用 replace()方法</strong>。这个方法接 收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace()之后，用户不能回到前一页。比 如下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>You won&#x27;t be able to get back here<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Enjoy this page for a second, because you won&#x27;t be coming back here.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></span><br><span class="line"><span class="javascript"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> location.replace(<span class="string">&quot;http://www.wrox.com/&quot;</span>), <span class="number">1000</span>); </span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>**最后一个修改地址的方法是 reload()**，它能重新加载当前显示的页面。调用 reload()而不传参 数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会 从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">// 重新加载，可能是从缓存加载</span></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">// 重新加载，从服务器加载</span></span><br></pre></td></tr></table></figure><p>脚本中位于 reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因 素。为此，最好把 reload()作为最后一行代码。</p><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><p>除 IE10 及更低版本外的浏览器，都可以通 过 plugins 数组来确定。这个数组中的每一项都包含如下属性。</p><p> name：插件名称。</p><p> description：插件介绍。 </p><p> filename：插件的文件名。 </p><p> length：由当前插件处理的 MIME 类型数量。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性， 所以每个 window 都有自己的 history 对象。</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数， 这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退（类似点击浏览器的“后 退”按钮），而正值表示在历史记录中前进（类似点击浏览器的“前进”按钮）。下面来看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.go(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.go(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.go(<span class="number">2</span>); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。Node 接口 在 JavaScript中被实现为 Node 类型，在除 IE之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有 <strong>nodeType 属性</strong>，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值 常量表示,节点类型可通过与这些常量比较来确定，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123;</span><br><span class="line"> alert(<span class="string">&quot;Node is an element.&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line"> value = someNode.nodeName; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//在这个例子中，先检查了节点是不是元素。如果是，则将其 nodeName 的值赋给一个变量。</span></span><br><span class="line"><span class="comment">//对元素而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null。</span></span><br></pre></td></tr></table></figure><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个<strong>类数组</strong>对象，用于存储可以按位置存取的有序节点。注意，NodeList 并不是 Array 的实例，但可以使用中括 号访问它的值，而且它也有 length 属性。<strong>NodeList 对象独特的地方在于，它其实是一个对 DOM 结 构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来。我们通常说 NodeList 是实时的 活动对象，而不是第一次访问时所获得内容的快照(后面的querySelectorAll()方法返回的NodeLis是快照,而不是实时的)。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种方法都是获取节点的方法</span></span><br><span class="line"><span class="comment">//即既可以用item()获得,也可以用中括号</span></span><br><span class="line"><span class="keyword">let</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count = someNode.childNodes.length; </span><br></pre></td></tr></table></figure><p>使用 Array.prototype. slice()可以像前面介绍 arguments 时一样把 NodeList 对象转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当然，使用 ES6 的 Array.from()静态方法，可以替换这种笨拙的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfNodes = <span class="built_in">Array</span>.from(someNode.childNodes);</span><br></pre></td></tr></table></figure><p>每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。childNodes 中的所有节点都 有同一个父元素，因此它们的 parentNode 属性都指向同一个节点。此外，childNodes 列表中的每个 节点都是同一列表中其他节点的同胞节点。而使用 <strong>previousSibling 和 nextSibling</strong> 可以在这个列 表的节点间导航。这个列表中第一个节点的 previousSibling 属性是 null，最后一个节点的 nextSibling 属性也是 null，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nextSibling === <span class="literal">null</span>)&#123;</span><br><span class="line"> alert(<span class="string">&quot;Last node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.previousSibling === <span class="literal">null</span>)&#123;</span><br><span class="line"> alert(<span class="string">&quot;First node in the parent&#x27;s childNodes list.&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>父节点和它的第一个及最后一个子节点也有专门属性：<strong>firstChild</strong> 和 <strong>lastChild</strong> 分别指向 childNodes 中的第一个和最后一个子节点。someNode.firstChild 的值始终等于 someNode. childNodes[0]，而 someNode.lastChild 的值始终等于 someNode.childNodes[someNode. childNodes.length-1]。</p><h4 id="操纵节点"><a href="#操纵节点" class="headerlink" title="操纵节点"></a>操纵节点</h4><ul><li><strong>appendChild()</strong></li></ul><p>appendChild()，用于在 childNodes 列表末尾添加节点。如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。 即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。</p><ul><li><strong>insertBefore()</strong></li></ul><p>如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 insertBefore()方法。 这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的 前一个同胞节点，并被返回。如果参照节点是 null，则 insertBefore()与 appendChild()效果相 同.</p><ul><li><strong>replaceChild()</strong></li></ul><p>replaceChild()方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档 树中完全移除，要插入的节点会取而代之。</p><ul><li><strong>removeChild()</strong></li></ul><p>要移除节点而不是替换节点，可以使用 removeChild()方法。这个方法接收一个参数，即要移除 的节点。被移除的节点会被返回.</p><p>以上四个方法都是通过父节点操纵其子元素.</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>所有节点类型还共享了两个方法。**第一个是 cloneNode()**，会返回与调用它的节点一模一样的节 点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制， 即复制节点及其整个子 DOM 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属 于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。</p><p>cloneNode()方法不会复制添加到 DOM 节点的 JavaScript 属性，比如事件处理程 序。这个方法只复制 HTML 属性，以及可选地复制子节点。除此之外则一概不会复制。</p><p><strong>normalize()<strong>。这个方法唯一的任务就是处理</strong>文档子树中的文本节点</strong>。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 normalize()方法会检测这个节点的所有后代，从中搜索上述两种 情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</p><h3 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h3><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> nodeType 等于 9；</span><br><span class="line"> nodeName 值为&quot;#document&quot;；</span><br><span class="line"> nodeValue 值为 null；</span><br><span class="line"> parentNode 值为 null；</span><br><span class="line"> ownerDocument 值为 null；</span><br><span class="line"> 子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction</span><br><span class="line">或 Comment 类型。</span><br></pre></td></tr></table></figure><p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例（HTMLDocument 继承 Document），表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象。</p><p>提供了两个访问子节点的快捷方式。<strong>第一个是 documentElement 属 性，始终指向 HTML 页面中的元素。</strong>虽然 document.childNodes 中始终有元素，但 使用 documentElement 属性可以更快更直接地访问该元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>作为 HTMLDocument 的实例，<strong>document 对象还有一个 body 属性，直接指向body元素。</strong>因为 这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到 document.body，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="built_in">document</span>.body; <span class="comment">// 取得对&lt;body&gt;的引用</span></span><br><span class="line"><span class="keyword">let</span> doctype = <span class="built_in">document</span>.doctype; <span class="comment">// 取得对&lt;!doctype&gt;的引用</span></span><br></pre></td></tr></table></figure><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文档标题</span></span><br><span class="line"><span class="keyword">let</span> originalTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="comment">// 修改文档标题</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&quot;New page title&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得完整的 URL,URL 包含当前页面的完整 URL（地址栏中的 URL）</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">document</span>.URL;</span><br><span class="line"><span class="comment">// 取得域名</span></span><br><span class="line"><span class="keyword">let</span> domain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="comment">// 取得来源</span></span><br><span class="line"><span class="keyword">let</span> referrer = <span class="built_in">document</span>.referrer;</span><br></pre></td></tr></table></figure><p>URL 跟域名是相关的。比如，如果 document.URL 是 <a href="http://www.wrox.com/WileyCDA/%EF%BC%8C%E5%88%99">http://www.wrox.com/WileyCDA/，则</a> document.domain 就是 <a href="http://www.wrox.com./">www.wrox.com。</a></p><p>在这些属性中，只有 domain 属性是可以设置的。出于安全考虑，给 domain 属性设置的值是有限制的。如果 URL包含子域名如 p2p.wrox.com，则可以将 domain 设置为”wrox.com”（URL包含“www” 时也一样，比如 <a href="http://www.wrox.com).不能给这个属性设置/">www.wrox.com）。不能给这个属性设置</a> URL 中不包含的值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;nczonline.net&quot;</span>; <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><p>当页面中包含来自某个不同子域的窗格（）或内嵌窗格（&lt;iframe）时，设置<br>document.domain 是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 JavaScript通信。此时，在每个页面上把 document.domain 设置为相同的值，这些页面就可以访问对方的 JavaScript对象了。比如，一个加载自 <a href="http://www.wrox.com/">www.wrox.com</a> 的页面中包含一个内嵌窗格，其中的页面加载自p2p.wrox.com。这两个页面的 document.domain 包含不同的字符串，内部和外部页面相互之间不能访问对方的 JavaScript 对象。如果每个页面都把 document.domain 设置为wrox.com，那这两个页面之间就可以通信了。<br>浏览器对 domain 属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把<br>document.domain 设置为”wrox.com”之后，就不能再将其设置回”p2p.wrox.com”，后者会导致错<br>误，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面来自 p2p.wrox.com</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;wrox.com&quot;</span>; <span class="comment">// 放松，成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;p2p.wrox.com&quot;</span>; <span class="comment">// 收紧，错误！</span></span><br></pre></td></tr></table></figure><h4 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h4><p>**getElementById()**和 **getElementsByTagName()**就是 Document 类型提供的两个方法。</p><p>getElementsByTagName()返回包含零个或多个元素的 NodeList。在 HTML 文档中，这个方法返回一个 HTMLCollection 对象。考虑到二者都是“实时”列表，HTMLCollection 与 NodeList 是很相似的。HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项 的引用。例如，假设页面中包含如下的<img>元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.gif&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myImage&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>那么也可以像这样从 images 中取得对这个元素的引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = images.namedItem(<span class="string">&quot;myImage&quot;</span>); </span><br><span class="line"><span class="comment">//也可以使用中括号直接获取</span></span><br><span class="line"><span class="keyword">let</span> myImage = images[<span class="string">&quot;myImage&quot;</span>]; </span><br></pre></td></tr></table></figure><p>对 HTMLCollection 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台， <strong>数值索引会调用 item()，字符串索引会调用 namedItem()。</strong></p><p>HTMLDocument 类型上定义的获取元素的第三个方法是 **getElementsByName()**。getElementsByName()方法也返回 HTMLCollection。</p><h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><p>特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> nodeType 等于 1；</span><br><span class="line"> nodeName 值为元素的标签名；</span><br><span class="line"> nodeValue 值为 null；</span><br><span class="line"> parentNode 值为 Document 或 Element 对象；</span><br><span class="line"> 子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、</span><br><span class="line">EntityReference 类型。</span><br></pre></td></tr></table></figure><p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 HTML 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bd&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Body text&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line">alert(div.id); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line">alert(div.className); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line">alert(div.title); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line">alert(div.lang); <span class="comment">// &quot;en&quot;</span></span><br><span class="line">alert(div.dir); <span class="comment">// &quot;ltr&quot; </span></span><br></pre></td></tr></table></figure><h4 id="取得属性"><a href="#取得属性" class="headerlink" title="取得属性"></a>取得属性</h4><p>与属性相关的 DOM 方法 主要有 3 个：getAttribute()、setAttribute()和 removeAttribute()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot;</span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;class&quot;</span>)); <span class="comment">// &quot;bd&quot;</span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;title&quot;</span>)); <span class="comment">// &quot;Body text&quot;</span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;lang&quot;</span>)); <span class="comment">// &quot;en&quot;</span></span><br><span class="line">alert(div.getAttribute(<span class="string">&quot;dir&quot;</span>)); <span class="comment">// &quot;ltr&quot;</span></span><br></pre></td></tr></table></figure><p>这种获取属性的方法和前面的不一样,重点为class,前面为className,这里为class,即元素中定义的什么属性名就是什么</p><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>可以使用 document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素 的标签名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>); </span><br></pre></td></tr></table></figure><p>可以使用 appendChild()、insertBefore()或 replaceChild()。 比如，以下代码会把刚才创建的元素添加到文档的元素中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><h1 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h1><h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p>动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。与对应的 HTML 元素一样，有两种方式通过<script>动态为网页添加脚本：引入外部文件和直接插入源代码。</p><p>动态加载外部文件很容易实现，比如下面的:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>可以像这样通过 DOM 编程创建这个节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;foo.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script); </span><br></pre></td></tr></table></figure><p>另一个动态插入 JavaScript 的方式是嵌入源代码，如下面的例子所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"> alert(<span class="string">&quot;hi&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 DOM，可以实现以下逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>));</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script); </span><br></pre></td></tr></table></figure><h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p>CSS 样式在 HTML 页面中可以通过两个元素加载。<link>元素用于包含 CSS 外部文件，而<style>元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加 到页面中的。</p><p>来看下面这个典型的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素很容易使用 DOM 编程创建出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">link.rel = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">link.type = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">link.href = <span class="string">&quot;styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(link);</span><br></pre></td></tr></table></figure><p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后 顺序。一般来说，也没有必要知道样式什么时候加载完成。</p><p>另一种定义样式的方式是使用<script>元素包含嵌入的 CSS 规则，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css"> <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>逻辑上，下列 DOM 代码会有同样的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">style.type = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;body&#123;background-color:red&#125;&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.appendChild(style); </span><br></pre></td></tr></table></figure><h3 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h3><p>理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList 就是基于 DOM 文档的<strong>实时查询</strong>。例如，下面的代码会导致无穷 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i)&#123;</span><br><span class="line"> <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>第一行取得了包含文档中所有div元素的 HTMLCollection。因为这个集合是“实时的”，所以 任何时候只要向页面中添加一个新元素，再查询这个集合就会多一项。因为浏览器不希望保存每 次创建的集合，所以就会在每次访问时更新集合。这样就会出现前面使用循环的例子中所演示的问题。 每次循环开始，都会求值 i &lt; divs.length。这意味着要执行获取所有div元素的查询。因为循环 体中会创建并向文档添加一个新元素，所以每次循环 divs.length 的值也会递增。因为两个值 都会递增，所以 i 将永远不会等于 divs.length。</p><h2 id="MutationObserver-接口"><a href="#MutationObserver-接口" class="headerlink" title="MutationObserver 接口"></a>MutationObserver 接口</h2><p>MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使 用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>MutationObserver 的实例要通过调用 MutationObserver 构造函数并传入一个回调函数来创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;DOM was mutated!&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="observe-方法"><a href="#observe-方法" class="headerlink" title="observe()方法"></a>observe()方法</h4><p>新创建的 MutationObserver 实例不会关联 DOM 的任何部分。要把这个 observer 与 DOM 关 联起来，需要使用 observe()方法。这个方法接收两个必需的参数：要观察其变化的 DOM 节点，以及 一个 MutationObserverInit 对象。</p><p>MutationObserverInit 对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。 例如，下面的代码会创建一个观察者（observer）并配置它观察元素上的属性变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br></pre></td></tr></table></figure><p>执行以上代码后，元素上任何属性发生变化都会被这个 MutationObserver 实例发现，然 后就会<strong>异步执行注册的回调函数</strong>。元素后代的修改或其他非属性修改都不会触发回调进入任务 队列。</p><h4 id="回调与-MutationRecord"><a href="#回调与-MutationRecord" class="headerlink" title="回调与 MutationRecord"></a>回调与 MutationRecord</h4><p>每个回调都会收到一个 MutationRecord 实例的数组。MutationRecord 实例包含的信息包括发 生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件 的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组。 下面展示了反映一个属性变化的 MutationRecord 实例的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(</span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="built_in">console</span>.log(mutationRecords));</span><br><span class="line">observer.observe(<span class="built_in">document</span>.body, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;,</span></span><br><span class="line"><span class="comment">// attributeNamespace: null,</span></span><br><span class="line"><span class="comment">// nextSibling: null,</span></span><br><span class="line"><span class="comment">// oldValue: null,</span></span><br><span class="line"><span class="comment">// previousSibling: null</span></span><br><span class="line"><span class="comment">// removedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// target: body</span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ] </span></span><br></pre></td></tr></table></figure><h4 id="disconnect-方法"><a href="#disconnect-方法" class="headerlink" title="disconnect()方法"></a>disconnect()方法</h4><p>默认情况下，只要被观察的元素不被垃圾回收，MutationObserver 的回调就会响应 DOM 变化事 件，从而被执行。要提前终止执行回调，可以调用 disconnect()方法。</p><p>这个方法是同步的方法,若想观察一次并执行回调函数后再取消观察,则需要使用 setTimeout()让已经入列的回调执行完毕再调用 disconnect()</p><h3 id="MutationObserverInit-与观察范围"><a href="#MutationObserverInit-与观察范围" class="headerlink" title="MutationObserverInit 与观察范围"></a>MutationObserverInit 与观察范围</h3><p>MutationObserverInit 对象的subtree表示除了目标节点，是否观察目标节点的子树（后代）.如果是 false，则只观察目标节点的变化；如果是 true，则观察目标节点及其整个子树</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>MutationObserver 实例与目标节点之间的引用关系是非对称的。<strong>MutationObserver 拥有对要 观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</strong> 然而，目标节点却拥有对 MutationObserver 的强引用。<strong>如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</strong></p><p>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存 它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</p><h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h1><p>描述 DOM 扩展的两个标准：Selectors API 与 HTML5。</p><h2 id="Selectors-API"><a href="#Selectors-API" class="headerlink" title="Selectors API"></a>Selectors API</h2><p>Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。</p><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h3><p>querySelector()方法接收 CSS 选择符参数，返回匹配该模式的<strong>第一个后代元素</strong>，如果没有匹配 项则返回 null。下面是一些例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&quot;body&quot;</span>);</span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#myDiv&quot;</span>);<span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果选择符有语法错误或碰到不支持的选择符， 则 querySelector()方法会抛出错误。</p><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h3><p>querySelectorAll()方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回 <strong>所有匹配的节点</strong>，而不止一个。这个方法返回的是一个 NodeList 的静态实例。</p><p><strong>querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一 个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性 能问题(前面提到的每个节点的childNodes 属性返回的NodeList是一个实时的查询)。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).querySelectorAll(<span class="string">&quot;em&quot;</span>);</span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.selected&quot;</span>);</span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line">返回的 NodeList 对象可以通过 <span class="keyword">for</span>-<span class="keyword">of</span> 循环、item()方法或中括号语法取得个别元素。比如：</span><br><span class="line"><span class="keyword">let</span> strongElements = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line"><span class="comment">// 以下 3 个循环的效果一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> strong <span class="keyword">of</span> strongElements) &#123;</span><br><span class="line"> strong.className = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.length; ++i) &#123;</span><br><span class="line"> strongElements.item(i).className = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.length; ++i) &#123;</span><br><span class="line"> strongElements[i].className = <span class="string">&quot;important&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="matches"><a href="#matches" class="headerlink" title="matches()"></a>matches()</h3><p>matches()方法（在规范草案中称为 matchesSelector()）接收一个 CSS 选择符参数，如果元素 匹配则该选择符返回 true，否则返回 false。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.matches(<span class="string">&quot;body.page1&quot;</span>))&#123;</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h3><p>getElementsByClassName()方法接收一个参数，即包含一个或多个类名的字符串，返回类名中 包含相应类的元素的 NodeList。如果提供了多个类名，则顺序无关紧要。下面是几个示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;username current&quot;</span>);</span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).getElementsByClassName(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h3><p>在之前要为一个元素删除或添加一个类很复杂,比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bd user disabled&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>这个元素有 3 个类名。要想删除其中一个，就得先把 className 拆开，删除不想要的那个， 再把包含剩余类的字符串设置回去。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要删除&quot;user&quot;类</span></span><br><span class="line"><span class="keyword">let</span> targetClass = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"><span class="comment">// 把类名拆成数组</span></span><br><span class="line"><span class="keyword">let</span> classNames = div.className.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="comment">// 找到要删除类名的索引</span></span><br><span class="line"><span class="keyword">let</span> idx = classNames.indexOf(targetClass);</span><br><span class="line"><span class="comment">// 如果有则删除</span></span><br><span class="line"><span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"> classNames.splice(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重新设置类名</span></span><br><span class="line">div.className = classNames.join(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><p>classList 属性为这些操作提供了更简单也更安全的实现方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</span><br><span class="line"> contains(value)，返回布尔值，表示给定的 value 是否存在。</span><br><span class="line"> remove(value)，从类名列表中删除指定的字符串值 value。</span><br><span class="line"> toggle(value)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.classList.remove(<span class="string">&quot;disabled&quot;</span>); </span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.classList.add(<span class="string">&quot;current&quot;</span>); </span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.classList.toggle(<span class="string">&quot;user&quot;</span>); </span><br><span class="line"><span class="comment">// 检测类名 </span></span><br><span class="line"><span class="keyword">if</span> (div.classList.contains(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.classList.contains(<span class="string">&quot;disabled&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="class"><span class="keyword">class</span> <span class="title">of</span> <span class="title">div</span>.<span class="title">classList</span>)</span>&#123; </span><br><span class="line"> doStuff(<span class="class"><span class="keyword">class</span>)</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement，始终包含当前拥 有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个 元素自动获得焦点。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>默认情况下，document.activeElement 在页面刚加载完之后会设置为 document.body。而在 页面完全加载之前，document.activeElement 的值为 null。</p><p>其次是 document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.focus();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="document新属性"><a href="#document新属性" class="headerlink" title="document新属性"></a>document新属性</h3><ul><li>readyState 属性</li></ul><p>document.readyState 属性有两个可能的值：  loading，表示文档正在加载；  complete，表示文档加载完成。</p><p>在这 个属性得到广泛支持以前，通常要依赖 onload 事件处理程序设置一个标记，表示文档加载完了。这个 属性的基本用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">&quot;complete&quot;</span>)&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含 与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后 面跟什么都可以。下面是一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">data-appId</span>=<span class="string">&quot;12345&quot;</span> <span class="attr">data-myname</span>=<span class="string">&quot;Nicholas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.dataset.appId;</span><br><span class="line"><span class="keyword">let</span> myName = div.dataset.myname;</span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.dataset.appId = <span class="number">23456</span>;</span><br><span class="line">div.dataset.myname = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.dataset.myname)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><p>赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。</p><h4 id="outerHTML-属性"><a href="#outerHTML-属性" class="headerlink" title="outerHTML 属性"></a>outerHTML 属性</h4><p>读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用 outerHTML 设置 HTML，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.outerHTML = <span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>则会得到与执行以下脚本相同的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&quot;This is a paragraph.&quot;</span>));</span><br><span class="line">div.parentNode.replaceChild(p, div); </span><br></pre></td></tr></table></figure><p>新的p元素会取代 DOM 树中原来的div元素。</p><h4 id="insertAdjacentHTML-与-insertAdjacentText"><a href="#insertAdjacentHTML-与-insertAdjacentText" class="headerlink" title="insertAdjacentHTML()与 insertAdjacentText()"></a>insertAdjacentHTML()与 insertAdjacentText()</h4><p>它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数 必须是下列值中的一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点；</span><br><span class="line"> &quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面；</span><br><span class="line"> &quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；</span><br><span class="line"> &quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">// 作为第一个子节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line">element.insertAdjacentText(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入</span></span><br><span class="line">element.insertAdjacentHTML(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element.</span><br><span class="line">insertAdjacentText(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br></pre></td></tr></table></figure><h4 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h4><p>使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的 子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关 系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 innerHTML、 outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。</p><h3 id="scrollIntoView"><a href="#scrollIntoView" class="headerlink" title="scrollIntoView()"></a>scrollIntoView()</h3><p>scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元 素进入视口。这个方法的参数如下：</p><ul><li> alignToTop 是一个布尔值。 </li></ul><p>  ​     true：窗口滚动后元素的顶部与视口顶部对齐。 </p><p>  ​     false：窗口滚动后元素的底部与视口底部对齐。 </p><ul><li><p>scrollIntoViewOptions 是一个选项对象。 </p><p>​     behavior：定义过渡动画，可取的值为”smooth”和”auto”，默认为”auto”。 </p><p>​     block：定义垂直方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “start”。 </p><p>​     inline：定义水平方向的对齐，可取的值为”start”、”center”、”end”和”nearest”，默 认为 “nearest”。 </p></li><li><p> 不传参数等同于 alignToTop 为 true。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保元素可见</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(); </span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(<span class="literal">true</span>); </span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(&#123;<span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;); </span><br><span class="line"><span class="comment">// 尝试将元素平滑地滚入视口</span></span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;); </span><br></pre></td></tr></table></figure><h1 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h1><h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">qux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭 包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。正如下面的例子所示，foo()函数仍然会 在后面的指令之前被求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这 个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">当然，直接返回一个期约对象也是一样的：</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure><p>。从这 里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式 的媒介。</p><p>在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队 列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互 的方式就是使用异步结构——更具体地说，就是期约的方法。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h2><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>JSON 对象有两个方法：**stringify()和 parse()**。在简单的情况下，这两个方法分别可以将 JavaScript 序列化为 JSON 字符串，以及将 JSON 解析为原生 JavaScript 值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"> <span class="attr">authors</span>: [</span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用 JSON.stringify()把一个 JavaScript 对象序列化为一个 JSON 字符串</span></span><br><span class="line"><span class="comment">//保存在变量jsonText 中</span></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用以下代码创建与 book 对象类似的新对象：</span></span><br><span class="line"><span class="comment">//得到js值</span></span><br><span class="line"><span class="keyword">let</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText);</span><br></pre></td></tr></table></figure><h3 id="序列化选项-参数"><a href="#序列化选项-参数" class="headerlink" title="序列化选项(参数)"></a>序列化选项(参数)</h3><p>JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用 于指定其他序列化 JavaScript 对象的方式。<strong>第一个参数是过滤器，可以是数组或函数；第二个参数是用 于缩进结果 JSON 字符串的选项。</strong>单独或组合使用这些参数可以更好地控制 JSON 序列化。</p><p>如果第二个参数是一个数组，那么 JSON.stringify()返回的结果只会包含该数组中列出的对象 属性。比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"> <span class="attr">authors</span>: [</span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;edition&quot;</span>]);</span><br></pre></td></tr></table></figure><p>第二个参数是一个包含两个字符串的数组：”title” 和”edition”。它们对应着要序列化的对象中的属性，因此结果 JSON 字符串中只会包含这两个属性：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;title&quot;</span>:<span class="string">&quot;Professional JavaScript&quot;</span>,<span class="attr">&quot;edition&quot;</span>:<span class="number">4</span>&#125; </span><br></pre></td></tr></table></figure><p>提供的函数接收两个参数：属性名（key）和属性 值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值 不属于某个键/值对时会是空字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"> <span class="attr">authors</span>: [</span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="number">2017</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">switch</span>(key) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;authors&quot;</span>:</span><br><span class="line"> <span class="keyword">return</span> value.join(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;year&quot;</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;edition&quot;</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON()方法"></a>toJSON()方法</h3><p>对象需要在 JSON.stringify()之上自定义 JSON 序列化。此时，可以在要序列化的对象 中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>,</span><br><span class="line"> <span class="attr">authors</span>: [</span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>,</span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="attr">year</span>: <span class="number">2017</span>,</span><br><span class="line"> <span class="attr">toJSON</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.title;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br></pre></td></tr></table></figure><p>toJSON()方法可以与过滤函数一起使用，因此理解不同序列化流程的顺序非常重要。在把对象传 给 JSON.stringify()时会执行如下步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) 如果可以获取实际的值，则调用 toJSON()方法获取实际的值，否则使用默认的序列化。</span><br><span class="line">(2) 如果提供了第二个参数，则应用过滤。传入过滤函数的值就是第(1)步返回的值。</span><br><span class="line">(3) 第(2)步返回的每个值都会相应地进行序列化。</span><br><span class="line">(4) 如果提供了第三个参数，则相应地进行缩进。</span><br><span class="line">理解这个顺序有助于决定是创建 toJSON()方法，还是使用过滤函数，抑或是两者都用。</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级程序设计</title>
      <link href="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><p>var声明的范围是函数作用域,let声明的范围是块作用域.</p><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声 明的变量则会）</p><h2 id="在for循环中var和let"><a href="#在for循环中var和let" class="headerlink" title="在for循环中var和let"></a>在for循环中var和let</h2><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 你可能以为会输出 0、1、2、3、4 </span></span><br><span class="line"><span class="comment">// 实际上会输出 5、5、5、5、5 </span></span><br></pre></td></tr></table></figure><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时 逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。 </p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。 每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时<strong>必须同时初始化变量</strong>，且 尝试修改 const 声明的变量会导致运行时错误。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时， 返回的结果还是”undefined”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined </span></span><br><span class="line"><span class="comment">// 确保没有声明过这个变量</span></span><br><span class="line"><span class="comment">// let age </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>null 和 undefined 值没有 toString()方法。</p><p>如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串。</p><p> 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。 </p><p> 如果值是 null，返回”null”。</p><p>  如果值是 undefined，返回”undefined”。</p><h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><p><strong>== 会先进行强制类型转换</strong></p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p><p> 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换 为 1。 </p><p> 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否 相等。 </p><p> 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再 根据前面的规则进行比较。 </p><p>在进行比较时，这两个操作符会遵循如下规则。</p><p> null 和 undefined 相等。 </p><p> <strong>null 和 undefined 不能转换为其他类型的值再进行比较。</strong> null或undefined都不等于0</p><p> 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两 个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。 </p><p> 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 true。否则，两者不相等。</p><p><strong>===在比较相等时不转换操作数</strong></p><h2 id="字面量定义和new的区别"><a href="#字面量定义和new的区别" class="headerlink" title="字面量定义和new的区别"></a>字面量定义和new的区别</h2><p>原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会 创建一个 Object 类型的实例,如下例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line">name1.age = <span class="number">27</span>; </span><br><span class="line">name2.age = <span class="number">26</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name1.age); <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到 的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期 间。这意味着不能在运行时给原始值添加属性和方法。</p><h2 id="基本数据和引用数据"><a href="#基本数据和引用数据" class="headerlink" title="基本数据和引用数据"></a>基本数据和引用数据</h2><ul><li>基本数据类型的值在内存中占据固定大小的空间,因此被保存在栈内存中.<ul><li>从一个变量向另一个变量复制基本类型的值,会创建这个值的一个副本</li></ul></li><li>引用类型的值是对象,保存在堆内存中<ul><li>从一个变量向另一个变量复制引用类型的值,复制的其实是指针,因此两个变量最终都指向同一个对象</li></ul></li></ul><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>ECMAScript 中<strong>所有函数的参数都是按值传递的</strong>。这意味着函数外的值会被复制到函数内部的参数 中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line"> num += <span class="number">10</span>; </span><br><span class="line"> <span class="keyword">return</span> num; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count); </span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">setName(person); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> obj.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">setName(person); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意最后一个例子,说明了对象是按值传递的.</strong></p><p>当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置 为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将 指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”， 这表明<strong>函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指 向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</strong></p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>非数值.</p><p>特点:</p><p>(1)任何涉及NaN的操作都会返回NaN</p><p>(2)NaN与任何值都不相等,包括NaN本身</p><p>isNaN()方法也适用于对象,在基于对象调用这个函数时,会首先调用对象的valueOf()方法,然后确定该方法返回的值是否可以转换为数值,如果不能,则给予这个返回值再调用toString()方法,再测试返回值.</p><h3 id="Number-parseInt-和parseFloat"><a href="#Number-parseInt-和parseFloat" class="headerlink" title="Number(),parseInt()和parseFloat()"></a>Number(),parseInt()和parseFloat()</h3><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210621154640957.png" alt="Number()转换规则"></p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210621155004329.png" alt="parseInt()转换规则"></p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210621155130885.png" alt="parseFloat()转换规则"></p><h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210621172336067.png" alt="执行环境和作用域"></p><ul><li>每次进入一个新的执行环境,都会创建一个用于搜索变量和函数的作用域链</li><li>变量的执行环境有助于确定应该何时释放内存</li></ul><h2 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h2><p>虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有 其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> try/catch 语句的 catch 块</span><br><span class="line"> with 语句</span><br></pre></td></tr></table></figure><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添 加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误 对象的声明。看下面例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line"> <span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> url = href + qs;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> url;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。 buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是 location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那 个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数 上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块级作 用域（稍后介绍），所以在 with 块之外没有定义。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p><strong>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函 数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了， 那么它就会自动被添加到全局上下文</strong>，如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30 </span></span><br></pre></td></tr></table></figure><p>这一次，变量 sum 被用加法操作的结果初始化时并没有使用 var 声明。在调用 add()之后，sum 被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let是块级作用域声明,let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重 复的 let 声明会抛出 SyntaxError。</p><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，<strong>如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错</strong>。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“<strong>暂时性死区</strong>”（temporal dead zone，简称 TDZ）。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>ES6 同时还增加了 const 关键字。<strong>使用 const 声明的变量必须同时初始化为某个值</strong>。 一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值 为其他引用值，但对象的键则不受限制。</p><p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错， 但会静默失败：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例 都替换成实际的值，而不会通过查询表进行变量查找。</strong>谷歌的 V8 引擎就执行这种优化。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数 中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是 引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按 值和按引用访问，而传参则只有按值传递。</p><p>下面看传入对象的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName() 方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象 是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的 对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为， 当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传 递的，我们再来看看下面这个修改后的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name 的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置 为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将 指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”， <strong>这表明函数中参数的值改变之后，原始的引用仍然没变.当 obj 在函数内部被重写时，它变成了一个指 向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</strong></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>最常用的垃圾收集方式是标记清除.垃圾收集器在运行的时候会给存储在内存的所有变量都加上标记.然后它会去掉<strong>环境中的变量以及被环境中的变量引用的变量</strong>的标记.而在此之后再被加上标记的变量将被视为准备删除的变量,原因是环境中的变量已经无法访问到这些变量了.最后垃圾收集器完成内存清除工作,销毁那些带标记的值并回收他们所占用的空间.</p><p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下 文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现 并不重要，关键是策略。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变 量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为 0 的值的内存。</p><h3 id="引用计数的问题"><a href="#引用计数的问题" class="headerlink" title="引用计数的问题"></a>引用计数的问题</h3><p>了严重的问题：循环引用。所谓循环引 用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> objectA.someOtherObject = objectB; </span><br><span class="line"> objectB.anotherObject = objectA; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这个例子中，objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在 标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调 用，则会导致大量内存永远不会被释放。</p><p>在 IE8 及更早版本的 IE 中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 C++ 实现的组件对象模型（COM，Component Object Model）对象，而 COM 对象使用引用计数实现垃圾回 收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用 计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM 对象的循环引用问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure><p>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之 间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两 套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="通过let和const声明提升性能"><a href="#通过let和const声明提升性能" class="headerlink" title="通过let和const声明提升性能"></a>通过let和const声明提升性能</h4><p>因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回 收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。</p><h4 id="隐藏类和删除操作"><a href="#隐藏类和删除操作" class="headerlink" title="隐藏类和删除操作"></a>隐藏类和删除操作</h4><p>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类 的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(); </span><br></pre></td></tr></table></figure><p>V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原 型。假设之后又添加了下面这行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author = <span class="string">&#x27;Jake&#x27;</span>; </span><br></pre></td></tr></table></figure><p>此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有 可能对性能产生明显影响。</p><p>当然，解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在 构造函数中一次性声明所有属性，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="built_in">this</span>.author = opt_author; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的返回值），因此可以共享一个隐藏类， 从而带来潜在的性能提升。</p><p>不过要记住，使用 delete 关键字会导致生成相同的隐藏类片段。看一下这 个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br></pre></td></tr></table></figure><p>在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性 与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变 和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(); </span><br><span class="line">a1.author = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring() 方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上 这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当 第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。</p><p>在以读模式访问字符串 值的任何时候，后台都会执行以下 3 步：</p><p>(1) 创建一个 String 类型的实例；</p><p>(2) 调用实例上的特定方法；</p><p>(3) 销毁实例。</p><p>在读的时候相当于进行了如下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p><strong>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到 的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期 间。这意味着不能在运行时给原始值添加属性和方法。</strong>比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.color); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><p>原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对 象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject); <span class="comment">// &quot;object&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue); <span class="comment">// &quot;number&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>原始数值在调用 typeof 时始终返回”number”，而 Number 对象则返回”object”。类似地，Number 对象是 Number 类型的实例，而原始数值不是。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="字符串的操作方法"><a href="#字符串的操作方法" class="headerlink" title="字符串的操作方法"></a>字符串的操作方法</h4><p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：**slice()、substr()和 substring()**。</p><p>都接收一或两个参数。第一个参数表示子字符串开 始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是提取结 束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字符串数量。 任何情况下，省略第二个参数都意味着提取到字符串末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><p>当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字 符串长度加上负参数值。 而 substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。 substring()方法会将所有负参数值都转换为 0。</p><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符 串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法 从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。</p><h4 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h4><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、 endsWith()和 includes()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、 后所有空格符，再返回结果。比如：</p><h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传 给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。</p><p>ECMAScript 提供了 **Array.isArray()**方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的。</p><h3 id="转化数组"><a href="#转化数组" class="headerlink" title="转化数组"></a>转化数组</h3><p>Array 构造函数还有两个 ES6 新增的<strong>用于创建数组的静态方法：from()和 of()。from()用于将 类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。</strong></p><p>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性 和可索引元素的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像 调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函 数中 this 的值。但这个重写的 this 值在箭头函数中不适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="built_in">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3); <span class="comment">// [1, 4, 9, 16] </span></span><br></pre></td></tr></table></figure><p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype. slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h3 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h3><p>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充 的位置，它是可选的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(zeroes); <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br></pre></td></tr></table></figure><p>copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"> <span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">alert(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf() 返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的 字符串。</p><p>toLocaleString()方法也可能返回跟 toString()和 valueOf()相同的结果，但也不一定。<strong>在 调用数组的 toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法 唯一的区别是，为了得到最终的字符串，会调用数组每个值的 toLocaleString()方法，而不是 toString()方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line"> <span class="function"><span class="title">toLocaleString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line"> <span class="function"><span class="title">toLocaleString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> people = [person1, person2];</span><br><span class="line">alert(people); <span class="comment">// Nicholas,Greg</span></span><br><span class="line">alert(people.toString()); <span class="comment">// Nicholas,Greg</span></span><br><span class="line">alert(people.toLocaleString()); <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure><p>这里定义了两个对象 person1 和 person2，它们都定义了 toString()和 toLocaleString()方 法，而且返回不同的值。然后又创建了一个包含这两个对象的数组 people。在将数组传给 alert()时， 输出的是”Nicholas,Greg”，这是因为会在数组每一项上调用 toString()方法（与下一行显式调用 toString()方法结果一样）。而在调用数组的 toLocaleString()方法时，结果变成了”Nikolaos, Grigorios”，这是因为调用了数组每一项的 toLocaleString()方法。</p><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>pop和push,以栈的方式操作数组,pop弹出数组中最后的元素,push在数组尾部添加新的元素</p><p><strong>push返回新数组的长度</strong></p><p><strong>pop返回弹出的元素</strong></p><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>shift()和 push(),以队列的方式操作数组,shift删除数组中的第一个元素,push在数组尾部添加新的元素.对应有unshift方法,在数组开头添加任意多个值，然后返回新的数组长度。</p><p><strong>shift返回删除的元素</strong></p><p><strong>unshift返回新数组的长度</strong></p><h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。</p><p>reverse()方法就 是将数组元素反向排列。<strong>reverse()会改变原来的数组,并返回这个数组</strong></p><p>默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此， sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。<strong>sort()会改变原来的数组,并返回这个数组</strong>,即使数组的元素都是数值， 也会先把数组转换为字符串再比较、排序。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure><p>开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此， 即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情 况下都不是最合适的。为此，sort()方法可以接收一个<strong>比较函数</strong>，用于判断哪个值应该排在前面。</p><p>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相 等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一 个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>1 join() 方法也可将所有数组元素结合为一个字符串。它的行为类似 toString()，但是可以规定分隔符.**返回生成的字符串</p><p>2 shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引,方法返回被“位移出”的字符串</p><p>3 unshift() 方法（在开头）向数组添加新元素，并“反向位移”旧元素, 方法返回新数组的长度</p><p>4 splice() 方法可用于向数组添加新项 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;Lemon&quot;</span>, <span class="string">&quot;Kiwi&quot;</span>);</span><br><span class="line"><span class="comment">//此时数组为[&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Kiwi&quot;, &quot;Apple&quot;,&quot;Mango&quot;]</span></span><br></pre></td></tr></table></figure><p>​    第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>​        第二个参数（0）定义应删除多少元素。</p><p>​        其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>​        <strong>splice() 方法改变原数组,返回一个包含已删除项的数组</strong></p><p>5 concat() 方法通过合并（连接）现有数组来创建一个新数组.<strong>concat()不会改变原数组,返回连接后的新数组</strong></p><p>6 slice() 方法用数组的某个片段切出新数组</p><p>​        slice() 可接受两个参数，比如 (1, 3)。</p><p>​        该方法会从开始参数选取元素，直到结束参数（不包括）为止</p><p>​        如果结束参数被省略，则 slice() 会切出数组的剩余部分</p><p>​        <strong>slice()不会改变原数组,返回截取的片段数组</strong></p><h3 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h3><h4 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h4><p>ECMAScript 提供了 3 个严格相等的搜索方法：**indexOf()、lastIndexOf()和 includes()**。其 中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。</p><p>这些方法都接收两个参 数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项） 开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。 indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。 includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一 项时，会使用全等（===）比较，也就是说两项必须严格相等。</p><h4 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h4><p>find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回 第一个匹配的元素，findIndex()返回第一个匹配元素的索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line"> &#125;</span><br><span class="line">];</span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</span><br><span class="line"> some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</span><br><span class="line"> filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</span><br><span class="line"> forEach()：对数组每一项都运行传入的函数，没有返回值。</span><br><span class="line"> map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</span><br><span class="line"></span><br><span class="line">这些方法都不改变调用它们的数组。</span><br></pre></td></tr></table></figure><p>每个方法接收两个参数：以每一项为参数运行的函数， 以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(everyResult); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(someResult); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line">alert(mapResult); <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数 组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。 而 reduceRight()从最后一项开始遍历至第一项。</p><p>传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数 组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line">alert(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数 组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。</p><p>reduceRight()方法与之类似，只是方向相反。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>键值对</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// undefined </span></span><br><span class="line">alert(m.size); <span class="comment">// 0 </span></span><br><span class="line">m.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt </span></span><br><span class="line">alert(m.size); <span class="comment">// 2 </span></span><br><span class="line">m.delete(<span class="string">&quot;firstName&quot;</span>); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">alert(m.size); <span class="comment">// 1 </span></span><br><span class="line">m.clear(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">alert(m.size); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>与 Object 只能使用数值、字符串或符号作为键不同，<strong>Map 可以使用任何 JavaScript 数据类型作为 键</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">m.set(functionKey, <span class="string">&quot;functionValue&quot;</span>); </span><br><span class="line">m.set(symbolKey, <span class="string">&quot;symbolValue&quot;</span>); </span><br><span class="line">m.set(objectKey, <span class="string">&quot;objectValue&quot;</span>); </span><br><span class="line">alert(m.get(functionKey)); <span class="comment">// functionValue </span></span><br><span class="line">alert(m.get(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line">alert(m.get(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>迭代各个键方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123; </span><br><span class="line"> alert(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="built_in">Symbol</span>.iterator]()) &#123; </span><br><span class="line"> alert(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure><h3 id="选择Object还是Map"><a href="#选择Object还是Map" class="headerlink" title="选择Object还是Map"></a>选择Object还是Map</h3><ul><li>内存占用:存储单个键/值对所占用的内存数量 都会随键的数量线性增加。给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。</li><li>插入性能:向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快 一点儿。对这两个类型来说，<strong>插入速度并不会随着键/值对数量而线性增加</strong>。如果代码涉及大量插入操 作，那么显然 Map 的性能更佳。</li><li>查找速度:对这两个类型而言， 查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选 择 Object 更好一些。</li><li>删除性能:Map 的 delete()操作都比插入和查找更快。 如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。</li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/ 值对存储机制。WeakMap 中的“weak”（弱）， 描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。</p><p><strong>弱映射中的键只能是 Object 或者继承自 Object 的类型</strong>，尝试使用非对象设置键会抛出 TypeError。值的类型没有限制。</p><p>WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果 允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</p><h3 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h3><p><strong>WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用， 不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line">wm.set(&#123;&#125;, <span class="string">&quot;val&quot;</span>); </span><br></pre></td></tr></table></figure><p>set()方法初始化了一个新对象并将它用作一个字符串的键。<strong>因为没有指向这个对象的其他引用， 所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。</strong>然后，这个键/值对就从弱映射中消失 了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身 也会成为垃圾回收的目标。再来看另一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">key</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">wm.set(container.key, <span class="string">&quot;val&quot;</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> container.key = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目 标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以 把这个键/值对清理掉。</p><h3 id="不可迭代键"><a href="#不可迭代键" class="headerlink" title="不可迭代键"></a>不可迭代键</h3><p>因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。当然， 也用不着像 clear()这样一次性销毁所有键/值的方法.</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><p>弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。<strong>前提很明确：私有变量会存储在弱 映射中，以对象实例为键，以私有成员的字典为值。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123; </span><br><span class="line"> <span class="built_in">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line"> <span class="built_in">this</span>.setId(id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="title">setPrivate</span>(<span class="params">property, value</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">const</span> privateMembers = wm.get(<span class="built_in">this</span>) || &#123;&#125;; </span><br><span class="line"> privateMembers[property] = value; </span><br><span class="line"> wm.set(<span class="built_in">this</span>, privateMembers); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="title">getPrivate</span>(<span class="params">property</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> wm.get(<span class="built_in">this</span>)[property]; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="title">setId</span>(<span class="params">id</span>)</span> &#123; </span><br><span class="line"> <span class="built_in">this</span>.setPrivate(<span class="built_in">this</span>.idProperty, id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="title">getId</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.getPrivate(<span class="built_in">this</span>.idProperty); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>); </span><br><span class="line">alert(user.getId()); <span class="comment">// 123 </span></span><br><span class="line">user.setId(<span class="number">456</span>); </span><br><span class="line">alert(user.getId()); <span class="comment">// 456 </span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line">alert(wm.get(user)[user.idProperty]); <span class="comment">// 456 </span></span><br></pre></td></tr></table></figure><h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>属性分数据属性和访问器属性.</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个保存数据值的位置,值会从这个位置读取,也会写入到这个位置.数据属性有4个特性描述他们的行为.</p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210622140123295.png" alt="数据属性的4个特性"></p><p>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包 含：<strong>configurable、enumerable、writable 和 value</strong>，跟相关特性的名称一一对应。根据要修改 的特性，可以设置其中一个或多个值。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就 不能再修改了.</p><p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不 指定，则都默认为 false。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不 过这两个函数不是必需的。</p><p>访问器属性有 4 个特性描述它们的行为。 </p><ul><li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性 都是 true。</li><li> [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。 </li><li> [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。 </li><li> [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition </span></span><br><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">year_</span>: <span class="number">2017</span>, </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123; </span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue; </span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">book.year = <span class="number">2018</span>; </span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>year_和 edition。year_中的下划线常用来表示该 属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简 单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改 为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性 值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。<strong>只定义获取函数意味着属性是只读的，尝试修改属性会被忽 略。类似地，只有一个设置函数的属性 是不能读取的.</strong></p><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添 加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; <span class="comment">//数据属性</span></span><br><span class="line"> <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; <span class="comment">//数据属性</span></span><br><span class="line"> <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; <span class="comment">//访问器属性</span></span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.year_; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line"> <span class="built_in">this</span>.year_ = newValue; </span><br><span class="line"> <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>读取属性特性方法如下,两种方法,第一种获取的是year_属性的特性描述,第二种方法获取的是book对象的全部属性和描述.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br></pre></td></tr></table></figure><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>有时也称为”混入,就是把源对象所有的本地属性一起复制到目标对象上.</p><p>ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个 或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true） 和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性 会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标 对象上的[[Set]]设置属性的值。</p><p>Object.assign()实际上对每个源对象执行的是浅复制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;; </span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// Object.assign 会覆盖重复的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125; </span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123; </span><br><span class="line"> <span class="keyword">set</span> <span class="title">id</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// first </span></span><br><span class="line"><span class="comment">// second </span></span><br><span class="line"><span class="comment">// third </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); </span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a :&#123;&#125; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力.</p><p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑 到了上述边界情形。这个方法必须接收两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN() </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 0、-0、+0 相等/不等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 正确的 NaN 相等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>创建对象的方法有多种,使用 Object 构造函数或对象字面量可以方便地创建对象.下面介绍几种其他的创建对象的方法</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> o.name = name; </span><br><span class="line"> o.age = age; </span><br><span class="line"> o.job = job; </span><br><span class="line"> o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.name = name; </span><br><span class="line"> <span class="built_in">this</span>.age = age; </span><br><span class="line"> <span class="built_in">this</span>.job = job; </span><br><span class="line"> <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.sayName(); <span class="comment">// Greg </span></span><br></pre></td></tr></table></figure><p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。 </p><p>(1) 在内存中创建一个新对象。</p><p> (2) 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</p><p>(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</p><p> (4) 执行构造函数内部的代码（给新对象添加属性）。</p><p> (5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p><p>定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在 这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承 自 Object.</p><h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p>构造函数的主要问题在于，其定义的方法会在每个实例上 都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方 法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会 初始化一个对象。</p><p>但创建新 Function 实例的机制是一样的。因此不同实例上的函数虽然同名却不相等如下.</p><p><code>console.log(person1.sayName == person2.sayName); // false </code></p><p>这个新问题可以通过原型模式来解决</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>(1)isPrototypeOf()方法</p><p>可以使用 isPrototypeOf()方法确定两个对 象之间的这种关系。本质上，isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象时 返回 true，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(2)Object.getPrototypeOf()方法</p><p>返回参数的内部特性 [[Prototype]]的值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>(3)setPrototypeOf()方法</p><p>Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一 个新值。这样就可以重写一个对象的原型继承关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创 建一个新对象，同时为其指定原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped); </span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt </span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs); <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>(4)hasOwnProperty()方法</p><p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object 的，会在属性存在于调用它的对象实例上时返回 true.</p><h4 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h4><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。</p><p>在单独使用时，in 操作符会在可 以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">delete</span> person1.name; </span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>只要通过对象可以访问，in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上 时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性 是一个原型属性。</p><p>如果要确定某个属性是否存在于原型上，则可以像下 面这样同时使用 hasOwnProperty()和 in 操作符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例 属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会 在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p><h4 id="获取实例属性"><a href="#获取实例属性" class="headerlink" title="获取实例属性"></a>获取实例属性</h4><p>要获得对象上所有<strong>可枚举的实例属性</strong>，可以使用 Object.keys()方法。这个方法接收一个对象作 为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;name,age,job,sayName&quot; </span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(); </span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>; </span><br><span class="line">p1.age = <span class="number">31</span>; </span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1); </span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure><p>如果想列出<strong>所有实例属性，无论是否可以枚举</strong>，都可以使用 Object.getOwnPropertyNames()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); </span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure><p>注意，返回的结果中包含了一个不可枚举的属性 constructor。</p><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对 象所做的修改也会在实例上反映出来。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">friend.sayHi(); <span class="comment">// &quot;hi&quot;，没问题！</span></span><br></pre></td></tr></table></figure><p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但<strong>这跟重写整个原型是两 回事</strong>。<strong>实例的[[Prototype]]指针是在调用构造函数时自动赋值的</strong>，这个指针即使把原型修改为不同 的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。 记住，<strong>实例只有指向原型的指针，没有指向构造函数的指针</strong>。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: Person, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">friend.sayName(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时 候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。</p><h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默 认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共 享特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: Person, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，Person.prototype 有一个名为 friends 的属性，它包含一个字符串数组。然后这里创建 了两个 Person 的实例。person1.friends 通过 push 方法向数组中添加了一个字符串。由于这个 friends 属性存在于 Person.prototype 而非 person1 上，新加的这个字符串也会在（指向同一个 数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一 般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>ECMAScript 2017 新增了两 个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values() 返回对象值的数组，Object.entries()返回键/值对的数组。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>他们得关系如下图.</p><p><img src="/2021/06/21/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/devApp\myblog\source_posts\js高级程序设计\image-20210712100515851.png" alt="原型链继承"></p><h3 id="原型链继承的问题"><a href="#原型链继承的问题" class="headerlink" title="原型链继承的问题"></a>原型链继承的问题</h3><p>主要问题出现在原型中包含引用值的时候。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，SuperType 构造函数定义了一个 colors 属性，其中包含一个数组（引用值）。每 个 SuperType 的实例都会有自己的 colors 属性，包含自己的数组。但是，当 SubType 通过原型继承 SuperType 后，SubType.prototype 变成了 SuperType 的一个实例，因而也获得了自己的 colors 属性。这类似于创建了 SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会 共享这个 colors 属性。这一点通过 instance1.colors 上的修改也能反映到 instance2.colors 上就可以看出来。</p><p>优点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函 数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</p><p>缺点：1、新实例无法向父类构造函数传参。<br>　　　2、继承单一。<br>　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共 享的，一个实例修改了原型属性，另一个实例的原型属性 也会被修改！）</p><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 继承 SuperType</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure><h3 id="传参-1"><a href="#传参-1" class="headerlink" title="传参"></a>传参</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 继承 SuperType 并传参</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"> <span class="comment">// 实例属性</span></span><br><span class="line"> <span class="built_in">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">// 29 </span></span><br></pre></td></tr></table></figure><h3 id="盗用构造参数的问题"><a href="#盗用构造参数的问题" class="headerlink" title="盗用构造参数的问题"></a>盗用构造参数的问题</h3><p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</p><p>优点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。<br>　　　2、解决了原型链继承缺点1、2、3。<br>　　　3、可以继承多个构造函数属性（call多个）。<br>　　　4、在子实例中可向父实例传参。</p><p>缺点：1、只能继承父类构造函数的属性。<br>　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）<br>　　　3、每个新实例都有父类构造函数的副本，臃肿。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方 法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"> <span class="comment">// 继承属性</span></span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName(); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName(); <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27 </span></span><br></pre></td></tr></table></figure><p>优点：1、可以继承父类原型上的属性，可以传参，可复用。<br>　　　2、每个新实例引入的构造函数属性是私有的。</p><p>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>基本思路如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> F.prototype = o;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面给出一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5 通过增加 <strong>Object.create()方法</strong>将原型式继承的概念规范化了。这个方法接收两个 参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时， Object.create()与这里的 object()方法效果相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样：每个新增 属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line"> <span class="attr">name</span>: &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Greg&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name); <span class="comment">// &quot;Greg&quot; </span></span><br></pre></td></tr></table></figure><p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。<strong>但要记住， 属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</strong></p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> clone = object(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line"> clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>可以像下面这样使用 createAnother()函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// &quot;hi&quot; </span></span><br></pre></td></tr></table></figure><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是 创建子类原型时调用，另一次是在子类构造函数中调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>寄生式组合继承的基本模式如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line"> prototype.constructor = subType; <span class="comment">// 增强对象</span></span><br><span class="line"> subType.prototype = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如下例所示，调用 inheritPrototype()就可以实现前面例 子中的子类型原型赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line"> <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"> SuperType.call(<span class="built_in">this</span>, name); </span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原型链仍然保持不变，因此 instanceof 操作符和 isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p><h1 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h1><h2 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h2><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺 少其中任何一个参数都会抛出 TypeError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// id 属性会访问同一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// target</span></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为两个对象访问的是同一个值</span></span><br><span class="line">target.id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.id = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="comment">// 都会应用到目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined</span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="built_in">console</span>.log(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的主要目的是可以定义捕获器（trap）。<strong>捕获器就是在处理程序对象中定义的“基本操作的 拦截器”</strong>。每个处理程序对象可以包含零个或多个捕获器，<strong>每个捕获器都对应一种基本操作，可以直接 或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对 象之前先调用捕获器函数，从而拦截并修改相应的行为</strong>。</p><p>例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例 子定义了一个 get()捕获器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler); </span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar </span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// handler override </span></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar </span></span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(target)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// bar </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(proxy)[<span class="string">&#x27;foo&#x27;</span>]); <span class="comment">// handler override </span></span><br></pre></td></tr></table></figure><p>这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获 器。注意，<strong>只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正 常的行为。</strong></p><h3 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h3><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get() 捕获器会接收到<strong>目标对象、要查询的属性和代理对象</strong>三个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(trapTarget === target);</span><br><span class="line"> <span class="built_in">console</span>.log(property);</span><br><span class="line"> <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, </span><br><span class="line"> <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> handler = &#123; </span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> decoration = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"> <span class="keyword">if</span> (property === <span class="string">&#x27;foo&#x27;</span>) &#123; </span><br><span class="line"> decoration = <span class="string">&#x27;!!!&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments) + decoration; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler); </span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// bar!!! </span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar </span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz); <span class="comment">// qux </span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><h3 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h3><p>每个 捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式” （trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的 值时，会抛出 TypeError：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);</span><br><span class="line"><span class="comment">// TypeError </span></span><br></pre></td></tr></table></figure><h3 id="撤销代理"><a href="#撤销代理" class="headerlink" title="撤销代理"></a>撤销代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// intercepted</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="代理的问题和不足"><a href="#代理的问题和不足" class="headerlink" title="代理的问题和不足"></a>代理的问题和不足</h3><h2 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h2><p>代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p><p>不过，<strong>对于 在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</strong></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>使用代理可以在代码中实现一些有用的编程模式。</p><h3 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h3><p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获 器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Jake&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123; </span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments); </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">proxy.name; <span class="comment">// Getting name </span></span><br><span class="line">proxy.age = <span class="number">27</span>; <span class="comment">// Setting age=27 </span></span><br></pre></td></tr></table></figure><h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><h1 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>HTTP cookie 通常也叫作 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。例如，下面是包含这个头部的一个 HTTP 响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure><p>这个 HTTP 响应会设置一个名为”name”，值为”value”的 cookie。名和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服 务器，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.jsl HTTP/1.1</span><br><span class="line">Cookie: name=value</span><br><span class="line">Other-header: other-header-value </span><br></pre></td></tr></table></figure><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li><p>cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。这个限制能保证 cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。</p></li><li><p>浏览器也会限制 cookie 的大小。大多数浏览器对 cookie 的限制是不超过 4096 字节，上下可以有一 个字节的误差。为跨浏览器兼容，最好保证 cookie 的大小不超过 4095 字节。这个大小限制适用于一个 域的所有 cookie，而不是单个 cookie。</p></li><li><p> 由于 <strong>Cookie 以纯文本的形式在浏览器和服务器中传递</strong>，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。</p></li></ul><h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>默认情况下， 浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间,用于指定删除 cookie 的具体时间。这样即使关闭 浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>因为<strong>所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影 响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长</strong>。即使浏览器对 cookie 大小有 限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。</p><p><strong>Cookie数据会带到请求头的cookie字段里面，每次同主域名的请求中，都会传递数据，增加了网络请求的数据量，并且造成主域的污染。同时，cookie在不同浏览器上数量和大小都有限制</strong></p><p>注意 <strong>不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因 此任何人都可能获得</strong>。应该避免把信用卡号或个人地址等信息保存在 cookie 中。</p><h2 id="web-storage"><a href="#web-storage" class="headerlink" title="web storage"></a>web storage</h2><p>Web Storage 的第 2 版定义了两个对象：localStorage 和 sessionStorage。localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。</p><p>Storage 的实例与其他 对象一样，但增加了以下方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> clear()：删除所有值；不在 Firefox 中实现。</span><br><span class="line"> getItem(name)：取得给定 name 的值。</span><br><span class="line"> key(index)：取得给定数值位置的名称。</span><br><span class="line"> removeItem(name)：删除给定 name 的名/值对。</span><br><span class="line"> setItem(name, value)：设置给定 name 的值。</span><br></pre></td></tr></table></figure><h3 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h3><p><strong>sessionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。</strong>这跟浏览器关闭时 会消失的会话 cookie 类似。<strong>存储在 sessionStorage 中的数据不受页面刷新影响</strong>，可以在浏览器崩溃 并重启后恢复。（取决于浏览器，Firefox 和 WebKit 支持，IE 不支持。）</p><p>因为 sessionStorage 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在 sessionStorage 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。</p><p><strong>sessionStorage 对象应该主要用于存储只在会话期间有效的小块数据。</strong>如果需要跨会话持久存储 数据，可以使用localStorage。</p><h3 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h3><p>要访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。</p><h3 id="存储事件"><a href="#存储事件" class="headerlink" title="存储事件"></a>存储事件</h3><p>每当 Storage 对象发生变化时，都会在文档上触发 storage 事件。使用属性或 setItem()设置 值、使用 delete 或 removeItem()删除值，以及每次调用 clear()时都会触发这个事件。这个事件的 事件对象有如下 4 个属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> domain：存储变化对应的域。</span><br><span class="line"> key：被设置或删除的键。</span><br><span class="line"> newValue：键被设置的新值，若键被删除则为 null。</span><br><span class="line"> oldValue：键变化之前的值。</span><br></pre></td></tr></table></figure><p>可以使用如下代码监听 storage 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;storage&quot;</span>,</span><br><span class="line"> <span class="function">(<span class="params">event</span>) =&gt;</span> alert(<span class="string">&#x27;Storage changed for $&#123;event.domain&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>两种存储方法的区别在于，<strong>存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览 器而丢失。</strong></p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>Indexed Database API 简称 IndexedDB，是浏览器中<strong>存储结构化数据</strong>的一个方案。</p><p>IndexedDB 的设计几乎完全是<strong>异步</strong>的。为此，大多数操作以请求的形式执行，这些请求会异步执行， 产生成功的结果或错误。绝大多数 IndexedDB 操作要求添加 onerror 和 onsuccess 事件处理程序来确 定输出。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>使用 IndexedDB 数据库的第一步是调用 indexedDB.open()方法，并给它传入一个要打开的数据 库名称。如果给定名称的数据库已存在，则会发送一个打开它的请求；如果不存在，则会发送创建并打 开这个数据库的请求。这个方法会返回 IDBRequest 的实例，可以在这个实例上添加 onerror 和 onsuccess 事件处理程序。举例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db, </span><br><span class="line"> request, </span><br><span class="line"> version = <span class="number">1</span>; </span><br><span class="line">request = indexedDB.open(<span class="string">&quot;admin&quot;</span>, version); </span><br><span class="line">request.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> </span><br><span class="line"> alert(<span class="string">`Failed to open: <span class="subst">$&#123;event.target.errorCode&#125;</span>`</span>); </span><br><span class="line">request.onsuccess = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> db = event.target.result; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>如果 onsuccess 事件处理程序被调用，说明可以通过 <strong>event.target.result</strong> 访问数据库（IDBDatabase）实例了， 这个实例会保存到 db 变量中。之后，所有与数据库相关的操作都要通过 db 对象本身来进行。如果打 开数据库期间发生错误，<strong>event.target.errorCode</strong> 中就会存储表示问题的错误码。</p><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>假设要存储包含用户名、密码等内容的用户记录。可以用如下对象来表示一条记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; </span><br><span class="line"> <span class="attr">username</span>: <span class="string">&quot;007&quot;</span>, </span><br><span class="line"> <span class="attr">firstName</span>: <span class="string">&quot;James&quot;</span>, </span><br><span class="line"> <span class="attr">lastName</span>: <span class="string">&quot;Bond&quot;</span>, </span><br><span class="line"> <span class="attr">password</span>: <span class="string">&quot;foo&quot;</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>可以很容易看出最适合作为对象存储键的 username 属性。用户名必须全局唯一， 它也是大多数情况下访问数据的凭据。这个键很重要，因为创建对象存储时必须指定一个键。</p><p>数据库的版本决定了数据库模式，包括数据库中的对象存储和这些对象存储的结构。如果数据库还 不存在，open()操作会创建一个新数据库，然后触发 upgradeneeded 事件。可以为这个事件设置处 理程序，并在处理程序中创建数据库模式。如果数据库存在，而你指定了一个升级版的版本号，则会立 即触发 upgradeneeded 事件，因而可以在事件处理程序中更新数据库模式。</p><p>下面的代码演示了为存储上述用户信息如何创建对象存储：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request.onupgradeneeded = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">const</span> db = event.target.result; </span><br><span class="line"> <span class="comment">// 如果存在则删除当前 objectStore。测试的时候可以这样做</span></span><br><span class="line"> <span class="comment">// 但这样会在每次执行事件处理程序时删除已有数据</span></span><br><span class="line"> <span class="keyword">if</span> (db.objectStoreNames.contains(<span class="string">&quot;users&quot;</span>)) &#123; </span><br><span class="line"> db.deleteObjectStore(<span class="string">&quot;users&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> db.createObjectStore(<span class="string">&quot;users&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;username&quot;</span> &#125;); </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>创建了对象存储之后，剩下的所有操作都是通过事务完成的。事务要通过调用数据库对象的 transaction()方法创建。</p><p>想要访问多个对象存储，可以给第 一个参数传入一个字符串数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.transaction([<span class="string">&quot;users&quot;</span>, <span class="string">&quot;anotherStore&quot;</span>]);</span><br></pre></td></tr></table></figure><p>如前所述，每个事务都以只读方式访问数据。要修改访问模式，可以传入第二个参数。这个参数应 该是下列三个字符串之一：”readonly”、”readwrite”或”versionchange”。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transaction = db.transaction(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;readwrite&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="网络请求和跨域"><a href="#网络请求和跨域" class="headerlink" title="网络请求和跨域"></a>网络请求和跨域</h1><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>使用 XHR 对象首先要调用 open()方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、 请求 URL，以及表示请求是否异步的布尔值。send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 null， 因为这个参数在某些浏览器中是必需的。调用 send()之后，请求就会发送到服务器。下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>); </span><br></pre></td></tr></table></figure><p>收到响应后，XHR 对象的以下属性会被填充上数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> responseText：作为响应体返回的文本。</span><br><span class="line"> responseXML：如果响应的内容类型是&quot;text/xml&quot;或&quot;application/xml&quot;，那就是包含响应</span><br><span class="line">数据的 XML DOM 文档。</span><br><span class="line"> status：响应的 HTTP 状态。</span><br><span class="line"> statusText：响应的 HTTP 状态描述。</span><br></pre></td></tr></table></figure><h2 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h2><p>跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。 <strong>CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应 应该成功还是失败</strong>。</p><p>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text/plain 类型， 这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、 域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例：</p><blockquote><p>Origin: <a href="http://www.nczonline.net/">http://www.nczonline.net</a></p></blockquote><p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源； 或者如果资源是公开的，那么就包含”*”。比如：</p><blockquote><p>Access-Control-Allow-Origin: <a href="http://www.nczonline.net/">http://www.nczonline.net</a> </p></blockquote><p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个 请求。注意，无论请求还是响应都不会包含 cookie 信息。</p><h3 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h3><h4 id="XMLHttpRequest-对象原生支持-CORS"><a href="#XMLHttpRequest-对象原生支持-CORS" class="headerlink" title="XMLHttpRequest 对象原生支持 CORS"></a>XMLHttpRequest 对象原生支持 CORS</h4><p>在尝试访问不同源的资源时，这个行为 会被自动触发。要向不同域的源发送请求，可以使用标准 XHR对象并给 open()方法传入一个绝对 URL， 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line"> alert(xhr.responseText);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;http://www.somewhere-else.com/page/&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR 对象也施加了一些额外限制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 不能使用 setRequestHeader()设置自定义头部。</span><br><span class="line"> 不能发送和接收 cookie。</span><br><span class="line"> getAllResponseHeaders()方法始终返回空字符串。</span><br></pre></td></tr></table></figure><h4 id="图片探测"><a href="#图片探测" class="headerlink" title="图片探测"></a>图片探测</h4><p>图片探测是利用<img>标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不 必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 onload 和 onerror 事件处理程序得知何时收到响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">&quot;http://www.example.com/test?name=Nicholas&quot;</span>; </span><br></pre></td></tr></table></figure><p>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，<strong>图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容</strong>。<strong>这也是只能利用图片探测实现浏览器与服务器单向通信的 原因</strong>。</p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 格式包含两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调 函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。下面是一个典 型的 JSONP 请求：</p><blockquote><p><a href="http://freegeoip.net/json/?callback=handleResponse">http://freegeoip.net/json/?callback=handleResponse</a></p><p>这个 JSONP 请求的 URL 是一个地理位置服务。JSONP 服务通常支持以查询字符串形式指定回调函 数的名称。比如这个例子就把回调函数的名字指定为 handleResponse()。</p></blockquote><p>JSONP 调用是通过动态创建<script>元素并为 src 属性指定跨域 URL 实现的。此时的<script>与<img>元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP 响应在被加载完成之后会立即执行。比如下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"> You&#x27;re at IP address <span class="subst">$&#123;response.ip&#125;</span>, which is in</span></span><br><span class="line"><span class="string"> <span class="subst">$&#123;response.city&#125;</span>, <span class="subst">$&#123;response.region_name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild); </span><br></pre></td></tr></table></figure><p>JSONP 由于其简单易用，在开发者中非常流行。相比于图片探测，<strong>使用 JSONP 可以直接访问响应， 实现浏览器与服务器的双向通信</strong>。不过 JSONP 也有一些缺点。</p><p>首先，JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。 此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。 第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了<script>元素的 onerror 事件 处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种 方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。</p><h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法， 浏览器就会向给定 URL 发送请求。</p><h4 id="分派请求"><a href="#分派请求" class="headerlink" title="分派请求"></a>分派请求</h4><p>fetch()只有一个必需的参数 input。多数情况下，这个参数是要获取资源的 URL。这个方法返回 一个期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = fetch(<span class="string">&#x27;/bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><h4 id="读取响应"><a href="#读取响应" class="headerlink" title="读取响应"></a>读取响应</h4><p>这要用到 text()方法。这个方法返回一个 期约，会解决为取得资源的完整内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;bar.txt&#x27;</span>)</span><br><span class="line"> .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"> response.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(data);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// bar.txt 的内容</span></span><br></pre></td></tr></table></figure><h4 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h4><p>只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请 求，需要传入可选的第二个参数 init 对象.</p><h3 id="常见fetch请求模式"><a href="#常见fetch请求模式" class="headerlink" title="常见fetch请求模式"></a>常见fetch请求模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">fetch(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line"> <span class="attr">body</span>: payload,</span><br><span class="line"> <span class="attr">headers</span>: jsonHeaders</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h3 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h3><p>Headers 对象是所有外发请求和入站响应头部的容器。每个外发的 Request 实例都包含一个空的 Headers 实例，可以通过 Request.prototype.headers 访问，每个入站 Response 实例也可以通过 Response.prototype.headers 访问包含着响应头部的 Headers 对象。这两个属性都是可修改属性。 另外，使用 new Headers()也可以创建一个新实例。</p><h4 id="头部护卫"><a href="#头部护卫" class="headerlink" title="头部护卫"></a>头部护卫</h4><p>某些情况下，并非所有 HTTP 头部都可以被客户端修改，而 Headers 对象使用护卫来防止不被允 许的修改。不同的护卫设置会改变 set()、append()和 delete()的行为。</p><h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><h4 id="克隆-Request-对象"><a href="#克隆-Request-对象" class="headerlink" title="克隆 Request 对象"></a>克隆 Request 对象</h4><p>Fetch API 提供了两种不太一样的方式用于创建 Request 对象的副本：使用 Request 构造函数和使 用 clone()方法。这种克隆方式并不总能得到一模一样的副本。最明显的是，第一个请求的请求体会被标记为“已使用”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1);</span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyUsed); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.bodyUsed); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>第二种克隆 Request 对象的方式是使用 clone()方法，这个方法会创建一模一样的副本，任何值 都不会被覆盖。与第一种方式不同，这种方法不会将任何请求的请求体标记为“已使用”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> r2 = r1.clone();</span><br><span class="line"><span class="built_in">console</span>.log(r1.url); <span class="comment">// https://foo.com/</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.url); <span class="comment">// https://foo.com/</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyUsed); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(r2.bodyUsed); <span class="comment">// false </span></span><br></pre></td></tr></table></figure><p>如果请求对象的 bodyUsed 属性为 true（即请求体已被读取），那么上述任何一种方式都不能用来 创建这个对象的副本。在请求体被读取之后再克隆会导致抛出 TypeError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line">r.clone();</span><br><span class="line"><span class="keyword">new</span> Request(r);</span><br><span class="line"><span class="comment">// 没有错误</span></span><br><span class="line">r.text(); <span class="comment">// 设置 bodyUsed 为 true</span></span><br><span class="line">r.clone();</span><br><span class="line"><span class="comment">// TypeError: Failed to execute &#x27;clone&#x27; on &#x27;Request&#x27;: Request body is already used</span></span><br><span class="line"><span class="keyword">new</span> Request(r);</span><br><span class="line"><span class="comment">// TypeError: Failed to construct &#x27;Request&#x27;: Cannot construct a Request with a</span></span><br><span class="line">Request object that has already been used.</span><br></pre></td></tr></table></figure><h4 id="在-fetch-中使用-Request-对象"><a href="#在-fetch-中使用-Request-对象" class="headerlink" title="在 fetch()中使用 Request 对象"></a>在 fetch()中使用 Request 对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 向 foo.com 发送 GET 请求</span></span><br><span class="line">fetch(r);</span><br><span class="line"><span class="comment">// 向 foo.com 发送 POST 请求</span></span><br><span class="line">fetch(r, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>fetch()会在内部克隆传入的 Request 对象。与克隆 Request 一样，fetch()也不能拿请求体已 经用过的 Request 对象来发送请求.关键在于，通过 fetch 使用 Request 会将请求体标记为已使用。也就是说，有请求体的 Request 只能在一次 fetch 中使用。（不包含请求体的请求不受此限制。）演示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line">fetch(r);</span><br><span class="line">fetch(r);</span><br><span class="line"><span class="comment">// TypeError: Cannot construct a Request with a Request object that has already been used.</span></span><br></pre></td></tr></table></figure><p>要想基于包含请求体的相同 Request 对象多次调用 fetch()，必须在第一次发送 fetch()请求前 调用 clone()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">&#x27;https://foo.com&#x27;</span>,</span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: <span class="string">&#x27;foobar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 3 个都会成功</span></span><br><span class="line">fetch(r.clone());</span><br><span class="line">fetch(r.clone());</span><br><span class="line">fetch(r); </span><br></pre></td></tr></table></figure><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><p>在 JavaScript 中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP 的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务 器实现，而必须使用支持该协议的专有服务器。</p><p> 因为 Web Socket使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http://或 https://， 而要使用 ws://和 wss://。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包 含 URL 方案，因为将来有可能再支持其他方案。 </p><p>使用自定义协议而非 HTTP 协议的好处是，客户端与服务器之间可以发送非常少的数据，不会对 HTTP 造成任何负担。使用更小的数据包让 Web Socket 非常适合带宽和延迟问题比较明显的移动应用。 使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长。</p><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p>要创建一个新的 Web Socket，就要实例化一个 WebSocket 对象并传入提供连接的 URL：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>); </span><br></pre></td></tr></table></figure><p>必须给 WebSocket 构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以 打开到任意站点的连接。</p><p>浏览器会在初始化 WebSocket 对象之后立即创建连接。与 XHR 类似，WebSocket 也有一个 readyState 属性表示当前状态。不过，这个值与 XHR 中相应的值不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> WebSocket.OPENING（0）：连接正在建立。</span><br><span class="line"> WebSocket.OPEN（1）：连接已经建立。</span><br><span class="line"> WebSocket.CLOSING（2）：连接正在关闭。</span><br><span class="line"> WebSocket.CLOSE（3）：连接已经关闭。</span><br></pre></td></tr></table></figure><p>任何时候都可以调用 close()方法关闭 Web Socket 连接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close(); </span><br></pre></td></tr></table></figure><h4 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stringData = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arrayBufferData = <span class="built_in">Uint8Array</span>.from([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> blobData = <span class="keyword">new</span> Blob([<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line">socket.send(stringData);</span><br><span class="line">socket.send(arrayBufferData.buffer);</span><br><span class="line">socket.send(blobData);</span><br></pre></td></tr></table></figure><p>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。这个 message 事件与其 他消息协议类似，可以通过 event.data 属性访问到有效载荷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> data = event.data;</span><br><span class="line"> <span class="comment">// 对数据执行某些操作</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>WebSocket 对象在连接生命周期中有可能触发 3 个其他事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> open：在连接成功建立时触发。</span><br><span class="line"> error：在发生错误时触发。连接无法存续。</span><br><span class="line"> close：在连接关闭时触发。</span><br></pre></td></tr></table></figure><p>WebSocket 对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程 序来监听这些事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://www.example.com/server.php&quot;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">&quot;Connection established.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">&quot;Connection error.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/getuserinfo.php?id=23 </span><br></pre></td></tr></table></figure><p>请求这个 URL，可以假定返回 ID 为 23 的用户信息。访问者可以将 23 改为 24 或 56，甚至其他任 何值。getuserinfo.php 文件必须知道访问者是否拥有访问相应数据的权限。否则，服务器就会大门敞开， 泄露所有用户的信息。</p><p>在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（CSRF，cross-site request forgery） 攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax 应用程序，无论大小，都会受到 CSRF 攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。</p><p>关于安全防护 Ajax 相关 URL 的一般理论认为，需要验证请求发送者拥有对资源的访问权限。可以 通过如下方式实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 要求通过 SSL 访问能够被 Ajax 访问的资源。</span><br><span class="line"> 要求每个请求都发送一个按约定算法计算好的令牌（token）。</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>箭头函数定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最 后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure><p>我们不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规 ECMAScript 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。</p><p><strong>箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。</strong></p><h2 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h2><p>如果只 传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是 因为 <strong>arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的</strong>。</p><p>在使用默认参数时，<strong>arguments 对象的值不反映参数的默认值，只反映传给函数的参数</strong>。当然， 跟 ES5 严格模式一样，<strong>修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line"> name = <span class="string">&#x27;Louis&#x27;</span>;<span class="comment">//并不能修改参数中name的值</span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King undefined&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis&#x27; </span></span><br></pre></td></tr></table></figure><p><strong>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</strong></p><h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p><strong>JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中 生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义</strong>。来看 下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个 过程叫作<strong>函数声明提升</strong>（function declaration hoisting）。</p><p>如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到表达式声明的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会 出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题</p><h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的 指针。来看下面这个经典的阶乘函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不 会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial，从而导致 了紧密耦合。<strong>使用 arguments.callee 就可以让函数逻辑与函数名解耦</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>比如下面的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trueFactorial = factorial;</span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(trueFactorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure><p>这里，trueFactorial 变量被赋值为 factorial，实际上把同一个函数的指针又保存到了另一个 位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果像 factorial()最初的版本那样不 使用 arguments.callee，那么像上面这样调用 trueFactorial()就会返回 0。不过，通过将函数与 名称解耦，trueFactorial()就可以正确计算阶乘，而 factorial()则只能返回 0。</p><p>不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可 以使用命名函数表达式（named function expression）达到目的。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this，它在标准函数和箭头函数中有不同的行为。</p><p>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在 网页的全局上下文中调用函数时，this 指向 windows）。</p><p><strong>在箭头函数中，this引用的是定义箭头函数的上下文</strong>。下面的例子演示了这一点。在对sayColor() 的两次调用中，this 引用的都是 window 对象，因为这个箭头函数是在 window 上下文中定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sayColor(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">// &#x27;red&#x27; </span></span><br></pre></td></tr></table></figure><p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将 回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line"> <span class="comment">// this 引用 King 的实例</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName), <span class="number">1000</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line"> <span class="comment">// this 引用 window 对象</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> Queen(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的 构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line">King(); <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure><h2 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h2><p>ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length 和 prototype。其中，length 属性保存<strong>函数定义</strong>的命名参数的个数</p><p>函数的两个方法apply()和call().到底是 使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便。如果想直接传 arguments 对象或者一个数组，那就用 apply()；否则，就用 call()。</p><p>apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this 值的能力。使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关 心方法。如下面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">this</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.call(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">// blue </span></span><br></pre></td></tr></table></figure><p>这里，在 sayColor()上调用 bind()并传入对象 o 创建了一个新函数 objectSayColor()。 objectSayColor()中的 this 值被设置为 o，因此直接调用这个函数，即使是在全局作用域中调用， 也会返回字符串”blue”。</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>即外部函数的返回值是一个内部函数的返回值。</p><p>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">“调用栈”</a>（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line"> <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line"> <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br><span class="line">下面是几个符合尾调用优化条件的例子：</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> condition ? innerFunctionA() : innerFunctionB();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。</p><h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><p>下面是一个通过递归 计算斐波纳契数列的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">6</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实 现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部 函数执行递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> fibImpl(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibImpl</span>(<span class="params">a, b, n</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> fibImpl(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> result = compare(<span class="number">5</span>, <span class="number">10</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line"> <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。<strong>全局上下文中的叫变量对象，它 会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。</strong>在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着 会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare() 函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p><p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局 部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。图展示了以下代码执行后的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="D:\devApp\myblog\source_posts\js高级程序设计\image-20210713155036645.png" alt="闭包"></p><p>在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的 活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留 在内存中，直到匿名函数被销毁后才会被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> compareNames = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br><span class="line">compareNames = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p>这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会 解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全 局作用域之外）也可以销毁。图也展示了调用 compareNames()之后作用域链之间的关系。</p><h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><p>在闭包中使用 this 会让代码变复杂。<strong>如果内部函数没有使用箭头函数定义，则 this 对象会在运 行时绑定到执行函数的上下文</strong>。<strong>如果在全局函数中调用，则 this 在非严格模式下等于 window，在严 格模式下等于 undefined</strong>。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情 况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。 不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line"> <span class="attr">identity</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line"> <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure><p>为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？</p><p>每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永 远不可能直接访问外部函数的这两个变量。</p><h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h2><p>可以用它来模仿块级作用域,即在一个函数表达式内部声明变量，然后立即调用这个函数。这 样位于函数体作用域的变量就像是在块级作用域中一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>如下面的代码,想要实现的功能:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用立即调用的函数表达式即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的功能使用块级作用域变量更简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line"> divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="私有变量-1"><a href="#私有变量-1" class="headerlink" title="私有变量"></a>私有变量</h2><p>如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部 的变量。基于这一点，就可以创建出能够访问私有变量的公有方法。</p><p>特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有 两种方式创建特权方法。第一种是在构造函数中实现，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line"> <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 特权方法</span></span><br><span class="line"> <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> privateVariable++;</span><br><span class="line"> <span class="keyword">return</span> privateFunction();</span><br><span class="line"> &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访 问构造函数中定义的所有变量和函数的能力。在这个例子中，变量 privateVariable 和函数 privateFunction()只能通过 publicMethod()方法来访问。在创建 MyObject 的实例后，没有办法 直接访问 privateVariable 和 privateFunction()，唯一的办法是使用 publicMethod()。</p><h1 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h1><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步行为是为了优化因计算量大而 时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做 就是务实的。 重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线 程执行，那么任何时候都可以使用。</p><h3 id="以前的异步编程模式"><a href="#以前的异步编程模式" class="headerlink" title="以前的异步编程模式"></a>以前的异步编程模式</h3><p>在早期的 JavaScript 中，只支持定义回调函数 来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回 调地狱”）来解决。</p><p>假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure><p>setTimeout 可以定义一个 在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，JavaScript 运行时会把回 调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码 就完全不可见了。还有一点，double()函数在 setTimeout 成功调度异步操作之后会立即退出。</p><h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>异步函数，也称为“async/await”（语法关键字）</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭 包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。正如下面的例子所示，foo()函数仍然会 在后面的指令之前被求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2 </span></span><br></pre></td></tr></table></figure><p>不过，异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这 个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">qux().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// qux</span></span><br><span class="line"><span class="comment">//与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">//不过，拒绝期约的错误不会被异步函数捕获</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。这个行 为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这 个值传给表达式，再异步恢复异步函数的执行。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 事件流被称为事件冒泡，这是因为事件被定义为<strong>从最具体的元素（文档树中最深的节点）开始触 发，然后向上传播至没有那么具体的元素（文档）</strong>。比如有如下 HTML 页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span> </span><br></pre></td></tr></table></figure><p>在点击页面中的</p><p>元素后，click 事件会以如下顺序发生： </p><p>(1)<div></p><p>(2)body</p><p>(3)html</p><p>(4)document</p><p>也就是说,div元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一 路向上，在经过的每个节点上依次触发，直至到达 document 对象。</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>Netscape Communicator 团队提出了另一种名为事件捕获的事件流。事件捕获的意思是<strong>最不具体的节 点应该最先收到事件，而最具体的节点应该最后收到事件</strong>。事件捕获实际上是为了在事件到达最终目标 前拦截事件。如果前面的例子使用事件捕获，则点击div元素会以下列顺序触发 click 事件：</p><p>(1)document</p><p>(2)html</p><p>(3)body</p><p>(4)div</p><p>由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情 况下可以使用事件捕获。</p><h3 id="事件流-1"><a href="#事件流-1" class="headerlink" title="事件流"></a>事件流</h3><p>事件流分为 3 个阶段：<strong>事件捕获</strong>、<strong>到达目标</strong>和<strong>事件冒泡</strong>。事件捕获最先发生， 为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个 阶段响应事件。仍以前面那个简单的 HTML 为例，点击div元素后会以下图的顺序触发事件.</p><p><img src="D:\devApp\myblog\source_posts\js高级程序设计\image-20210714144401148.png" alt="事件流触发顺序"></p><p>在 DOM 事件流中，实际的目标（div元素）在捕获阶段不会接收到事件。这是因为捕获阶段从 document 到html再到body就结束了。下一阶段，即会在div元素上触发事件的“到达目标” 阶段，通常在事件处理时被认为是冒泡阶段的一部分（稍后讨论）。然后，冒泡阶段开始，事件反向传 播至文档。</p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><h4 id="DOM0事件处理程序"><a href="#DOM0事件处理程序" class="headerlink" title="DOM0事件处理程序"></a>DOM0事件处理程序</h4><p>每个元素（包括 window 和 document）都有通常小写的事件处理程序属性，比如 onclick。只要 把这个属性赋值为一个函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，<strong>事件处理程 序会在元素的作用域中运行，即 this 等于元素</strong>。下面的例子演示了使用 this 引用元素本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.id); <span class="comment">// &quot;myBtn&quot;</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>不仅仅是 id，在事件处 理程序里通过 this 可以访问元素的任何属性和方法。<strong>以这种方式添加事件处理程序是注册在事件流的冒泡阶段的</strong>。</p><h4 id="DOM2事件处理程序"><a href="#DOM2事件处理程序" class="headerlink" title="DOM2事件处理程序"></a>DOM2事件处理程序</h4><p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：<strong>addEventListener()和 removeEventListener()<strong>。这两个方法暴露在所有 DOM 节点上，</strong>它们接收 3 个参数：事件名、事件处理函 数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事 件处理程序</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><p>以上代码为按钮添加了会在事件冒泡阶段触发的 onclick 事件处理程序（因为最后一个参数值为 false）。与 DOM0 方式类似，这个事件处理程序同样在被附加到的元素的作用域中运行。使用 DOM2 方式的主要优势是可以为同一个事件添加多个事件处理程序。来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>); </span><br></pre></td></tr></table></figure><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><p>IE 实现了与 DOM 类似的方法，即 **attachEvent()和 detachEvent()**。这两个方法接收两个同样 的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 <strong>attachEvent()添加的事件处理程序会添加到冒泡阶段</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>注意，attachEvent()的第一个参数是”onclick”，而不是 DOM 的 addEventListener()方法 的”click”。</p><p>在 IE 中使用 attachEvent()与使用 DOM0 方式的主要区别是事件处理程序的作用域。使用 DOM0 方式时，事件处理程序中的 this 值等于目标元素。而使用 attachEvent()时，事件处理程序是在全 局作用域中运行的，因此 this 等于 window。</p><p>与使用 addEventListener()一样，使用 attachEvent()方法也可以给一个元素添加多个事件处 理程序。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>不过，与 DOM 方法不同，这里的事件处理程序会以添加它们的顺序反向触发。换句话说，在点击例子中的按钮 后，控制台中会先打印出”Hello world!”，然后再打印出”Clicked”。</p><p>使用 attachEvent()添加的事件处理程序将使用 detachEvent()来移除，只要提供相同的参数。 与使用 DOM 方法类似，作为事件处理程序添加的匿名函数也无法移除。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p><strong>preventDefault()方法用于阻止特定事件的默认动作</strong>。比如，链接的默认行为就是在被单击时导 航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，如下 面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLink&quot;</span>);</span><br><span class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> event.preventDefault();</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡</strong>。 例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注 册的事件处理程序执行。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Clicked&quot;</span>);</span><br><span class="line"> event.stopPropagation();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Body clicked&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>如果这个例子中不调用stopPropagation()，那么点击按钮就会打印两条消息。但这里由于click 事件不会传播到 document.body，因此 onclick 事件处理程序永远不会执行。</p><p><strong>eventPhase 属性可用于确定事件流当前所处的阶段</strong>。如果事件处理程序在捕获阶段被调用，则 eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序 在冒泡阶段被调用，则 eventPhase 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的， 但其 eventPhase 仍然等于 2。下面的例子展示了 eventPhase 在不同阶段的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 1</span></span><br><span class="line">&#125;, <span class="literal">true</span>);<span class="comment">//第三个参数为true表示定义在事件捕获阶段</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 3</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原 因有很多。<strong>首先，每个函数都是对象，都占用内存空间，对象越多，性能越差</strong>。其次，<strong>为指定事件处理 程序所需访问 DOM 的次数会先期造成整个页面交互的延迟</strong>。</p><p><strong>“过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件 处理程序来管理一种类型的事件</strong>。例如，click 事件冒泡到 document。这意味着可以为整个页面指定 一个 onclick 事件处理程序，而不用为每个可点击元素分别指定事件处理程序。</p><p>例如一个列表点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;myLinks&quot;</span>&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;goSomewhere&quot;</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt; </span><br></pre></td></tr></table></figure><p>想让每个li被点击时输出不同的内容,老的方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;goSomewhere&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;sayHi&quot;</span>);</span><br><span class="line">item1.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> location.href = <span class="string">&quot;http:// www.wrox.com&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">item2.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">document</span>.title = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">item3.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>使用事件委托:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myLinks&quot;</span>);</span><br><span class="line">list.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> target = event.target;</span><br><span class="line"> <span class="keyword">switch</span>(target.id) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>:</span><br><span class="line"> <span class="built_in">document</span>.title = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>:</span><br><span class="line"> location.href = <span class="string">&quot;http:// www.wrox.com&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>:</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>事件委托的优点:</p><p> document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded 或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。 </p><p> 节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也 可以节省时间。 </p><p> 减少整个页面所需的内存，提升整体性能。</p><h3 id="删除事件处理程序"><a href="#删除事件处理程序" class="headerlink" title="删除事件处理程序"></a>删除事件处理程序</h3><p>把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。 这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用 的事件处理程序。很多 Web 应用性能不佳都是由于无用的事件处理程序长驻内存导致的。</p><p>导致这个问题的原因主要有两个。<strong>第一个是删除带有事件处理程序的元素</strong>。比如通过真正的 DOM方法 removeChild()或 replaceChild()删除节点。最常见的还是使用 innerHTML 整体替换页面的 某一部分。这时候，被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清 理。比如下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span>&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="comment">// 执行操作</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML = <span class="string">&quot;Processing...&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="comment">// 不好！</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure><p>这里的按钮在div元素中。单击按钮，会将自己删除并替换为一条消息，以阻止双击发生。这是 很多网站上常见的做法。问题在于，按钮被删除之后仍然关联着一个事件处理程序。在div元素上设 置 innerHTML 会完全删除按钮，但事件处理程序仍然挂在按钮上面。某些浏览器，特别是 IE8 及更早 版本，在这时候就会有问题了。很有可能元素的引用和事件处理程序的引用都会残留在内存中。如果知 道某个元素会被删除，那么最好在删除它之前手工删除它的事件处理程序，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span>&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="comment">// 执行操作</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> btn.onclick = <span class="literal">null</span>; <span class="comment">// 删除事件处理程序</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"> <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML = <span class="string">&quot;Processing...&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"> &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>但也要注意，在事件处理程序中删除按钮会阻止事件冒泡。只有事件目标仍然存在于文档中时，事 件才会冒泡。( 事件委托也有助于解决这种问题。如果提前知道页面某一部分会被使用innerHTML 删除，就不要直接给该部分中的元素添加事件处理程序了。把事件处理程序添加到更高层 级的节点上同样可以处理该区域的事件。)</p><p>另一个可能导致内存中残留引用的问题是<strong>页面卸载</strong>。同样，IE8 及更早版本在这种情况下有很多问 题，不过好像所有浏览器都会受这个问题影响。如果在页面卸载后事件处理程序没有被清理，则它们仍然会残留在内存中。之后，浏览器每次加载和卸载页面（比如通过前进、后退或刷新），内存中残留对 象的数量都会增加，这是因为事件处理程序不会被回收。</p><p>一般来说，最好在 onunload 事件处理程序中趁页面尚未卸载先删除所有事件处理程序。这时候也 能体现使用事件委托的优势，因为事件处理程序很少，所以很容易记住要删除哪些。关于卸载页面时的 清理，可以记住一点：onload 事件处理程序中做了什么，最好在 onunload 事件处理程序中恢复。</p><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><h3 id="DOM事件模拟"><a href="#DOM事件模拟" class="headerlink" title="DOM事件模拟"></a>DOM事件模拟</h3><p>任何时候，都可以使用 <strong>document.createEvent()方法</strong>创建一个 event 对象。这个方法接收一个 参数，此参数是一个表示要创建事件类型的字符串。(包括UIEvents,MouseEvents,HTMLEvents)</p><p>创建 event 对象之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法， 可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用 createEvent()时传入的参数。</p><p>事件模拟的最后一步是触发事件。为此要使用 <strong>dispatchEvent()方法</strong>，这个方法存在于所有支持 事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调 用 dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。</p><p>下面举一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&quot;MouseEvents&quot;</span>); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.initMouseEvent(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, </span><br><span class="line"> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.dispatchEvent(event);</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP权威指南</title>
      <link href="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一-简述HTTP"><a href="#一-简述HTTP" class="headerlink" title="一.简述HTTP"></a>一.简述HTTP</h1><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>客户端向服务器发起请求访问资源,服务器响应时,Web服务器会为所有的Http对象数据附加一个MIME类型.如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210603221720458.png" alt="服务器响应的mine类型"></p><p>URI 统一资源标识符(URL和URN是URI的两种类型)</p><p>URL 统一资源定位符</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604113110181.png" alt="image-20210604113110181"></p><p>​    标准格式包含三部分</p><p>​        “方案://服务器位置/路径”</p><p>​        (1)方案(scheme) 说明访问资源所使用的协议类型(比如http://)</p><p>​        (2)第二部分是服务器的位置,因特网地址 (比如<a href="http://www.baidu.com/">www.baidu.com</a>)</p><p>​        (3)其余部分指定服务器上的某个资源,资源路径(比如/img.png)</p><p>URN 统一资源名</p><p>​        是作为特定内容的唯一名称使用的,与目的资源所在地无关.</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604093009602.png" alt="常用方法"></p><h2 id="客户端发起服务器返回的过程"><a href="#客户端发起服务器返回的过程" class="headerlink" title="客户端发起服务器返回的过程"></a>客户端发起服务器返回的过程</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604103916295.png" alt="发起请求并响应的过程"></p><h2 id="HTTP版本"><a href="#HTTP版本" class="headerlink" title="HTTP版本"></a>HTTP版本</h2><h3 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h3><h2 id="常见的方案"><a href="#常见的方案" class="headerlink" title="常见的方案"></a>常见的方案</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604145015386.png" alt="常见的方案1"><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604145028826.png" alt="常见的方案2"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604145028826.png" alt="常见的方案3"></p><h1 id="二-HTTP报文"><a href="#二-HTTP报文" class="headerlink" title="二.HTTP报文"></a>二.HTTP报文</h1><p>术语:</p><p>​    流入:请求报文流入源端服务器</p><p>​    流出:报文从源端服务器流出到用户Agent代理(Agent代理是所有能代替用户发送请求的应用程序,比如web浏览器)</p><p>​    上游 下游:所有的报文都会像河水一样流动,不管是请求报文还是响应报文,都会像下游流动.所有报文的发送者都在接收者的上游.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604145820623.png" alt="流入和流出"></p><h2 id="报文的格式"><a href="#报文的格式" class="headerlink" title="报文的格式"></a>报文的格式</h2><p>任何报文都由三个部分组成:<strong>起始行</strong>(请求报文称为请求行,响应报文中称为响应行),<strong>首部</strong>,和<strong>主体</strong>部分如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604150716208.png" alt="报文示例"></p><p>下面展示了请求报文和响应报文的组成,和一组假想的请求报文和响应报文作文参照</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604150429851.png" alt="请求报文格式"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604150545573.png" alt="对比"></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><strong>并不是每个服务器都实现了所有的方法,比如一台服务器要与HTTP1.1兼容,那么只要为其资源实现GET方法和HEAD方法就可以了</strong></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604151544099.png" alt="常见方法"></p><h3 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h3><p>HEAD方法在服务器响应中只返回首部,不会返回实体的主题部分,这就允许客户端在未获取实际资源的情况下,对资源的首部进行检查.比如可以:</p><pre><code>- 在不获取资源的情况下了解资源的情况(比如判断其类型)- 通过查看响应中的状态码,看看某个对象是否存在- 通过查看首部,测试资源是否被修改了</code></pre><h3 id="TRACE方法"><a href="#TRACE方法" class="headerlink" title="TRACE方法"></a>TRACE方法</h3><p>可恶端发起一个请求时,这个请求可能要穿过防火墙,代理,网关或其他一些应用程序.每个中间节点都可能会修改原始的HTTP请求.TRACE方法允许客户端在最终将请i去发送给服务器时,蓝看他办成了什么样子</p><h3 id="OPTIONS方法"><a href="#OPTIONS方法" class="headerlink" title="OPTIONS方法"></a>OPTIONS方法</h3><p>OPTIONS方法请求web服务器告知其支持的各种功能,可以询问服务器通常支持哪些方法,或者对某些特殊资源支持哪些方法.下图显示了一个使用OPTIONS方法的请求</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604160823846.png" alt="OPTIONS方法示例"></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="100-199信息性状态码"><a href="#100-199信息性状态码" class="headerlink" title="100-199信息性状态码"></a>100-199信息性状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604161531968.png" alt="1的状态码"></p><p>100 Continue目的时对这样的情况进行优化:HTTP客户端应用程序有一个尸体的主体部分想要发送给服务器,但是希望在发送之前查看一下服务器是否会接受这个实体.</p><h3 id="200-299成功状态码"><a href="#200-299成功状态码" class="headerlink" title="200-299成功状态码"></a>200-299成功状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604161727326.png" alt="2的状态码"></p><h3 id="300-399重定向状态码"><a href="#300-399重定向状态码" class="headerlink" title="300-399重定向状态码"></a>300-399重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源,要么就提供一个体态的响应而不是资源的内容.如果资源已经被移动,可以发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被一走,以及现在可以在哪里找到它,这样浏览器可以在不打扰使用者的情况下,透明的转入新的位置.如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604163648167.png" alt="重定向状态码示例"></p><p>可以通过某些重定向状态码对本地的副本进行验证,确认是否源服务端上的资源被修改过,如下请求</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604164615015.png" alt="有条件的请求示例"></p><p>从下面列出所有的重定向状态码</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604163933794.png" alt="3状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604163947803.png" alt="3状态码2"></p><h3 id="400-499客户端错误状态码"><a href="#400-499客户端错误状态码" class="headerlink" title="400-499客户端错误状态码"></a>400-499客户端错误状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604165206275.png" alt="4状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604165219898.png" alt="4状态码2"></p><h3 id="500-599状态码"><a href="#500-599状态码" class="headerlink" title="500-599状态码"></a>500-599状态码</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604165302940.png" alt="5状态码1"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604165315445.png" alt="5状态码2"></p><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><p>HTTP规范定义了几种首部字段,应用程序亦可以随意发明自己所用的首部.分为以下几类</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><p>既可以出现在请求报文中,也可以出现在响应报文中</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604190213633.png" alt="通用首部"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604190501850.png" alt="缓存首部"></p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604190610991.png" alt="请求首部"></p><h5 id="1-Accept首部"><a href="#1-Accept首部" class="headerlink" title="(1)Accept首部"></a>(1)Accept首部</h5><p>Accept首部为客户端提供了一种将其想要什么形式的内容告知服务器的方式.Accept首部会使连接的两端都收益,客户端会得到他们想要的内容,服务器就可以根据这些信息来决定发送的内容,不会浪费其时间和贷款来发送客户端无法使用的东西.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604191311768.png" alt="accept首部"></p><h5 id="2-条件请求首部"><a href="#2-条件请求首部" class="headerlink" title="(2)条件请求首部"></a>(2)条件请求首部</h5><p>有时客户端希望为其请求加上某些限制,就可以通过使用条件请求头部的方式,要求服务器在对请求进行响应之前,确保某个条件为真.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604191619053.png" alt="条件请求首部"></p><h5 id="3-安全请求首部"><a href="#3-安全请求首部" class="headerlink" title="(3)安全请求首部"></a>(3)安全请求首部</h5><p>质询/响应认证.这种机制要求客户端在获取特定的资源之前,先对自身进行认证,这样可以使事务安全一些.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604192648331.png" alt="安全请求首部"></p><h5 id="4-代理请求首部"><a href="#4-代理请求首部" class="headerlink" title="(4)代理请求首部"></a>(4)代理请求首部</h5><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604192719914.png" alt="代理请求首部"></p><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604192807882.png" alt="相应首部"></p><h5 id="1-协商首部"><a href="#1-协商首部" class="headerlink" title="(1)协商首部"></a>(1)协商首部</h5><p>如果资源有多种表示方法,比如如果服务器上有某文档的法语和德语稿,HTTP1/1.1可以为服务器和客户端提供对资源进行协商的能力.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604193018651.png" alt="协商首部"></p><h5 id="2-安全响应首部"><a href="#2-安全响应首部" class="headerlink" title="(2)安全响应首部"></a>(2)安全响应首部</h5><p>前面提到的质询/响应机制的响应侧.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604193927961.png" alt="安全响应首部"></p><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><p>描述实体的长度和内容,或者资源自身</p><p>在请求和响应报文中都可能包含实体部分,所有这两中类型的报文都可能出现这些首部</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604194155520.png" alt="实体首部"></p><h5 id="1-内容首部"><a href="#1-内容首部" class="headerlink" title="(1)内容首部"></a>(1)内容首部</h5><p>与实体内容有关的特定信息,说明了其类型尺寸以及处理它所需要的其他有用信息.比如web浏览器可以通过查看返回的内容类型,得知如何显示对象.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604194345491.png" alt="内容首部"></p><h5 id="2-实体缓存首部"><a href="#2-实体缓存首部" class="headerlink" title="(2)实体缓存首部"></a>(2)实体缓存首部</h5><p>通用的缓存首部说明了如何或什么时候进行缓存,实体的缓存首部提供了与被缓存实体有关的信息.比如验证已缓存的资源副本是否仍然有效所需的信息,以及更好的估计已缓存的资源合适失效所需的线索.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604194619183.png" alt="实体缓存首部"></p><h4 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h4><h2 id="版本0-9的报文"><a href="#版本0-9的报文" class="headerlink" title="版本0.9的报文"></a>版本0.9的报文</h2><p>版本0.9请求中只包含方法和URL,响应中只包含实体,他没有版本信息,没有状态码或原因短语也没有首部</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210604153729637.png" alt="版本0.9的报文"></p><h1 id="三-连接"><a href="#三-连接" class="headerlink" title="三.连接"></a>三.连接</h1><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210615092208139.png" alt="连接"></p><p>每个TCP段都是由IP分组承载,从一个IP地址发送到另一个IP地址的,每个IP分组中都包括:</p><ul><li>一个IP分组首部</li><li>一个TCP段首部</li><li>一个TCP数据块</li></ul><p>任何时候计算机都可以有几条tcp连接处于打开状态,tcp是通过端口来保持这些连接的正确运行的.</p><p>TCP连接是通过四个值来辨别的,&lt;源IP地址,源端口号,目的IP地址,目的端口号&gt;这四个值一起唯一定义了一条连接</p><h2 id="TCP性能"><a href="#TCP性能" class="headerlink" title="TCP性能"></a>TCP性能</h2><h3 id="HTTP事务的时延"><a href="#HTTP事务的时延" class="headerlink" title="HTTP事务的时延"></a>HTTP事务的时延</h3><p>主要有以下几种原因:</p><p>(1)客户端首先要根据url确定web服务器的ip地址.(如果最近访问过,则dns缓存可以很快的解析出来)</p><p>(2)客户端向服务器发一条tcp连接请求.每条tcp连接都会有连接建立时延</p><p>(3)连接建立起来,客户端会通过新建立的tcp管道来发送http请求,web服务器会读取请求报文并处理.因特网传输请求报文,以及服务器处理请求报文都需要时间.</p><p>(4)web服务器回送http响应报文也需要时间.</p><h3 id="性能聚焦区"><a href="#性能聚焦区" class="headerlink" title="性能聚焦区"></a>性能聚焦区</h3><p>常见的tcp相关时延如下</p><ul><li>tcp连接建立握手</li><li>tcp慢启动拥塞控制</li><li>数据聚集的Nagle算法</li><li>用于捎带确认的tcp延迟确认算法</li><li>TIME_WAIT时延和端口耗尽</li></ul><h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><p>每个段的接收者收到完好的段时都会向发送者回送小的确认分组,如果发送者没有在指定的窗口时间内收到确认信息,发送者就认为分组已经被破坏并重发数据.</p><p>由于确认报文很小,所以tcp允许在发往相同方向的输出数据分组中对其进行”捎带”.为了增加确认报文找到同向传输数据分组的可能性,很多tcp栈都实现了一种”延迟确认”算法,延迟确认算法会在一个特定的窗口时间内将输出的确认存放在缓冲区中,以寻找能够捎带它的输出数据分组,如果在那个时段内没有输出数据分组,就将确认信息放在单独的分组中传送.</p><h4 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h4><p>TCP连接会随着时间进行自我”调谐”,起初会限制连接的最大速度.如果数据成功传输,会随着时间的推移提高传输的速度.这被称为TCP慢启动,用于防止因特网的突然过载和拥塞.</p><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>TCP有一个数据流接口,应用程序可以通过它将任意尺寸的数据放入TCP栈中,但是每个tcp段中都至少装载了40个字节的标记和首部,所以如果TCP发送了大量的包含少量数据的分组,网络的性能就会严重下降.</p><p>Nagle算法鼓励发送全尺寸的段,只有当所有其他分组都被确认后,nagle算法才允许发送非全尺寸的分组.</p><p>nagle算法会引发几种HTTP性能的问题.首先,小的HTTP报文可能无法填满一个分组,可能会因为等待那些永远不会到来的额外数据而产生时延.其次nagle算法与延迟确认之间的监护存在问题—nagle算法会阻止数据的发送,直到有确认分组抵达为止,但确认分组自身会被延迟确认算法延迟.</p><p>http应用程序常常会在自己的栈中设置参数TCP_NODELAY来禁用nagle算法.</p><h2 id="串行连接"><a href="#串行连接" class="headerlink" title="串行连接"></a>串行连接</h2><p>缺点</p><p>1tcp的性能时延会叠加起来.比如有一个包含了3个嵌入图片的web页面.如果每个事务都要一条新的连接,那么连接时延和慢启动时延就会叠加起来.而且加载一幅图片时,页面上其他地方没有动静也会让人觉得速度很慢.</p><p>2有些浏览器再对象加载完毕前无法获知对象的尺寸,无法决定将对象放在什么位置,所以在加载了足够多的对象之前,无法再屏幕上显示任何内容.用户面对的是一个空白的屏幕.</p><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210615135947172.png" alt="并行连接"></p><p>如上图所示即为并行连接请求和响应的过程.</p><p>即使并行连接的速度可能会更快,但是不一定总是更快.客户端的网络带宽不足时,一个连接到速度较快的服务器上的HTTP事务就会很容易地耗尽所有可用的带宽.如果并行加载多个对象,每个对象都去竞争这有限的带宽,每个对象都会以较慢的速度按比例加载,这样带来的性能提升就非常小</p><p>而且打开大量连接会消耗很多内存资源,从而引发自身性能的问题.一百个用户同时发出申请,每个用户打开一百个连接,服务器就要负责处理10000个连接,这会造成服务器性能严重下降.</p><p>实际上,浏览器确实使用了并行连接,但是会将连接的总数限制为一个较小的值.</p><p>缺点:</p><ul><li>每个事务都会打开一条新的连接,会耗费时间和带宽</li><li>由于tcp慢启动的特性,每条连接的性能都会有所降低</li><li>可打开的并行连接数量实际上是有限的</li></ul><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><blockquote><p>TCP慢启动</p><p>TCP数据传输会随着时间进行自我调谐,起初会限制连接的最大速度,如果数据成功传输,会随着时间的推移提高传输的速度.这种调谐被成为TCP慢启动,用于防止因特网的突然过载和拥塞.所以新连接的传输速度会比已经交换过一定量数据的连接慢一些.</p></blockquote><p>在事务处理结束之后仍然保持在打开状态的TCP连接被称为持久连接.重用已对目标服务器打开的空闲持久连接,就可以避开缓慢的连接建立阶段.而且已经打开的连接还可以避免慢启动的拥塞适应阶段,以便更酷爱的进行数据的传输.</p><h3 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+keep-alive连接"></a>HTTP/1.0+keep-alive连接</h3><p>实现HTTP/1.0 keep-alive连接的客户端可以通过包含Connection:Keep-alive首部请求将一条连接保持在打开状态.</p><p>如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。</p><h4 id="Keep-Alive选项"><a href="#Keep-Alive选项" class="headerlink" title="Keep-Alive选项"></a>Keep-Alive选项</h4><p>可以用Keep-Alive通用首部中指定的,由都好分割的选项来调节keep-alive的行为.</p><ul><li>参数timeout是在Keep-Alive响应首部发送的,他估计了服务器希望将连接保持在活跃状态的时间,这并不是一个承诺值</li><li>参数max是在Keep-Alive响应首部发送的,他估计了服务器还希望为多少个事务保持此连接的活跃状态,不是承诺值</li></ul><p>Keep-Alive首部完全是可选的，但只有在提供Connection: Keep-Alive时才能使用它。这里有个Keep-Alive响应首部的例子，这个例子说明服务器最多还会为另外5个事务保持连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection: Keep-Alive</span><br><span class="line">Keep-Alive: max=5, timeout=120</span><br></pre></td></tr></table></figure><h4 id="Keep-Alive和哑代理"><a href="#Keep-Alive和哑代理" class="headerlink" title="Keep-Alive和哑代理"></a>Keep-Alive和哑代理</h4><p>1Connetion首部和盲中继</p><p>问题出现在代理上,尤其是那些不理解Connection首部,而且不知道在沿着转发链路将其发送出去之前,应该将该首部删除的代理.下图显示了这种情形</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210903144209726.png" alt="image-20210903144209726"></p><p>上图中哑代理收到了这条HTTP请求,但是不理解Connection首部,因此原封不动的发给服务器.但是Connection首部是个逐跳首部,只适用于单条传输链路.服务器收到带有Connection:Keep-Alive首部的请求,会以为代理希望进行持久连接,回送了Connection首部,所以此时服务器认为他在与代理进行keep-alive对话,然而代理却一无所知.代理将收到的所有数据返回给客户端,然后等待源服务器管理连接,但是源服务器认为会和代理进行keep-alive对话,不回去关闭连接,这样,代理就会挂在哪里等待连接的关闭,客户端看到后会认为代理同意进行keep-alive对话,会向代理发送另一条请求,而代理不认为同一条连接上会有其他请求到来就会忽略.</p><p>这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时并将其关闭为止.</p><p>为避免此类代理通信问题的发生，现代的代理都绝不能转发connection首部和所有名字出现在Connection值中的首部。因此，如果一个代理收到了一个Connection: Keep-Alive首部，是不应该转发connection首部，或所有名为Keep-Alive的首部的。</p><h3 id="HTTP-1-1持久连接"><a href="#HTTP-1-1持久连接" class="headerlink" title="HTTP/1.1持久连接"></a>HTTP/1.1持久连接</h3><p>与HTTP/1.0的keep-alive连接不同,HTTP/1.1持久连接在默认情况下是激活的,除非特别指明,否则HTTP/1.1假定所有链接都是持久的.</p><p>HTTP/1.1客户端假定在收到响应后，除非响应中包含了Connection: close首部，不然HTTP/1.1连接就仍维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 connection: close并不意味着服务器承诺永远将连接保持在打开状态。</p><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用请求管道。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间,提高性能。</p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><h1 id="四-代理"><a href="#四-代理" class="headerlink" title="四.代理"></a>四.代理</h1><p>Web代理(proxy)服务器是网络的中间实体,位于客户端和服务器之间,扮演”中间人的角色,在各端点之间来回传送HTTP报文”</p><h2 id="私有和共享代理"><a href="#私有和共享代理" class="headerlink" title="私有和共享代理"></a>私有和共享代理</h2><p>代理服务器可以是某个客户端专用的,也可以是很多客户端共享的.单个客户端专用的代理被称为私有代理.众多客户端共享的代理被称为公共代理.</p><h2 id="代理和网关的对比"><a href="#代理和网关的对比" class="headerlink" title="代理和网关的对比"></a>代理和网关的对比</h2><p>代理连接的是两个或多个是同<strong>相同协议的应用程序</strong>,而网关连接的是两个或多个使用<strong>不同协议的端点</strong>.网关扮演的是”协议转换器”的角色,即使客户端和服务器使用的是不同的协议,客户端也可以通过它完成与服务器之间的事务处理.如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210617160127706.png" alt="代理和网关的对比"></p><p>实际上,代理和网关之间的区别很模糊.由于浏览器和服务器实现的是不同版本的HTTTP,代理也经常要做一些协议转换工作.而商业化的代理服务器也会实现网关的功能来支持SSL安全协议,SICKS防火墙,FTP访问等.</p><h2 id="为什么使用代理"><a href="#为什么使用代理" class="headerlink" title="为什么使用代理"></a>为什么使用代理</h2><p>代理服务器可以实现各种时髦且有用的功能。它们可以改善安全性，提高性能，节省费用。代理服务器可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的增值Web服务。</p><ul><li>儿童过滤器</li><li></li></ul><h2 id="代理URI与服务器URI的不同"><a href="#代理URI与服务器URI的不同" class="headerlink" title="代理URI与服务器URI的不同"></a>代理URI与服务器URI的不同</h2><p>客户端向服务器和代理发送请求时,HTTP报文中的URI有所不同,除了这一点,服务器报文和代理报文语法是一样的.</p><p>客户端向web服务器发送请求时,请求行中只包含部分URI(没有方案,主机或者端口),如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618115151160.png" alt="向服务器发送请求示例"></p><p>但是向代理发送请求时,请求行中则包含完整的URI,如下</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618115240995.png" alt="向代理发送请求示例"></p><h2 id="URI的客户端自动扩展和主机名解析"><a href="#URI的客户端自动扩展和主机名解析" class="headerlink" title="URI的客户端自动扩展和主机名解析"></a>URI的客户端自动扩展和主机名解析</h2><h3 id="没有代理时URI的解析"><a href="#没有代理时URI的解析" class="headerlink" title="没有代理时URI的解析"></a>没有代理时URI的解析</h3><p>在没有代理的情况下,浏览器进行主机名自动扩展,如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618134700422.png" alt="没有代理时URI的解析"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618134737985.png" alt="没有代理时URI的解析过程"></p><h3 id="有显示代理时URI的解析"><a href="#有显示代理时URI的解析" class="headerlink" title="有显示代理时URI的解析"></a>有显示代理时URI的解析</h3><p>使用显示代理时,用户的URI会被直接发送给代理,所以浏览器就不再执行所有的便捷的扩展功能了.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618134948486.png" alt="有显示代理时URI的解析"></p><h2 id="Via首部字段"><a href="#Via首部字段" class="headerlink" title="Via首部字段"></a>Via首部字段</h2><p>Via首部字段用于记录报文的转发,诊断报文循环,标识请求/响应链上所有发送者的协议能力.</p><p>代理也可以使用Via首部来检测网络中的路由循环.代理应该在发送一条请求之前,在ia首部插入一个与其自身有关的独特字符串,并在输入的请求中查找这个字符串,以检测网络中是否存在路由循环.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618135630181.png" alt="Via示例"></p><p>代理也可以为使用非HTTP协议的服务器提供网关的功能.Via首部记录了这些协议转换.这时Via字段中协议的版本号之前必须加上协议的类型(如果是HTTP协议则可加可不加)如下图</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618142058586.png" alt="代理网关示例"></p><p>可以使用Max-Forwards首部来限制请求报文经过代理转发的跳数.</p><h2 id="代理认证"><a href="#代理认证" class="headerlink" title="代理认证"></a>代理认证</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618144545665.png" alt="代理认证"></p><h1 id="五-缓存"><a href="#五-缓存" class="headerlink" title="五.缓存"></a>五.缓存</h1><h2 id="缓存优点"><a href="#缓存优点" class="headerlink" title="缓存优点"></a>缓存优点</h2><ul><li>减少了冗余的数据传输,节省了网络费用</li><li>缓解了网络瓶颈的问题,不需要更多的带宽就能更快的加载页面</li><li>降低了对原始服务器的要求,服务器可以更快的响应,避免了过载的出现</li><li>降低了距离时延,因为从较远的地方加载页面会更慢一些</li></ul><h2 id="命中和未命中"><a href="#命中和未命中" class="headerlink" title="命中和未命中"></a>命中和未命中</h2><p>缓存命中:可以用已有的副本为某些到达缓存的请求提供服务.</p><p>缓存未命中:一些到达缓存的请求可能会由于没有副本可用,而被转发给原始服务器,</p><p>再验证:原始服务器的内容可能会发生变化,缓存要不时对其进行检测,看看它们保存的副本是否仍是服务器上的最新版本.这些新鲜度检测称为HTTP再验证.</p><p>验证再命中:缓存对缓存的副本进行再验证时,会向原始服务器发送一个小的在验证请求,如果内容没有变化,服务器会以一个小的304 Not Modified进行响应,缓存知道副本仍然有效.,就会再次将副本标识为暂时新鲜的,并将副本提供给客户端,这被称为再验证命中,或者缓慢命中.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210618161151295.png" alt="命中示例"></p><p>再验证的工具最常用的就是If-Modified-Since首部,将这个首部添加到get请求中,就可以告诉服务器,只有在缓存了对象的副本之后,又对其进行了修改的情况下,才发送此对象.</p><h3 id="区分命中和未命中的情况"><a href="#区分命中和未命中的情况" class="headerlink" title="区分命中和未命中的情况"></a>区分命中和未命中的情况</h3><p>HTTP没有为用户提供一种手段来区分响应是缓存命中的还是访问原始服务器得到的,在这两种情况下,响应码都是200OK.</p><p>客户端可以使用Date首部,将响应中Date首部的值与当前时间进行比较,如果响应中的日期比较早,客户端就可以认为这是一条缓存的响应.</p><p>也可以通过Age首部来检测缓存的响应,通过这个首部可以分辨出这条响应的使用期.</p><h2 id="缓存处理过程"><a href="#缓存处理过程" class="headerlink" title="缓存处理过程"></a>缓存处理过程</h2><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621141546286.png" alt="缓存处理过程"></p><h2 id="新鲜度检测"><a href="#新鲜度检测" class="headerlink" title="新鲜度检测"></a>新鲜度检测</h2><p>HTTP有一些简单的机制可以在不要求服务器记住哪些缓存拥有其文档副本的情况下,保持已缓存数据与服务器数据之间充分一致.HTTP将这些简单的机制称为文档过期和服务器再验证.</p><h3 id="文档过期-强缓存"><a href="#文档过期-强缓存" class="headerlink" title="文档过期(强缓存)"></a>文档过期(强缓存)</h3><p>通过特殊的HTTP Cache-Control首部和Expires首部,HTTP让原始服务器向每个文档附加了一个’过期日期’(如下图).</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621142527681.png" alt="Cache-Control首部和Expires首部"></p><h3 id="服务器再验证"><a href="#服务器再验证" class="headerlink" title="服务器再验证"></a>服务器再验证</h3><p>已缓存的文档过期并不意味着它和服务器上的文档有实际的区别,这只是意味着到了要进行核对的时间了,这种情况被称为’服务器再验证’,说明缓存需要询问原始服务器文档是否发生了变化.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621143021847.png" alt="再验证过程"></p><h3 id="条件方法再验证-协商缓存"><a href="#条件方法再验证-协商缓存" class="headerlink" title="条件方法再验证(协商缓存)"></a>条件方法再验证(协商缓存)</h3><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621143234576.png" alt="条件再验证首部"></p><h4 id="If-Modified-Since日期再验证"><a href="#If-Modified-Since日期再验证" class="headerlink" title="If-Modified-Since日期再验证"></a>If-Modified-Since日期再验证</h4><p>If-Modified-Since首部(一般称为IMS)可以与Last-Modified服务器响应首部配合工作.如下图为一个工作流程示例.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621143632010.png" alt="If-Modified-Since示例"></p><h4 id="If-None-Match实体标签再验证"><a href="#If-None-Match实体标签再验证" class="headerlink" title="If-None-Match实体标签再验证"></a>If-None-Match实体标签再验证</h4><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210621144119753.png" alt="If-None-Match"></p><p>如果服务器回送了实体标签ETag,HTTP/1.1客户端就必须使用实体标签验证器.如果HTTP/1.1缓存或者服务器收到的请求既带有If-Modified-Since又带有实体标签条件首部,那么只有这两个条件都满足时,才能返回304Not Modified响应.</p><h2 id="控制缓存的能力"><a href="#控制缓存的能力" class="headerlink" title="控制缓存的能力"></a>控制缓存的能力</h2><p>服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间,按照优先级递减的顺序,服务区可以:</p><ul><li>附加一个Cache-Control : no-store首部到响应中去;</li><li>附加一个cache-Control : no-cache首部到响应中去,</li><li>附加一个cache-Control : must-revalidate首部到响应中去;</li><li>附加一个cache-Control : max-age首部到响应中去;</li><li>附加一个 Expires日期首部到响应中去;</li><li>不附加过期信息,让缓存确定自己的过期日期。</li></ul><h3 id="no-Store和no-Cache响应首部"><a href="#no-Store和no-Cache响应首部" class="headerlink" title="no-Store和no-Cache响应首部"></a>no-Store和no-Cache响应首部</h3><p>no-store首部和no-cache首部可以<strong>防止缓存提供未经证实的已缓存对象</strong>:</p><p>标识为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样,向客户端转发一条no-store响应,然后删除对象。</p><p>标识为no-cache的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用do-not-serve-from-cache-without-revalidation这个名字会更恰当一些。(即协商缓存)</p><h1 id="客户端识别与cookie机制"><a href="#客户端识别与cookie机制" class="headerlink" title="客户端识别与cookie机制"></a>客户端识别与cookie机制</h1><p>HTTP并不是天生就具有丰富的识别特性的,下面讨论几种用户识别机制.</p><h2 id="HTTP首部-1"><a href="#HTTP首部-1" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><p>下图中给出了七种最常见的用来承载用户相关信息的HTTP请求首部</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/image-20210910162816606.png" alt="image-20210910162816606"></p><p>From首部包含了用户的E-mail地址,但是由于担心那些不讲武德的服务器会搜集这些E-mail地址用于辣鸡邮件的散发,所以很少有浏览器会发送From首部.</p><p>User-Agent首部可以将用户所用浏览器相关信息告知服务器,包括程序的名称和版本,通常还包括操作系统的相关信息.要实现定制内容与特定的浏览器及其属性间的良好交互操作时,这个首部很有用.</p><p>Referer首部提供了用户来源页面的URL.Referer首部自身并不能完全识别用户,但它可以说明用户之前访问过哪个页面,从而直到用户的行为和兴趣.</p><p>这三种首部都不足以实现可靠的识别</p><h2 id="客户端IP地址"><a href="#客户端IP地址" class="headerlink" title="客户端IP地址"></a>客户端IP地址</h2><p>通常在HTTP首部并不提供客户端的IP地址,但web服务器可以找到承载HTTP请求的TCP连接另一端的IP地址.</p><p>但是客户端IP地址来识别用户存在着很多缺点,限制了将其作为用户识别技术的效能.</p><ul><li>客户端IP地址描述的是机器,不是用户,如果几个用户共享一台计算机就无法区分.</li></ul><h2 id="胖URL"><a href="#胖URL" class="headerlink" title="胖URL"></a>胖URL</h2><p>有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。通常，会对真正的 URL进行扩展，在 URL路径开始或结束的地方添加一些状态信息。用户浏览站点时，Web服务器会动态生成一些超链，继续维护URL中的状态信息。改动后<strong>包含了用户状态信息的URL被称为胖URL</strong> (fat URL)。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="cookie的类型"><a href="#cookie的类型" class="headerlink" title="cookie的类型"></a>cookie的类型</h3><p>会话cookie和持久cookie.会话cookie是一种临时cookie,它记录了用户访问站点时的设置和偏好,用户退出浏览器时,会话cookie就被删除了.持久cookie的生存时间更长一些,它们存储在硬盘上,浏览器退出,计算机重启时他们仍然存在,通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名.</p><p>会话cookie和持久cookie的唯一区别就是过期时间.如果设置了Discard参数,或者没有设置Expires或Max-Age参数来说明扩展的过期时间,这个cookie就是一个会话cookie.</p><h3 id="cookie罐-客户端的状态"><a href="#cookie罐-客户端的状态" class="headerlink" title="cookie罐:客户端的状态"></a>cookie罐:客户端的状态</h3><p>cookie的基本思想就是让<strong>浏览器</strong>积累一组服务器特有的信息,每次访问服务器时都将这些信息提供给他.</p><h4 id="不同站点使用不同的cookie"><a href="#不同站点使用不同的cookie" class="headerlink" title="不同站点使用不同的cookie"></a>不同站点使用不同的cookie</h4><h5 id="cookie的域属性"><a href="#cookie的域属性" class="headerlink" title="cookie的域属性"></a>cookie的域属性</h5><p>产生cookie的服务器可以向Set-Cookie响应首部添加一个Domain属性来控制哪些站点可以看到哪个cookie,比如下面的示例就是在告诉浏览器将cookie user=”mary17”发送给域”.air……..com”中的所有站点.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: user= &quot;mary17&quot; ; domain=&quot;airtravelbargains.com&quot;</span><br></pre></td></tr></table></figure><p>如果用户访问的是<a href="http://www.airtravelbargains.com、specials.airtravelbargains.com或任意以.airtravelbargains.com结尾的站点,cookie/">www.airtravelbargains.com、specials.airtravelbargains.com或任意以.airtravelbargains.com结尾的站点，Cookie</a>: user=”mary17”首部都会被发布出去</p><h5 id="cookie的路径属性"><a href="#cookie的路径属性" class="headerlink" title="cookie的路径属性"></a>cookie的路径属性</h5><p>cookie规范甚至允许用户将cookie与部分Web站点关联起来。可以通过Path属性来实现这一功能，在这个属性列出的URL路径前缀下所有cookie都是有效的。例如，某个 Web服务器可能是由两个组织共享的，每个组织都有独立的cookie。站点<a href="http://www.airtravelbargains.com可能会将部分web站点用于汽车租赁——比如,http//www.airtravelbargains.com/autosl%E2%80%94%E2%80%94%E7%94%A8%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84cookie%E6%9D%A5%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E5%96%9C%E6%AC%A2%E7%9A%84%E6%B1%BD%E8%BD%A6%E5%B0%BA%E5%AF%B8%E3%80%82%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B1%BD%E8%BD%A6%E7%A7%9F%E8%B5%81cookie">www.airtravelbargains.com可能会将部分Web站点用于汽车租赁——比如,http://www.airtravelbargains.com/autosl——用一个独立的cookie来记录用户喜欢的汽车尺寸。可能会生成一个如下所示的特殊汽车租赁cookie</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: pref=compact; domain=&quot;airtravelbargains.com&quot; ; path=/autos/</span><br></pre></td></tr></table></figure><p>只有用户访问/auto/**才会返回Cookie:pref=compact这个首部</p><h3 id="cookies1版本相对于cookies0版本改动"><a href="#cookies1版本相对于cookies0版本改动" class="headerlink" title="cookies1版本相对于cookies0版本改动"></a>cookies1版本相对于cookies0版本改动</h3><ul><li>为每个cookie关联上解释性文本，对其目的进行解释。</li><li>允许在浏览器退出时,不考虑过期时间，将cookie强制销毁。用相对秒数,而不是绝对日期来表示cookie 的 Max-Age.</li><li>通过URL端口号，而不仅仅是域和路径来控制cookie的能力。</li><li>通过cookie首部回送域、端口和路径过滤器（如果有的话)。</li><li>为实现互操作性使用的版本号。</li><li>在cookie首部从名字中区分出附加关键字的$前缀。</li></ul><h1 id="安全HTTP"><a href="#安全HTTP" class="headerlink" title="安全HTTP"></a>安全HTTP</h1><p>使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在 HTTP下面提供了一个传输级的密码安全层如图.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210913105201844.png" alt="image-20210913105201844"></p><h2 id="数字加密"><a href="#数字加密" class="headerlink" title="数字加密"></a>数字加密</h2><p>给定一段明文报文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C。通过解码函数D和解码密钥d，可以将密文C解码为原始的明文P。当然，编/解码函数都是互为反函数的，对P的编码进行解码就会回到原始报文P上去。如图所示.</p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210913132532722.png" alt="image-20210913132532722"></p><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210913132744651.png" alt="image-20210913132744651"></p><h2 id="对称密钥加密技术"><a href="#对称密钥加密技术" class="headerlink" title="对称密钥加密技术"></a>对称密钥加密技术</h2><p>对称密钥(symmetric-key)加密技术，这是因为它们在<strong>编码时使用的密钥值和解码时一样</strong>(e=d)。我们就将其统称为密钥k。</p><p>对称密钥加密技术得缺点之一就是发送者和接收者在互相对话之前,一定要有一个共享的保密密钥.</p><p>比如 Alice (A)、Bob (B)和 Chris (C）都想与Joe的五金商店(J)对话。A、B和C都要建立自己与J之间的保密密钥。A可能需要密钥K^，B可能需要密钥KB,C可能需要密钥K“。每对通信实体都需要自己的私有密钥。如果有N个节点,每个节点都要和其他所有N-1个节点进行安全对话，总共大概会有N个保密密钥:这将是一个管理噩梦。</p><h2 id="公开密钥加密技术"><a href="#公开密钥加密技术" class="headerlink" title="公开密钥加密技术"></a>公开密钥加密技术</h2><p>公开密钥加密技术没有为每对主机使用单独的加密/解密密钥，而是使用了两个非对称密钥:一个用来对主机报文编码，另一个用来对主机报文解码。编码密钥是众所周知的（这也是公开密钥加密这个名字的由来)，但只有主机才知道私有的解密密钥。这样，每个人都能找到某个特定主机的公开密钥，密钥的建立变得更加简单。但解码密钥是保密的，因此只有接收端才能对发送给它的报文进行解码。</p><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>任何人只要知道了其公开密钥,就可以向一台公共服务器发送安全报文，所以非对称的公开密钥加密系统是很好用的。两个节点无须为了进行安全的通信而先交换私有密钥。</p><p>但公开密钥加密算法的计算可能会很慢。实际上它混合使用了对称和非对称策略。比如，比较常见的做法是<strong>在两节点间通过便捷的公开密钥加密技术建立起安全通信,然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密</strong>。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>除了加/解密报文之外，还可以用加密系统对报文进行签名(sign)，以<strong>说明是谁编写的报文，同时证明报文未被篡改过</strong>。这种技术被称为数字签名(digital signing)</p><p>数字签名通常是用非对称公开密钥技术产生的。因为只有所有者才知道其私有密钥,所以可以将作者的私有密钥当作一种“指纹”使用。下图是一个例子,说明了节点A是如何向节点B发送一条报文并对其进行签名得.</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书中包含了由某个受信任组织担保得用户或公司的相关信息.</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTPS在将HTTP报文发送给TCP之前,先将其发送给了一个安全层,对齐进行加密</p><p>请求一个客户端（比如Web浏览器）对某Web资源执行某事务时，它会去检查URL的方案。</p><ul><li>如果URL的方案为http，客户端就会打开一条到服务器端口80（默认情况下)的连接,并向其发送老的HTTP命令(参见图14-14a)。</li><li>如果URL的方案为https，客户端就会打开一条到服务器端口443（默认情况下)的连接，然后<strong>与服务器“SSL握手”，以二进制格式与服务器交换一些SSL安全参数，附上加密的HTTP命令</strong>(参见图14-14b)。</li></ul><h3 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h3><p>在发送已加密的 HTTP报文之前，客户端和服务器要进行一次SSL 握手，在这个握手过程中,它们要完成以下工作,过程如图</p><ul><li>交换协议版本号;</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证;</li><li>生成临时的会话密钥，以便加密信道。</li></ul><p><img src="/2021/06/03/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/devApp\myblog\source_posts\HTTP权威指南\image-20210913143410655.png" alt="image-20210913143410655"></p><h3 id="为什么不一直使用HTTPS"><a href="#为什么不一直使用HTTPS" class="headerlink" title="为什么不一直使用HTTPS"></a>为什么不一直使用HTTPS</h3><p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平 摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息 等敏感数据时，才利用 HTTPS 加密通信。</p><p>除此之外，想要节约购买证书的开销也是原因之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2021/05/07/js%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/05/07/js%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="bind函数实现"><a href="#bind函数实现" class="headerlink" title="bind函数实现"></a>bind函数实现</h1><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><p>首先第一个功能在于传入的第一个参数改变this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回了一个函数</span></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo); </span><br><span class="line"></span><br><span class="line">bindFoo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟传入第一个参数改变this指向</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">newThis</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> self.apply(newThis)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line">bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind2函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.habit);</span><br><span class="line"><span class="built_in">console</span>.log(obj.friend);</span><br><span class="line"><span class="comment">// shopping</span></span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h2><p>pending 等待(比如网络请求需要一定的时间,这个过程为等待)</p><p>fulfill 完成(回调resolve函数)</p><p>reject 拒绝(回调reject函数)</p><p>一般情况下是在有异步操作时,使用Promise对异步操作进行封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//成功时回调resolve</span></span><br><span class="line">        resolve(<span class="string">&#x27;学习promise&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//失败时回调reject</span></span><br><span class="line">        <span class="comment">// reject(&#x27;学习promise&#x27;)</span></span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>new Promise需要传入两个参数,一个为resolve,另一个为reject,这两个都是函数.</p><p>每个promise和下面的then都是一对,只有promise中resole或reject了(即promise的状态不是pedding),then中的回调函数才会执行</p><p>如果里面返回的对象有then方法,则也会自动封装成一个promise对象</p><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>catch会处理前面没有在then里处理的错误</p><h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;请求1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;18&#x27;</span>&#125;)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(&#123;<span class="attr">name</span>:<span class="string">&#x27;请求2&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;)</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只有当promise.all中的所有promise都完成后才会执行then.其中then中的res是一个数组,是每个请求的结果.</p><p>如果其中有一个promise返回的是reject状态切没有被处理,则整个Promise.all返回的就是失败状态.如果传入的promise自己有处理失败的操作,则返回</p><h2 id="Promise-Settled"><a href="#Promise-Settled" class="headerlink" title="Promise.Settled"></a>Promise.Settled</h2><p>传入一个promise数组,返回的是所有promise返回的结果的数组,不管是否成功.因此Promise.Settled返回的结果永远是成功</p><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>传入的promise数组中谁先返回结果就返回谁</p><h2 id="使用map实现promise队列"><a href="#使用map实现promise队列" class="headerlink" title="使用map实现promise队列"></a>使用map实现promise队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       let a = [1, 3, 4, 5, 6]</span><br><span class="line">       let promise = Promise.resolve()</span><br><span class="line">       a.map(num =&gt; &#123;</span><br><span class="line">           promise = promise.then(value =&gt; &#123;</span><br><span class="line">               return new Promise(resolve =&gt; &#123;</span><br><span class="line">                   setTimeout(() =&gt; &#123;</span><br><span class="line">                       console.log(num);</span><br><span class="line">                       resolve()</span><br><span class="line">                   &#125;, 1000);</span><br><span class="line">               &#125;)</span><br><span class="line"></span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">//每隔一秒输出</span><br></pre></td></tr></table></figure><pre><code>    let a = [1, 3, 4, 5, 6]    let promise = Promise.resolve()    a.map(num =&gt; &#123;        promise.then(value =&gt; &#123;            return new Promise(resolve =&gt; &#123;                setTimeout(() =&gt; &#123;                    console.log(num);                    resolve()                &#125;, 1000);            &#125;)        &#125;)    &#125;)//一秒后一起输出</code></pre><h2 id="async与await语法糖"><a href="#async与await语法糖" class="headerlink" title="async与await语法糖"></a>async与await语法糖</h2><h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">that.status = <span class="string">&#x27;pending&#x27;</span><span class="comment">//三种状态,初始为pending状态</span></span><br><span class="line">that.data = <span class="literal">undefined</span><span class="comment">//给promise对象指定一个用于存储结果数据的属性</span></span><br><span class="line">that.callbacks = []<span class="comment">//每个元素的结构:&#123;onResolved()&#123;&#125;,onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//因为状态只能又pending-&gt;resolved或者由pending-&gt;rejected</span></span><br><span class="line"><span class="comment">//所以要判断状态,当多次调用resolve时,直接返回</span></span><br><span class="line"><span class="keyword">if</span>(that.status!==<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为resolved</span></span><br><span class="line">that.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="comment">//保存value数据</span></span><br><span class="line">that.data = value</span><br><span class="line"><span class="comment">//如果有待执行的callback函数,立即异步执行回调</span></span><br><span class="line"><span class="keyword">if</span>(that.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//放入队列里执行所有成功的回调</span></span><br><span class="line"><span class="comment">//加上setTimeout是为了使里面的代码异步执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">that.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span>=&gt;</span>&#123;</span><br><span class="line">callbacksObj.onResolved(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="comment">//因为状态只能又pending-&gt;resolved或者由pending-&gt;rejected</span></span><br><span class="line"><span class="comment">//所以要判断状态,当多次调用reject时,直接返回</span></span><br><span class="line"><span class="keyword">if</span>(that.status!==<span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为rejected</span></span><br><span class="line">that.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="comment">//保存value数据</span></span><br><span class="line">that.data = reason</span><br><span class="line"><span class="comment">//如果有待执行的callback函数,立即异步执行回调</span></span><br><span class="line"><span class="keyword">if</span>(that.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//放入队列里执行所有成功的回调</span></span><br><span class="line"><span class="comment">//加上setTimeout是为了使里面的代码异步执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">that.callbacks.forEach(<span class="function"><span class="params">callbacksObj</span>=&gt;</span>&#123;</span><br><span class="line">callbacksObj.onRejected(reason)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//立即同步执行excutor</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">excutor(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line"><span class="comment">//当执行器中直接抛异常时,promise对象变为reject</span></span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">onResolved</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">onRejected</span></span></span></span><br><span class="line"><span class="comment"> * 指定成功和失败的回调代码</span></span><br><span class="line"><span class="comment"> * 返回一个新的promise对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当then中的回调函数不是函数时(比如then中什么都没有写,实现then的传透传递,直接返回数据,将数据传递到下一个then中)</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">onResolved = <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> that.data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">onRejected = <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> that.data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">result,resolve,reject</span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// let result = onResolved(value)</span></span><br><span class="line"><span class="comment">//处理返回的是一个新的promise的情况</span></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设当前状态还是pending状态,将回调函数保存起来</span></span><br><span class="line"><span class="keyword">if</span>(that.status === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">that.callbacks.push(&#123;</span><br><span class="line"><span class="comment">//压入回调栈中的函数也要有可能错,和下面的一样,只不过这是加到了回调栈中,执行的时间不一样而已</span></span><br><span class="line"><span class="comment">//所以压入回调栈中的函数也是要进行捕获异常的操作</span></span><br><span class="line"><span class="attr">onResolved</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onResolved(value),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = onResolved(value)</span><br><span class="line"><span class="comment">//处理返回的是一个新的promise的情况</span></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">onRejected</span>: <span class="function"><span class="params">reaseon</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onRejected(reaseon),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = onRejected(reaseon)</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(that.status === <span class="string">&#x27;resolved&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//假设当前状态是resolved状态,异步执行成功的回调函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onResolved(that.data),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当onResolved报错时要进行相应捕获并处理(比如onResolved函数输出了未定义的变量)</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//result存储当前promise执行then后的值,并且默认返回一个成功状态promise</span></span><br><span class="line"><span class="keyword">let</span> result = onResolved(that.data)</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line"><span class="built_in">console</span>.log(result.then(resolve,reject))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="comment">//如果前一个promise的then中报错,就等于新的一个promise报错,要交给新的promise中的reject处理</span></span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(that.status === <span class="string">&#x27;rejected&#x27;</span>)&#123;</span><br><span class="line"><span class="comment">//假设当前状态是rejected状态,异步执行失败的回调函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// handle(onRejected(that.data),resolve,reject)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//result存储当前promise执行then后的值,并且默认返回一个成功状态promise</span></span><br><span class="line"><span class="keyword">let</span> result = onRejected(that.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">result.then(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reaseon</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Promise = <span class="built_in">Promise</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2021/04/30/ES6/"/>
      <url>/2021/04/30/ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，<strong>但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</strong></p><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。另外，**<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。两个作用域中的i互不影响**</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h3 id="let不存在变量提升"><a href="#let不存在变量提升" class="headerlink" title="let不存在变量提升"></a>let不存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，**变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>**。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p><strong>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。<strong>所以在<code>let</code>声明变量前，对<code>tmp</code>的进行操作的区域则为暂时性死区(TDZ)</strong></p><p><strong>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，<strong>块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</strong></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><p><strong><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。<code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</strong></p><p><strong><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</strong>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p><p>因此已经被const定义好的对象和数据,可以进行增加删除属性的操作,但是不能让其指向另一个数组.</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ES6声明变量六种方法"><a href="#ES6声明变量六种方法" class="headerlink" title="ES6声明变量六种方法"></a>ES6声明变量六种方法</h2><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">et [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><p>可以传入默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。,上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而<strong>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。</strong></p><h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><p>字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><h1 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h1><ul><li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p></li><li><p>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li><li><p>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</p><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><p>使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。如果某个字符串不够指定长度，会在头部或尾部补全。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p>第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果省略第二个参数，默认使用空格补全长度。</p><ul><li><code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>使用参数默认值时，函数不能有同名参数。</p><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p><h3 id="默认值结合解构"><a href="#默认值结合解构" class="headerlink" title="默认值结合解构"></a>默认值结合解构</h3><p>下面是另一个解构赋值默认值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<strong>函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</strong></p><p>作为练习，请问下面两种写法有什么差别？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure><h3 id="默认参数的位置"><a href="#默认参数的位置" class="headerlink" title="默认参数的位置"></a>默认参数的位置</h3><p>提供默认参数的参数最好设置在末尾,否则一些情况下会报错,比如下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure><h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这是因为<code>length</code>属性的含义是，<strong>该函数预期传入的参数个数</strong>。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入<code>length</code>属性。</p><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，<strong>参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</strong></p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p><p>如果此时，全局变量<code>x</code>不存在，就会报错。</p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p><p>如果写成下面这样，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p><p><strong>下面是一个更复杂的例子。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，该变量与第一个参数<code>x</code>由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p><p>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p><p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h2 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">...a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params">&#123;a, b&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数有几个使用注意点。</p><p>（1）箭头函数没有自己的<code>this</code>对象（详见下文）。</p><p>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，最重要的是第一点。<strong>对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。</strong>也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s1: &#x27;</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s2: &#x27;</span>, timer.s2), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p><p>箭头函数实际上可以让<code>this</code>指向固定化，绑定<code>this</code>使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="params">event</span> =&gt;</span> <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init()</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。如果回调函数是普通函数，那么运行<code>this.doSomething()</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p><p>总之，箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p><p>请问下面的代码之中，<code>this</code>的指向有几个？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>答案是<code>this</code>的指向只有一个，就是函数<code>foo</code>的<code>this</code>，这是因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。所以不管怎么嵌套，<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的<code>this</code>都指向运行时所在的不同对象。</p><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p><strong>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">globalThis.s = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">s</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.s)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.m() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>上面例子中，**<code>obj.m()</code>使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给<code>obj.m</code>，这导致箭头函数内部的<code>this</code>指向全局对象，所以<code>obj.m()</code>输出的是全局空间的<code>21</code>，而不是对象内部的<code>42</code>。上面的代码实际上等同于下面的代码。**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">globalThis.s = <span class="number">21</span>;</span><br><span class="line">globalThis.m = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">s</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">m</span>: globalThis.m</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.m() <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>由于上面这个原因，对象的属性建议使用传统的写法定义，不要用箭头函数定义。</p><p><strong>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="代替函数的apply方法"><a href="#代替函数的apply方法" class="headerlink" title="代替函数的apply方法"></a>代替函数的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p><p>ES5 只能用变通方法来复制数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p><p>扩展运算符提供了复制数组的简便写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p><h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的可枚举型和遍历"><a href="#属性的可枚举型和遍历" class="headerlink" title="属性的可枚举型和遍历"></a>属性的可枚举型和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p><strong>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性</strong>。</p><ul><li><code>for...in</code>循环：只遍历对象<strong>自身的和继承的可枚举的</strong>属性。</li><li><code>Object.keys()</code>：返回对<strong>象自身的所有可枚举的</strong>属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象<strong>自身的可枚举的</strong>属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象<strong>自身的可枚举的</strong>属性。</li></ul><p><strong>ES6 一共有 5 种方法可以遍历对象的属性。</strong></p><ul><li><strong>for…in</strong></li></ul><p><code>for...in</code>循环遍历对象<strong>自身的和继承的可枚举属性</strong>（不含 Symbol 属性）。</p><ul><li><strong>Object.keys(obj)</strong></li></ul><p><code>Object.keys</code>返回一个数组，包括<strong>对象自身的（不含继承的）所有可枚举属性</strong>（不含 Symbol 属性）的键名。</p><ul><li><strong>Object.getOwnPropertyNames(obj)</strong></li></ul><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含<strong>对象自身的所有属性</strong>（不含 Symbol 属性，但是<strong>包括不可枚举属性</strong>）的键名。</p><ul><li><strong>Object.getOwnPropertySymbols(obj)</strong></li></ul><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><ul><li><strong>Reflect.ownKeys(obj)</strong></li></ul><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，<strong>不管键名是 Symbol 或字符串，也不管是否可枚举。</strong></p><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的<strong>关键字<code>super</code>，指向当前对象的原型对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>super</code>关键字表示原型对象时，<strong>只能用在对象的方法之中</strong>，用在其他地方都会报错。</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有<strong>可遍历的（enumerable）、但尚未被读取的属性</strong>，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数，否则会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>Object.is()它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p><code>Object.assign()</code>拷贝的属性是有限制的，<strong>只拷贝源对象的自身属性（不拷贝继承属性）</strong>，<strong>也不拷贝不可枚举的属性</strong>（<code>enumerable: false</code>）。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>(1)浅拷贝</p><p><code>Object.assign()</code>方法实行的是<strong>浅拷贝</strong>，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>(2)数组的处理</p><p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><p><code>Object.keys</code>方法，返回一个数组，成员是参数对象<strong>自身的（不含继承的）所有可遍历</strong>（enumerable）属性的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<code>Object.values</code>只返回对象自身的可遍历属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><h1 id="运算符的扩展"><a href="#运算符的扩展" class="headerlink" title="运算符的扩展"></a>运算符的扩展</h1><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>新增了一个指数运算符（<code>**</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure><h2 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.querySelector(<span class="string">&#x27;input[name=foo]&#x27;</span>)?.value</span><br></pre></td></tr></table></figure><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p><h2 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h2><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText || <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p><p>新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6 引入了一种新的原始<strong>数据类型<code>Symbol</code>，表示独一无二的值。</strong></p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.toString() <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p><strong>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sym.description <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><h2 id="Symbal-for-和Symbal-keyFor"><a href="#Symbal-for-和Symbal-keyFor" class="headerlink" title="Symbal.for()和Symbal.keyFor()"></a>Symbal.for()和Symbal.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo();</span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Set的基本使用"><a href="#Set的基本使用" class="headerlink" title="Set的基本使用"></a>Set的基本使用</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的，没有重复的值</strong>。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p>可以用传入数组的方法去除数组重复成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>set中认为两个对象总是不相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set的属性"><a href="#Set的属性" class="headerlink" title="Set的属性"></a>Set的属性</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><h3 id="Set的操作方法"><a href="#Set的操作方法" class="headerlink" title="Set的操作方法"></a>Set的操作方法</h3><p>操作方法主要是用于操作数据</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="Set遍历方法"><a href="#Set遍历方法" class="headerlink" title="Set遍历方法"></a>Set遍历方法</h3><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>(1)<code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>(2)forEach()</p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，<strong>WeakSet 的成员只能是对象，而不能是其他类型的值</strong>。其次，<strong>WeakSet 中的对象都是弱引用</strong>，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。ES6 规定 <strong>WeakSet 不可遍历</strong>。</p><p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p>首先，**<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p>其次，**<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制**。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li><p>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p></li><li><p>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p></li><li><p>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p><p>典型的操作就是<code>in</code>运算符。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p></li><li><p>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p></li><li><p>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</p></li><li><p>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p></li><li><p>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p></li><li><p>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p></li><li><p>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p></li><li><p>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p></li><li><p>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p></li><li><p>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p></li><li><p>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p></li></ul><h2 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + key;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === handler);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// Hello, foo</span></span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><h2 id="与defineProperty的区别"><a href="#与defineProperty的区别" class="headerlink" title="与defineProperty的区别"></a>与defineProperty的区别</h2><ul><li><p>defineproperty只能监听某个属性不能全对象监听</p><p>defineproperty监听需要知道那个对象的那个属性，而proxy只需要知道那个对象就可以了。也就是会省去for in 循环提高了效率</p></li><li><p>vue中，Proxy在调用时递归，Object.defineProperty在一开始就全部递归，Proxy性能优于Object.defineProperty。</p></li><li><p>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。</p></li><li><p>数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。</p></li></ul><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p><h2 id="resolve函数的参数还是Promise"><a href="#resolve函数的参数还是Promise" class="headerlink" title="resolve函数的参数还是Promise"></a><code>resolve</code>函数的参数还是Promise</h2><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="built_in">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function"><span class="params">value</span>  =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p><p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [url_1, url_2, url_3];</span><br><span class="line"><span class="keyword">const</span> requests = urls.map(<span class="function"><span class="params">x</span> =&gt;</span> fetch(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p><p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p><p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。<code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">  fetch(<span class="string">&#x27;https://v8.dev/&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;https://v8.dev/blog&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;blog&#x27;</span>),</span><br><span class="line">  fetch(<span class="string">&#x27;https://v8.dev/docs&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">]).then(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;  <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(first);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><p><strong>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><p>第二种写法是使用<code>new Promise()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p><p>Iterator 的遍历过程是这样的。</p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h2><p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p><p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p><p>需要注意的是，**<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能**。</p><p>正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。</p><h2 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h2><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被<strong>当作上一个<code>yield</code>表达式的返回值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。这里需要注意，<strong>一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象</strong>，所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</p><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;内部捕获&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.throw(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p><p><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next() <span class="comment">// a</span></span><br><span class="line">g.throw() <span class="comment">// b</span></span><br><span class="line">g.next() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p><p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;throwing an exception&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;generator broke!&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;starting generator&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第三次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caller done&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(g());</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers();</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><p><strong><code>next()</code>是将<code>yield</code>表达式替换成一个值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = g(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.next(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="comment">// 手动遍历 foo()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// y</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p><p>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;x&quot;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;y&quot;</span></span><br></pre></td></tr></table></figure><p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.next().value <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.next().value <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure><p>如果不用yield*的话,第二个next返回一个字符串</p><h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">myGeneratorMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p><h2 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h2><p>Generator 函数总是返回一个遍历器，ES6 规定<strong>这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hi!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.hello() <span class="comment">// &#x27;hi!&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，<strong>如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.next();</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p><p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = F.call(obj);</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">obj.a <span class="comment">// 1</span></span><br><span class="line">obj.b <span class="comment">// 2</span></span><br><span class="line">obj.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p><p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p><p>一个办法就是将<code>obj</code>换成<code>F.prototype</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.call(F.prototype);</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="Generator的上下文"><a href="#Generator的上下文" class="headerlink" title="Generator的上下文"></a>Generator的上下文</h2><p>它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  g.next().value,</span><br><span class="line">  g.next().value,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><h1 id="Generator异步应用"><a href="#Generator异步应用" class="headerlink" title="Generator异步应用"></a>Generator异步应用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码的方法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h1><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>使用Generator函数如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p><code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">&#x27;goog&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> superagent.get(<span class="string">&#x27;http://google.com/this-throws-an-error&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的<code>prototype</code>属性上面</strong>。</p><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）.</p><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>类不存在变量提升（hoist），这一点与 ES5 的函数完全不同。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>原因:这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><ul><li>将私有方法移出类，因为类内部的所有方法都是对外可见的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。</p><ul><li>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p><h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">&#x27;张三&#x27;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><h1 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h1><p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p><p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p><p>除了私有属性，<strong>父类的所有属性和方法，都会被子类继承，其中包括静态方法</strong>。</p><h2 id="super关键字-1"><a href="#super关键字-1" class="headerlink" title="super关键字"></a>super关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><h3 id="super作为函数调用"><a href="#super作为函数调用" class="headerlink" title="super作为函数调用"></a>super作为函数调用</h3><p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="super作为对象时"><a href="#super作为对象时" class="headerlink" title="super作为对象时"></a>super作为对象时</h3><p><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><h4 id="普通方法中"><a href="#普通方法中" class="headerlink" title="普通方法中"></a>普通方法中</h4><p>在普通方法中,<code>super.p()</code>就相当于<code>A.prototype.p()</code>。这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A.prototype.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><h4 id="静态方法中"><a href="#静态方法中" class="headerlink" title="静态方法中"></a>静态方法中</h4><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><p>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x = <span class="number">3</span>;</span><br><span class="line">B.m() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，就得到了上面的结果。</p><p><strong>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</strong></p><h2 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 _ proto_ 属性"></a>实例的 _ <em>proto</em>_ 属性</h2><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p><h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。</p><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br><span class="line">a.foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure><p><strong>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，**<code>import</code>命令是编译阶段执行的，在代码运行之前**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> MyModual <span class="keyword">from</span> <span class="string">&#x27;./myModual&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p><p>如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><h2 id="import-1"><a href="#import-1" class="headerlink" title="import()"></a>import()</h2><p><code>import()</code>函数，支持动态加载模块。也就是说，什么时候运行到这一句，就会加载指定的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><p><code>import()</code>返回一个 Promise 对象。</p><p><code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...·</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">myModule</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myModule.default);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Module加载实现"><a href="#Module加载实现" class="headerlink" title="Module加载实现"></a>Module加载实现</h1><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h2 id="ES6模块加载规则"><a href="#ES6模块加载规则" class="headerlink" title="ES6模块加载规则"></a>ES6模块加载规则</h2><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p><p>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p><p>注意:</p><ul><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES6和CommonJS差异"><a href="#ES6和CommonJS差异" class="headerlink" title="ES6和CommonJS差异"></a>ES6和CommonJS差异</h2><p>它们有三个重大差异。</p><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ul><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><p>再举一个出现在<code>export</code>一节中的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。让我们看看，<code>m2.js</code>能否正确读取这个变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>最后，**<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sum += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./x&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./y&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/2021/04/16/Android/"/>
      <url>/2021/04/16/Android/</url>
      
        <content type="html"><![CDATA[<p>最近写了一个viewpaper+fragment实现底部导航的页面,记录一下</p><p>整体的效果大概是这样,通过页面下方的导航栏可以进行页面的跳转</p><p><img src="/2021/04/16/Android/devApp\blog\source\_posts\Android.assets\image-20210416134643199.png" alt="image-20210416134643199" style="zoom:50%;"><img src="/2021/04/16/Android/devApp\blog\source\_posts\Android.assets\image-20210416134737687.png" alt="image-20210416134737687" style="zoom:50%;"></p><h2 id="1导航界面"><a href="#1导航界面" class="headerlink" title="1导航界面"></a>1导航界面</h2><p>首先实现viewpaper,在activity_layout.xml中设计导航页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.zhihui.ZhihuiActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_radio_group&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;49dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;门户&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbMenhu&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbBaojing&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;报警&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbZhihui&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;智慧&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rbWode&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;11dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:drawableTop</span>=<span class="string">&quot;@drawable/mine&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:button</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;10sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#262626&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;我的&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span><span class="tag">&lt;/<span class="name">RadioButton</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.viewpager.widget.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_viewpager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/main_radio_group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">androidx.viewpager.widget.ViewPager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2viewpaper的适配器"><a href="#2viewpaper的适配器" class="headerlink" title="2viewpaper的适配器"></a>2viewpaper的适配器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragmentPaperAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PAGE_NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_MENHU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_BAOJING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_ZHIHUI = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_WODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> MenhuFragment menhuFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> BaojingFragment baojingFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ZhihuiFragment zhihuiFragment = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> WodeFragment wodeFragment = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFragmentPaperAdapter</span><span class="params">(<span class="meta">@NonNull</span> FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        menhuFragment = <span class="keyword">new</span> MenhuFragment();</span><br><span class="line">        baojingFragment = <span class="keyword">new</span> BaojingFragment();</span><br><span class="line">        zhihuiFragment = <span class="keyword">new</span> ZhihuiFragment();</span><br><span class="line">        wodeFragment = <span class="keyword">new</span> WodeFragment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">            <span class="keyword">case</span> PAGE_MENHU: &#123;</span><br><span class="line">                <span class="keyword">return</span> menhuFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_BAOJING: &#123;</span><br><span class="line">                <span class="keyword">return</span> baojingFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_ZHIHUI: &#123;</span><br><span class="line">                <span class="keyword">return</span> zhihuiFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> PAGE_WODE: &#123;</span><br><span class="line">                <span class="keyword">return</span> wodeFragment;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PAGE_NUM;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3fragment的layout文件"><a href="#3fragment的layout文件" class="headerlink" title="3fragment的layout文件"></a>3fragment的layout文件</h2><p>创建几个fragment的布局文件,我这里创建的是fragment_baojing.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;报警界面&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于四个都很类似,我就不再一一堆代码了</p><h2 id="4对fragment进行实现"><a href="#4对fragment进行实现" class="headerlink" title="4对fragment进行实现"></a>4对fragment进行实现</h2><p>创建BaojingFragment类继承Fragment类,重写onCreatView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaojingFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_baojing, container,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对自己定义的几个fragment都进行这样的实现</p><h2 id="5activity"><a href="#5activity" class="headerlink" title="5activity"></a>5activity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhihuiActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> <span class="keyword">implements</span> <span class="title">ViewPager</span>.<span class="title">OnPageChangeListener</span>, <span class="title">RadioGroup</span>.<span class="title">OnCheckedChangeListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyFragmentPaperAdapter myFragPageAdapter;</span><br><span class="line">    <span class="keyword">private</span> ViewPager viewPager;</span><br><span class="line">    <span class="keyword">private</span> RadioGroup radioGroup;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_menhu;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_baojing;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_zhihui;</span><br><span class="line">    <span class="keyword">private</span> RadioButton radioButton_wode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> PAGE_NUM = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_MENHU = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_BAOJING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_ZHIHUI = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_WODE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_zhihui);</span><br><span class="line"></span><br><span class="line">        myFragPageAdapter=<span class="keyword">new</span> MyFragmentPaperAdapter(getSupportFragmentManager());</span><br><span class="line">        bindViews();</span><br><span class="line">        radioButton_zhihui.setChecked(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindViews</span><span class="params">()</span></span>&#123;</span><br><span class="line">        radioButton_menhu=findViewById(R.id.rbMenhu);</span><br><span class="line">        radioButton_baojing=findViewById(R.id.rbBaojing);</span><br><span class="line">        radioButton_zhihui=findViewById(R.id.rbZhihui);</span><br><span class="line">        radioButton_wode=findViewById(R.id.rbWode);</span><br><span class="line"></span><br><span class="line">        radioGroup=findViewById(R.id.main_radio_group);</span><br><span class="line">        radioGroup.setOnCheckedChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        viewPager= findViewById(R.id.main_viewpager);</span><br><span class="line">        viewPager.setAdapter(myFragPageAdapter);</span><br><span class="line">        viewPager.addOnPageChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        viewPager.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (viewPager.getCurrentItem())&#123;</span><br><span class="line">                <span class="keyword">case</span> PAGE_MENHU:</span><br><span class="line">                    radioButton_menhu.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_BAOJING:</span><br><span class="line">                    radioButton_baojing.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_ZHIHUI:</span><br><span class="line">                    radioButton_zhihui.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> PAGE_WODE:</span><br><span class="line">                    radioButton_wode.setChecked(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(RadioGroup group, <span class="keyword">int</span> checkedId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (checkedId)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbMenhu:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_MENHU);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbBaojing:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_BAOJING);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbZhihui:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_ZHIHUI);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> R.id.rbWode:&#123;</span><br><span class="line">                viewPager.setCurrentItem(PAGE_WODE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p>主活动的layout</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/lv_one&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>listview的布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/lv_item&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实体类Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建adapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Bean&gt; data;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(List&lt;Bean&gt; data, Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(convertView == <span class="keyword">null</span>)&#123;</span><br><span class="line">            convertView = LayoutInflater.from(context).inflate(R.layout.lv_one,parent,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        TextView textView = convertView.findViewById(R.id.lv_item);</span><br><span class="line">        textView.setText(data.get(position).getName());</span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Bean&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Bean bean = <span class="keyword">new</span> Bean();</span><br><span class="line">            bean.setName(<span class="string">&quot;上官婉儿&quot;</span>+i);</span><br><span class="line">            data.add(bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListView listView = findViewById(R.id.lv_one);</span><br><span class="line">        listView.setAdapter(<span class="keyword">new</span> MyAdapter(data,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一行代码</title>
      <link href="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(FirstActivity.<span class="keyword">this</span>,<span class="string">&quot;您点击了这个按钮&quot;</span>,Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure><p>第一个参数：上下文</p><p>第二个参数：现实的内容</p><p>第三个参数：显示时常</p><h3 id="获取layout中的组件"><a href="#获取layout中的组件" class="headerlink" title="获取layout中的组件"></a>获取layout中的组件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.mybutton);</span><br></pre></td></tr></table></figure><p>需要事先在layout中定义id为mybutton的按钮。</p><h3 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View rootView;</span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> View button;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rootView == <span class="keyword">null</span>)&#123;</span><br><span class="line">            rootView = inflater.inflate(R.layout.fragment_blank1,container,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        textView = rootView.findViewById(R.id.tv_f1);</span><br><span class="line">        button = rootView.findViewById(R.id.b_f1);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                textView.setText(<span class="string">&quot;我一般&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rootView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fragment的layout</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.fragments.BlankFragment1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Update blank fragment layout --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_f1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/hello_blank_fragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;你好吗&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/b_f1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main的layout</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.hie.androidstudy.fragments.BlankFragment1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>fragment必须提供id,否则报错</p><h4 id="fragment动态添加"><a href="#fragment动态添加" class="headerlink" title="fragment动态添加"></a>fragment动态添加</h4><p>activity的layout</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_main2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;第二个页面&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;切换到fragment1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;切换到fragment2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/f_layout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_surface&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FrameLayout用来盛放切换的fragment</p><p>activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line"></span><br><span class="line">        Button button1 = findViewById(R.id.button1);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                replaceFragment(<span class="keyword">new</span> BlankFragment1());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Button button2 = findViewById(R.id.button2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                replaceFragment(<span class="keyword">new</span> BlankFragment2());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//切换fragment方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">        FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br><span class="line">        fragmentTransaction.replace(R.id.f_layout,fragment);</span><br><span class="line">        fragmentTransaction.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        fragmentTransaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity向fragment传参"><a href="#activity向fragment传参" class="headerlink" title="activity向fragment传参"></a>activity向fragment传参</h4><p>activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                bundle.putString(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;activity传递给的参数&quot;</span>);</span><br><span class="line">                BlankFragment1 blankFragment1= <span class="keyword">new</span> BlankFragment1();</span><br><span class="line">                blankFragment1.setArguments(bundle);</span><br><span class="line">                replaceFragment(blankFragment1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = getArguments();</span><br><span class="line">String message = bundle.getString(<span class="string">&quot;message&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示intent跳转secondActivity</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式intent</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个intent只能指定一个action，但是能指定多个category</span></span><br><span class="line">intent.addCategory(<span class="string">&quot;com.example.activitytest.MY_CATEGORY&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更多的隐式Intent</span></span><br><span class="line"><span class="comment">//打开系统自带浏览器访问百度</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;http://www.baidu.com&quot;</span>));</span><br><span class="line"><span class="comment">//拨号</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;tel:10086&quot;</span>));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>在第一层活动中使用putExtra方法将数据存在Intent中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//传递数据给下一个活动</span><br><span class="line">String data= &quot;传递的数据&quot;;</span><br><span class="line">Intent intent = new Intent(FirstActivity.this,SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;data&quot;,data);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>在第二层活动中取出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//接收上一层活动传过来的数据</span><br><span class="line">Intent intent = getIntent();//获取用于启动第二层活动的Intent</span><br><span class="line">String data = intent.getStringExtra(&quot;data&quot;);//获取第一层传入的数据</span><br><span class="line">Log.d(&quot;SecondActivity&quot;, data);</span><br></pre></td></tr></table></figure><h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>在上一层活动中使用startActivityForResult()方法来跳转到下一个活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受下一层活动传回来的数据</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line"><span class="comment">//第二个参数为requescode，用来判断是从哪个活动中传来的数据</span></span><br><span class="line">startActivityForResult(intent,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在下一层活动中传递数据到上一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递数据到上一层</span></span><br><span class="line">Button button = (Button) findViewById(R.id.mybutton2);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(<span class="string">&quot;data_return&quot;</span>,<span class="string">&quot;这是第二层向第一层传递的数据&quot;</span>);</span><br><span class="line">        <span class="comment">//第一个参数为resulcode</span></span><br><span class="line">        setResult(RESULT_OK,intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为在上一层活动中使用startActivityForResult()方法来启动到下一个活动，在下一个活动销毁时会自动调用上一个活动的onActivityResult()方法，因此需要在上一层活动中重写这个方法来获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过requestCode判断是否为第二层传入的数据</span></span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK)&#123;</span><br><span class="line">                String resultData = data.getStringExtra(<span class="string">&quot;data_return&quot;</span>);</span><br><span class="line">                Log.d(TAG, resultData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h4><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201202153001306.png" alt="image-20201202153001306" style="zoom: 33%;"><h4 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h4><p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/image-20210823132015046.png" alt="image-20210823132015046"></p><h4 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h4><p>共有四种启动模式:standard,singleTop,singleTask,</p><p>standard:默认的启动模式,当当前活动启动的任然是当前活动时,<strong>不管返回栈是否存在</strong>这个活动,每次启动都会创建该活动一个新的实例.</p><p>singleTop:在启动活动时发现返回栈的<strong>栈顶</strong>已经是该活动,则认为可以直接使用,而不会再创建新的活动.但如果此时这个活动不在栈顶,则会再创建该活动的一个新的实例.</p><p>singleTask:当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在<strong>返回栈</strong>中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并<strong>把在这个活动之上的所有活动统统出栈</strong>，如果没有发现就会创建一个新的活动实例。</p><p>singleInstance:不同于以上3种启动模式，指定为singleInstance模式的活动会<strong>启用一个新的返回栈</strong>来管理这个活动(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。那么这样做有什么意义呢?想象以下场景，假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢?使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用singleInstance模式就可以解决这个问题,<strong>在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动,都共用的同一个返回栈，也就解决了共享活动实例的问题</strong>。</p><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><p>首先在activity_main.xml中添加LIstView组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/list&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ListView&gt;</span><br></pre></td></tr></table></figure><p>然后在activity中添加数据,ListView中的数据不能直接传入,需要使用适配器传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data = &#123; <span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;watermelon&quot;</span> ,</span><br><span class="line">            <span class="string">&quot;Pear&quot;</span>,<span class="string">&quot;Grape&quot;</span>,<span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>,<span class="string">&quot;Mango&quot;</span>,<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> ,<span class="string">&quot;watermelon&quot;</span>,<span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span> , <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ArrayAdapter arrayAdapter = <span class="keyword">new</span> ArrayAdapter(MainActivity.<span class="keyword">this</span>,android.R.layout.simple_list_item_1,data);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list);</span><br><span class="line">        listView.setAdapter(arrayAdapter);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用ArrayAdapter适配器,有多种构造方法,这里共有三个参数,依次传人当前上下文、ListView子项布局的 id，以及要适配的数据。注意，我们使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。这样适配器对象就构建好了。然后调用setAdapter方法传入适配器.</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播分类:</p><p>标准广播（Normal broadcasts ）:是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</p><p>有序广播(Ordered broadcasts ):则是一种同步执行的广播，在广播发出之后，同-时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><h4 id="SharedPerferences"><a href="#SharedPerferences" class="headerlink" title="SharedPerferences"></a>SharedPerferences</h4><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201207140333584.png" alt="image-20201207140333584" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.save);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SharedPreferences.Editor editor = getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE).edit();</span><br><span class="line">        editor.putString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        editor.putInt(<span class="string">&quot;age&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        editor.apply();</span><br><span class="line">        Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;保存成功&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201207140451502.png" alt="image-20201207140451502" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button button1 = (Button) findViewById(R.id.read);</span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE);</span><br><span class="line">        String name = sharedPreferences.getString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = sharedPreferences.getInt(<span class="string">&quot;age&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;姓名是:&quot;</span>+name+<span class="string">&quot;年龄是:&quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Litepal操纵数据库"><a href="#Litepal操纵数据库" class="headerlink" title="Litepal操纵数据库"></a>Litepal操纵数据库</h4><h5 id="创建和升级数据库"><a href="#创建和升级数据库" class="headerlink" title="创建和升级数据库"></a>创建和升级数据库</h5><p>1.首先再build.gardle中引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.litepal.android:core:1.5.0&#x27;</span></span><br></pre></td></tr></table></figure><p>2.在main中新建一个assets目录,在assets目录下新建一个litepal.xml文件,内容如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">&quot;BookStore&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库版本号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于设定所有的映射模型,即你定义数据库表的类名路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">&quot;com.fx.sqlitetest.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.修改AndroidManifest.xml中的代码,让litepal的所有正常工作</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208134121215.png" alt="image-20201208134121215" style="zoom: 50%;"><p>即在application中添加android:name=”org.litepal.LitePalApplication</p><p>下面就可以使用啦</p><p>4.创建新的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fx.sqlitetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.litepal.crud.DataSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">DataSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二步的mapping中映射这个类然后进行任意数据库操作就可以自动创建相应的表和属性啦</p><p>如在主活动中使用Connector.getDatabase();</p><p>如果想要添加一个类就新建然后再mapping中设置映射,再将版本号更改成更高一级就好啦!</p><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">       Button button = (Button) findViewById(R.id.button);</span><br><span class="line">       button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">               Book book1 = new Book();</span><br><span class="line">               book1.setName(&quot;水浒传&quot;);</span><br><span class="line">               book1.setAuthor(&quot;梁朝伟&quot;);</span><br><span class="line">               book.save();</span><br><span class="line">               </span><br><span class="line">               //这是更高级一些的更新方法,即对书名字为三国演义,作者为不知道的书进行更新</span><br><span class="line">               //book1.updateAll(&quot;name = ? and author = ?&quot;,&quot;三国演义&quot;,&quot;不知道&quot;);</span><br><span class="line">               </span><br><span class="line">               List&lt;Book&gt; bookList = DataSupport.findAll(Book.class);</span><br><span class="line">               //使用循环并利用日志打印所有值</span><br><span class="line">               for (Book book : bookList) &#123;</span><br><span class="line">                   Log.d(&quot;Data&quot;, book.getName());</span><br><span class="line">                   Log.d(&quot;Data&quot;, book.getAuthor());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSupport.deleteAll(Book.class,<span class="string">&quot;name=?&quot;</span>,<span class="string">&quot;水浒传&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Book&gt; bookList = DataSupport.findAll(Book.class);</span><br><span class="line">   <span class="comment">//使用循环并利用日志打印所有值</span></span><br><span class="line">   <span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">       Log.d(<span class="string">&quot;Data&quot;</span>, book.getName());</span><br><span class="line">       Log.d(<span class="string">&quot;Data&quot;</span>, book.getAuthor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他的高级查询方式</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208135619931.png" alt="image-20201208135619931" style="zoom:50%;"><h3 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h3><h4 id="Adroid权限"><a href="#Adroid权限" class="headerlink" title="Adroid权限"></a>Adroid权限</h4><p>权限分为普通权限和危险权限,普通权限会进行自动授权,危险权限则需要用户授权,其中危险权限包括如下:</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/学习笔记\Android\第一行代码.assets\image-20201208140648039.png" alt="image-20201208140648039" style="zoom:50%;"><h5 id="拨打电话"><a href="#拨打电话" class="headerlink" title="拨打电话"></a>拨打电话</h5><p>在Mainfest中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;&gt;&lt;/uses-permission&gt;</span><br></pre></td></tr></table></figure><p>修改mainactivity中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Button button = (Button)findViewById(R.id.button);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(MainActivity.<span class="keyword">this</span>, Manifest.permission.CALL_PHONE)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                <span class="comment">//拨打电话的权限未被授予</span></span><br><span class="line">                ActivityCompat.requestPermissions(</span><br><span class="line">                        MainActivity.<span class="keyword">this</span>,<span class="keyword">new</span> String[] &#123;Manifest.permission.CALL_PHONE&#125;,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//拨打电话的权限被授予则进行拨打</span></span><br><span class="line">                call();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拨打电话的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</span><br><span class="line">        intent.setData(Uri.parse(<span class="string">&quot;tel:10086&quot;</span>));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length&gt;<span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>]==PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                call();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;您未授权&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h4><p>以访问联系人为例,大部分之前都涉及了,直接堆代码了</p><p>首先赋予权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主活动中代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayAdapter&lt;String&gt; arrayAdapter;</span><br><span class="line">    List&lt;String&gt; contactList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ListView contactsView = (ListView)findViewById(R.id.myList);</span><br><span class="line">        arrayAdapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,contactList);</span><br><span class="line">        contactsView.setAdapter(arrayAdapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.READ_CONTACTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            readContacts();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readContacts</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Cursor c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(c.moveToNext())&#123;</span><br><span class="line">                    String name = c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));</span><br><span class="line">                    String number = c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">                    contactList.add(name+<span class="string">&quot;\n&quot;</span>+number);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                arrayAdapter.notifyDataSetChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                c.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(grantResults.length&gt;<span class="number">0</span>&amp;&amp;grantResults[<span class="number">0</span>]==PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    readContacts();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;您没有授予权限&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要观察readContacts()方法.</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/devApp\blog\source\_posts\第一行代码.assets\image-20201209123305891.png" alt="image-20201209123305891" style="zoom:50%;"><h3 id="使用网络技术"><a href="#使用网络技术" class="headerlink" title="使用网络技术"></a>使用网络技术</h3><h4 id="使用okhttp"><a href="#使用okhttp" class="headerlink" title="使用okhttp"></a>使用okhttp</h4><p>在build.gradle的dependencies中加载依赖</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttp</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okhttp3:okhttp:3.14.2&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.okio:okio:1.17.4&#x27;</span></span><br></pre></td></tr></table></figure><p>并build.gradle的android中添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示</p><img src="/2021/04/06/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81/devApp\blog\source\_posts\第一行代码.assets\image-20201210103636399.png" alt="image-20201210103636399" style="zoom: 33%;"><p>赋予权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布局文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/send&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;发送http请求&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/scrollView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/resText&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主活动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TextView resText;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    Button button = (Button)findViewById(R.id.send);</span><br><span class="line">    resText = (TextView)findViewById(R.id.resText);</span><br><span class="line">    button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            sendHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendHttpRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">                Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;https://api-hmugo-web.itheima.net/api/public/v1/goods/detail?goods_id=1&quot;</span>).build();</span><br><span class="line">                Response response = client.newCall(request).execute();</span><br><span class="line">                String responseData = response.body().string();</span><br><span class="line">                showResponse(responseData);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showResponse</span><span class="params">(<span class="keyword">final</span> String responseData)</span></span>&#123;</span><br><span class="line">    runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在这里进行ui操作,结果将显示到界面上</span></span><br><span class="line">            resText.setText(responseData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要在showResponse()方法中调用runOnUiThread()这个方法呢?因为在<strong>android中是不允许在子线程中进行ui操作的</strong>,需要通过调用这个方法切换到主线程,然后再更新ui元素.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2021/04/02/%E5%89%91%E6%8C%87offer/"/>
      <url>/2021/04/02/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>①举几个简单的具体例子让自己理解问题</p><p>②试着用图形表示抽象的数据结构</p><p>③试着把复杂的问题分解成若干的简单的子问题.(递归,分治法,动态规划)</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>①数组中的数字如果不存在重复的话,那么正常排序后数字i应该在下标为i的地方,可以根据这个对数组中数字的位置进行交换,从而发现重复.(剑指 Offer 03 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a> )</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2020/11/17/css/"/>
      <url>/2020/11/17/css/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>只能选择作为某元素的<strong>最近的一级子元素</strong>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只对div中的<strong>直接后代的所有a标签</strong>起作用</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="focus伪类选择器"><a href="#focus伪类选择器" class="headerlink" title=":focus伪类选择器"></a>:focus伪类选择器</h4><p>用于选取获得焦点的表单元素</p><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* :first-child第一个元素 :last-child最后一个元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* :nth-child(1)选中第一个子元素  */</span></span><br><span class="line"><span class="comment">/* :nth-child(n)全部选中,范围为0到正无穷  */</span></span><br><span class="line"><span class="comment">/* :nth-child(2n) 或 :nth-child(even)选中偶数子元素  */</span></span><br><span class="line"><span class="comment">/* :nth-child(2n+1) 或 :nth-child(odd)选中奇数子元素  */</span></span><br><span class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* :first-of-type :last-child nth-of-type和上面的类似 */</span></span><br><span class="line"><span class="comment">/* 不同的是这种只会选择ul中li中的第几个 */</span></span><br><span class="line"><span class="comment">/* 而上面的是针对ul中所有的元素,如果第一个元素不是li的话则无效 */</span></span><br><span class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* :not() 否定伪类,就是排除 */</span></span><br><span class="line"><span class="comment">/* 下面的表示除了第三个li都有效 */</span></span><br><span class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>))&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>表示页面中一些特殊的并不真实存在的元素(特殊的位置)</p><ul><li><p>字体</p><p>::first-letter    表示第一个字母</p><p>::first-line    表示第一行</p><p>::selection    选中的效果</p></li><li><p>div</p><p>::before 元素的开始</p><p>::after    元素的末尾</p><p>必须结合content来使用,content可以为空</p></li></ul><h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p>优先级的规则</p><p>!important 无穷大</p><p>​    内联样式 style=””，优先级1000<br>​    id选择器，优先级100<br>​    类和伪类，优先级10<br>​    元素选择器和伪元素，优先级1<br>​    通配*，优先级0<br>​    继承的样式，没有优先级</p><h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><p>长度单位</p><h3 id="像素px"><a href="#像素px" class="headerlink" title="像素px"></a>像素px</h3><p>​        像素是我们在网页中使用的最多的一个单位，一个像素就相当于我们屏幕中的一个小点，我们的屏幕实际上就是由这些像素点构成的但是这些像素点，是不能直接看见。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素就越小，反之像素越大。</p><h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比%"></a>百分比%</h3><p>​        也可以将单位设置为一个百比的形式，这样浏览器将会根据其父元素的样式来计算该值。使用百分比的好处是，当父元素的属性值发生变化时，子元素也会按照比例发生改变在我们创建一个自适应的页面时，经常使用百分比作为单位</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>​    em和百分比类似，它是相对于当前元素的字体大小来计算的</p><p>​    1em = 1font-size</p><h3 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h3><p>视口的宽度,100vm就是整个视口的宽度.</p><p>vm和百分比的区别:vm永远都相对于整个视口,而百分比参照的会随父元素的变化而改变</p><h2 id="垂直外边距的重叠"><a href="#垂直外边距的重叠" class="headerlink" title="垂直外边距的重叠"></a>垂直外边距的重叠</h2><p>在网页中<strong>相邻的垂直方向</strong>的外边距会发生外边距的重叠</p><h3 id="兄弟外边距折叠"><a href="#兄弟外边距折叠" class="headerlink" title="兄弟外边距折叠"></a>兄弟外边距折叠</h3><p>所谓的兄弟外边距重叠指垂直方向上兄弟元素之间的相邻外边距会取最大值而不是取和</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;up&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#up</span>,<span class="selector-id">#bottom</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#up</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="comment">/* 设置margin-bottom和margin-right会移动相邻的元素,自身不移动 */</span></span></span><br><span class="line"><span class="css"><span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#bottom</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="comment">/* 设置margin-top和margin-left会移动自身元素,相邻元素不移动 */</span></span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码对上面的div设置了margin-bottom,对下面的元素设置了margin-top.相邻的垂直方向的外边距会发生外边距的重叠,外边距重叠指兄弟元素之间的相邻外边距会取最大值,所以两个div的距离仍然是100,而不是200如下</p><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602134028697.png" alt="image-20210602134028697" style="zoom:25%;"><p>如果两个外边距全是正数,折叠后的边距取较大的一个</p><p>如果两个外边距一正一负,则取两个数的和</p><p>如果两个外边距全是负数,则取两个数绝对值大的那个</p><h3 id="父子外边距折叠"><a href="#父子外边距折叠" class="headerlink" title="父子外边距折叠"></a>父子外边距折叠</h3><p>如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素(上外边距)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码只给里面的子元素加了上外边距 但是效果如下,外面的父元素也随之移动</p><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602140713028.png" alt="image-20210602140713028" style="zoom:25%;"><h3 id="空元素外边距折叠"><a href="#空元素外边距折叠" class="headerlink" title="空元素外边距折叠"></a>空元素外边距折叠</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.slide3</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>第3种外边距折叠：空的块级元素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;slide3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background: #063181;color: #fff;&quot;</span>&gt;</span>这是用来检测slide3已经折叠的辅助元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下slide3应该是20px,但是实际只有10px</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>发生外边距折叠的共同原因：<strong>margin之间直接接触，没有阻隔</strong>。</p><ul><li>第一个例子中，两个<code>&lt;p&gt;</code>标签的垂直方向<code>margin</code>是直接接触的；</li><li>第二个例子中，由于父元素的<code>padding</code>,<code>border</code>都为0，所以<code>margin</code>和它的子元素也是直接接触的。（这个例子画出盒模型就很好理解）</li><li>第三个例子中，空元素本身的上下边距也是直接接触的（<code>padding</code>,<code>border</code>也是0）</li></ul><p>解决办法:</p><p>(1**)对父元素使用内边距**</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;<span class="comment">/*将父元素高度减去多余的高度*/</span></span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">padding-top</span>: <span class="number">100px</span>; <span class="comment">/*对父元素使用内边距*/</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20210602141639336.png" alt="image-20210602141639336" style="zoom:25%;"><p>(2)<strong>给外边距加boder</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">199px</span>;<span class="comment">/*将父元素的高度减去boder的宽度*/</span></span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border-top</span>: <span class="number">1px</span> <span class="number">#00FFFF</span> solid;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">99px</span>;<span class="comment">/*子元素外边距减去boder的宽度*/</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)使用伪元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.out</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.inner</span><span class="selector-pseudo">::before</span>&#123;<span class="comment">/*伪元素*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>:table;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(4)为父元素添加overflow:hidden</p><h2 id="内联元素和块元素盒子模型"><a href="#内联元素和块元素盒子模型" class="headerlink" title="内联元素和块元素盒子模型"></a>内联元素和块元素盒子模型</h2><ul><li><p>内联元素不能设置width和height</p></li><li><p>内联元素可以设置水平方向的内边距；也可以设置<strong>垂直方向的内边距</strong>，但是<strong>不会影响页面的布局</strong>，即若内联元素下方有其他元素，上方的内联元素内边距过大时会覆盖下方的元素。而块元素则会将下面的元素往下面挤。</p></li><li><p>内联元素可以设置边框，但是<strong>垂直的边框不会影响页面的布局</strong>。</p></li><li><p>内联元素可以设置外边距；<strong>垂直方向的外边距不会影响页面的布局</strong>。水平方向上会影响并且不会产生外边距重叠</p></li></ul><h2 id="轮廓阴影和圆角"><a href="#轮廓阴影和圆角" class="headerlink" title="轮廓阴影和圆角"></a>轮廓阴影和圆角</h2><p>outline属性用来设置元素的轮廓线,用法和border一样,区别是轮廓线不会影响可见框的大小,不会影响其他元素的位置</p><p>box-shadow用来设置元素的阴影效果,也不会影响页面的布局</p><p>​    第一个值:水平偏移量,设置阴影的水平位置,正值向右移动,负值向左移动</p><p>​    第二个值:垂直偏移量,设置阴影的垂直位置,正值向下移动,负值向上移动</p><p>​    第三个值:阴影的模糊半径,值越大,阴影越模糊</p><p>​    第四个值,阴影的颜色</p><p>border-radius属性用来设置圆角,设置圆角的半径大小,第一个值为水平方向的半径,第二个值为垂直方向的半径</p><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#00FFFF</span>;</span><br><span class="line"><span class="comment">/* float: left; */</span></span><br><span class="line"><span class="comment">/* 圆形 */</span></span><br><span class="line"><span class="comment">/* clip-path: circle(50% at 100% 0); */</span></span><br><span class="line"><span class="comment">/* 椭圆 */</span></span><br><span class="line"><span class="comment">/* clip-path: ellipse(50% 20%); */</span></span><br><span class="line"><span class="comment">/* 多边形 括号里面是各个顶点的位置 */</span></span><br><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">100%</span> <span class="number">0</span>,<span class="number">100%</span> <span class="number">100%</span>,<span class="number">0</span> <span class="number">100%</span>);</span><br></pre></td></tr></table></figure><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>设置了浮动后,元素水平布局的等式不再适用</p><p>浮动的特点:</p><p>​    (1)元素设置了float后会脱离文档流,所以元素下面的还在文档流中的元素会自动向上移动</p><p>​    (2)浮动元素会向父元素的左侧或右侧移动,默认不会从**父元素内容区中(即不会超过内边框)**移出</p><p>​    (3)浮动元素不会超过它前面的其他浮动元素,也不会覆盖其它浮动元素</p><p>​    (4)如果浮动元素的上边是一个没有浮动的块元素,则浮动元素无法上移</p><p>​    (5)当不设置浮动时,一个div会自动设置margin-right的值来使其内容区的宽度等于父元素的宽度.设置了浮动后,元素水平布局的等式不再适用</p><p>​    (6)<strong>浮动元素会生成一个块级框,因此如果让一个链接浮动,即使该链接元素本身是行内元素,就会生成一个块级框,会像块级元素一样摆放和表现.(也可以定义高度和宽度)</strong></p><p>浮动的其他特点</p><p>​    (1)浮动元素不会覆盖文字,文字会自动环绕在浮动元素周围(可以利用这个来实现文字环绕图片的效果)</p><p>脱离文档流的特点:</p><p>​    块元素</p><p>​    (1)块元素不再独占一行</p><p>​    (2)脱离文档流后,块元素的宽度和高度默认被内容撑开</p><p>​    行内元素</p><p>​    行内元素脱离文档流后会变成块元素,特点和块元素一样</p><h2 id="高度塌陷和BFC"><a href="#高度塌陷和BFC" class="headerlink" title="高度塌陷和BFC"></a>高度塌陷和BFC</h2><p>高度塌陷:想要使父元素的高度随着子元素的高度改变,即被子元素撑开,从而不设置父元素的具体高度.在这种情况下,子元素使用浮动属性,子元素会脱离文档流,导致无法撑起父元素的高度从而导致高度塌陷.父元素高度丢失之后会导致下面的元素下移,影响页面布局</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>block formatting context 格式化上下文</p><p>BFC是css中的一个隐含的属性,可以为一个元素开启BFC,该元素会变成一个<strong>独立的布局区域</strong></p><p>元素开启BFC后的特点:</p><ul><li>开启BFC后的元素不会被浮动元素覆盖</li><li>开启BFC的父元素中,子元素和父元素外边距不会重叠</li><li>可以包含浮动的子元素</li><li>bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。因此,当两个兄弟元素发生外边距重叠时,可以对某一个元素外面包裹一层div并开启bfc</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">       <span class="attribute">overflow</span>: hidden;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">       <span class="attribute">background-color</span>: red;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">       <span class="attribute">overflow</span>: hidden;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="selector-class">.box1</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">       <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">background-color</span>: green;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="selector-class">.box2</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">       <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">       <span class="attribute">background-color</span>: green;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样wrapper开启BFC并包裹box1,就可以避免box1和box2发生外边距重叠</p><p>开启BFC的方法:</p><ul><li><p>设置父元素为浮动(不推荐)</p></li><li><p>设置元素绝对定位</p></li><li><p>将父元素设置为行内块元素(不推荐)这种方法会使行宽不再自动扩大,而是子元素的宽度撑开的大小</p></li><li><p>将父元素的overflow设置为一个非visible的值</p><p>这是常用的方式,父元素overflow:hidden开启</p></li></ul><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>如果我们不希望某个元素因为其他元素浮动的影响而改变位置,可以通过clear属性</p><p>可选值:</p><ul><li>left 清楚左侧浮动元素对当前元素的影响</li><li>right 清除右侧浮动元素对当前元素的影响</li><li>both 清楚两侧中最大影响的那侧</li></ul><p>原理:设置清除浮动以后,浏览器会自动为元素添加一个<strong>上外边距</strong>,使其位置不受影响.</p><h3 id="解决高度塌陷最终方案"><a href="#解决高度塌陷最终方案" class="headerlink" title="解决高度塌陷最终方案"></a>解决高度塌陷最终方案</h3><p>可以在父元素的最下面加一个空的div 标签,设置clear属性,从而撑起父元素,这种方法相当于用html解决css的问题,下面使用伪元素的方式以纯css方式解决.</p><p><strong>使用伪元素选择器</strong>,对父元素使用伪元素选择器相当于在父元素的最后添加一个元素设置其样式.这个伪元素默认为行内元素.下面为示例,其中box1为父元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:block;<span class="comment">/*将伪元素转换为块元素*/</span></span><br><span class="line"><span class="attribute">clear</span>:both;<span class="comment">/*设置clear属性使其不受浮动元素影响,从而撑起父元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个既解决高度塌陷,又解决外边距重叠的方法,其中设置父元素的类为clearfix</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>:table;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position可选值:</p><ul><li>static 默认值,元素是静止的,没有开启定位</li><li>relative 相对定位</li><li>absolute 绝对定位</li><li>fixed 固定定位</li><li>sticky 粘滞定位</li></ul><p>对于开启的定位的元素,可以设置z-index设置元素的层级.如果都不设置z-index的话,则靠下的元素层级更高.</p><p>祖先元素的层级再高也不会覆盖后代元素.</p><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>开启后设置偏移量只会影响自己的位置,不影响其他元素</p><p>特点:</p><ul><li>开启后如果不设置偏移量,<strong>页面内得所有元素不会发生任何变化</strong></li><li>相对定位参照与元素在文档流中得位置进行定位得,即<strong>相对于自己本身位置得左上角</strong></li><li>相对定位会提升元素得层级,高于页面中其他元素.(即如果和其他元素重叠,会覆盖其他元素)</li><li>相对定位不会脱离文档流,不会改变元素的性质,即块级元素还是块级元素,行内还是行内</li></ul><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>特点</p><ul><li><p>开启绝对定位后,如果不设置偏移量,<strong>自身元素得位置不会发生变化</strong></p></li><li><p><strong>元素会从文档流中脱离</strong></p></li><li><p>元素开启绝对定位后会生成一个块级框,不论原来它在正常流中生成何种类型的框</p></li><li><p>会使元素提升一个层级</p></li><li><p><strong>开启了绝对定位后整个div盒子的宽度要加上left和right</strong></p><ul><li><p>水平方向上,当发生过度约束时,如果9个值中没有auto,则会自动调整right,如果有auto的话,会自动调整auto的值</p><p>可以设置auto的值:margin,width,left,right</p></li><li><p>垂直方向上,等式也必须要满足,这样也<strong>可以用上下外边距都设置为auto,top和bottom都设置为0的方式来使元素垂直居中.但是在非绝对定位时不可以.</strong></p></li></ul></li><li><p>绝对定位参照包含块进行定位,即<strong>相对于离他最近的开启了定位的祖先元素</strong>,如果所有的祖先元素都没有开启定位,则相对于根元素</p><p>包含块:</p><ul><li><p>正常情况下</p><p>包含块就是当前元素<strong>最近的祖先块元素</strong></p></li><li><p>绝对定位包含块</p><p>包含块是离他最近的开启了定位的祖先元素</p></li></ul></li></ul><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>固定定位也是一种绝对定位,大部分特点都和绝对定位一样</p><p>唯一不同的是固定定位永远参考与浏览器的视口进行定位(视口只有浏览器窗口大小,例如网页侧边的广告)</p><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>和relative相对定位和相似,不同的是粘滞定位可以在元素到达某个位置时将其固定</p><h2 id="文字超出显示省略号"><a href="#文字超出显示省略号" class="headerlink" title="文字超出显示省略号"></a>文字超出显示省略号</h2><p>white-space 设置网页如何处理文字的空白区域</p><p>可选值:</p><ul><li>normal 正常,即如果文字需要换行的时候,一个单词盛不下会换行</li><li>nowrap 不换行,一行中显示所有文字,会自动撑开div的宽度</li><li>pre 保留空白 即文字在html中是什么样式就显示什么样式,会保留空格和回车</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*文字超出显示省略号*/</span></span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line">text-flow:ellipsis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹性盒flex"><a href="#弹性盒flex" class="headerlink" title="弹性盒flex"></a>弹性盒flex</h2><p>当父元素设置flex布局之后,子元素的float clear 和 vertical-align属性将失效</p><h3 id="弹性容器-6个"><a href="#弹性容器-6个" class="headerlink" title="弹性容器(6个)"></a>弹性容器(6个)</h3><p>​    display:flex;</p><p>flex-direction 指定容器中弹性元素的排列方式,可选值:</p><ul><li>row 默认值,弹性元素在容器中水平排列(左向又),主轴自左向右</li><li>row-reverse 水平排列,从右向左</li><li>column 纵向排列(自上向下)</li><li>column-reverse 纵向自下向上</li></ul><p>flex-wrap 设置弹性元素在容器横向装不下的时候是否自动换行</p><ul><li><p>nowrap 默认值 元素不会自动换行</p><p>如果设置了不自动换行的话,那么如果盒子容器一行装不下里面的item,就会自动相同程度的缩小里面的每个item使他们在一行上显示.</p></li><li><p>wrap 元素沿着辅轴方向自动换行</p></li><li><p>wrap-reverse 元素沿着辅轴反方向换行</p></li></ul><p>flex-flow是flex-direction和flex-wrap的缩写</p><p>justify-content <strong>主轴</strong>上的元素如何排列,主轴空白空间的分布</p><ul><li>flex-start 元素沿着主轴的起边排列,即从左开始</li><li>flex-end 元素沿着主轴终边排列</li><li>center 元素居中排列</li><li>space-around 容器中的空白分布到元素两侧(这样会使中间的元素空隙大一些,因为中间的元素空隙为左边元素分配到的加上右边元素分配到的)</li><li>space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配空间.两边不再有空白</li><li>space-evenly 空白分布到元素单侧</li></ul><p>align-items 元素在辅轴上如何对齐(只适用于单行,在多行下没效果)</p><ul><li>stretch 默认值将元素的长度设置成相同的值,使其填满整个容器(每一行的高度相同,第一行和第二行不一定相同.需要把里面的item的高度值去掉才能生效)</li><li>flex-start 元素不会拉伸,沿着辅轴的垂直方向起边对齐</li><li>flex-end元素不会拉伸,沿着辅轴的垂直方向终边对齐</li><li>center</li></ul><p>align-content 辅轴空白空间的分布(属性和justify-content相同,适用于多行,,在单行下没效果)</p><ul><li>center 所有元素都在中间,上下空白空间相等</li></ul><h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>flex-grow 当父元素有多余空间时,子元素如何伸展,父元素的剩余空间会按照比例进行分配,默认是0</p><p>​    例如父元素宽度为 300,两个子元素宽度分别为100,此时父元素剩余100的宽度,为子元素分别设置flex-grow:1;和flex-grow:2;则父元素剩余的100宽度会按1:2的比例分配给两个子元素,使两个子元素盛满整个父元素</p><p>flex-shrink 当父元素的空间不足以容纳所有的子元素时,如何对子元素进行收缩</p><p>flex-basis 设置元素在主轴上的长度,优先级大于width,低于max-width</p><p>flex 分配<strong>剩余空间</strong>,用flex表示占多少份数  前三个属性的缩写,顺序:增长 缩减 基础.</p><p>align-self 用来覆盖当前弹性元素上的align-items,即不再受容器中的align-items属性约束,使用自己的设置的在辅轴上的对齐方式</p><p>order 指定弹性元素的排列顺序,传入整数数值,数值越小越靠前(默认是0)</p><h2 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h2><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">100%</span>,<span class="number">100%</span>,<span class="number">100px</span>);<span class="comment">/*分别为x轴,y轴和z轴*/</span></span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">2</span>);<span class="comment">/*x轴放大为原来的2倍*/</span></span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">45deg</span>);<span class="comment">/*以x轴为轴旋转45°*/</span></span><br></pre></td></tr></table></figure><h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">45deg</span>);<span class="comment">/*以x轴为轴倾斜45°,变成平行四边形*/</span></span><br></pre></td></tr></table></figure><h2 id="css面试布局"><a href="#css面试布局" class="headerlink" title="css面试布局"></a>css面试布局</h2><h3 id="圣杯布局和双飞翼布局"><a href="#圣杯布局和双飞翼布局" class="headerlink" title="圣杯布局和双飞翼布局"></a>圣杯布局和双飞翼布局</h3><p>圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，<strong>圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right</strong> 。</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="css权威指南"><a href="#css权威指南" class="headerlink" title="css权威指南"></a>css权威指南</h1><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择h1的子元素中所有p元素,注意,<strong>只是子元素,后代元素不受影响</strong></p><h3 id="兄弟元素选择器"><a href="#兄弟元素选择器" class="headerlink" title="兄弟元素选择器"></a>兄弟元素选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>+<span class="selector-tag">p</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要求h1和p必须有相同的父元素</strong></p><h3 id="伪类选择器-1"><a href="#伪类选择器-1" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:link定义未访问过的锚点,而:visited定义已访问的锚点.他们是静态的,第一次显示后,他们一般不会再改变文档的样式.</p><h4 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:focus</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:focus表示拥有输入焦点的元素.</p><p>:hover鼠标停留的元素.</p><p>:active被用户输入激活的元素,比如用户点击超链接.</p><h4 id="选择第一个子元素"><a href="#选择第一个子元素" class="headerlink" title="选择第一个子元素"></a>选择第一个子元素</h4><p>first-child,来选择元素的第一个子元素.</p><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><h4 id="设置首字母样式"><a href="#设置首字母样式" class="headerlink" title="设置首字母样式"></a>设置首字母样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置第一行的样式"><a href="#设置第一行的样式" class="headerlink" title="设置第一行的样式"></a>设置第一行的样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置之前和之后元素的样式"><a href="#设置之前和之后元素的样式" class="headerlink" title="设置之前和之后元素的样式"></a>设置之前和之后元素的样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>:before&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>:after&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构和层叠"><a href="#结构和层叠" class="headerlink" title="结构和层叠"></a>结构和层叠</h2><h3 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h3><p>特殊性值表述分为4个部分,如:0,0,0,0.一个选择器的具体特殊性如下确定:</p><ul><li><p>内联样式,加1,0,0,0</p></li><li><p>对于选择器中给定的各个ID属性值,加0,1,0,0</p></li><li><p>类属性值,属性选择或伪类,加0,0,1,0</p></li><li><p>各个元素和伪元素,加0,0,0,1</p></li><li><p>通配符,0</p></li></ul><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>在这些声明的结束分号之前插入!important来标志</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.dart</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:yellow <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#AAAAAA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><img src="/2020/11/17/css/image-20210802111245645.png" alt="image-20210802111245645"></p><p>将声明color:gray;应用到ul元素时,这个元素会采用该声明,这个值再沿着树向下传播到后代元素,并一直继续,直到再没有更多后代元素继承这个值为止.</p><p>有些属性不能继承,如border,一般的大多数框模型属性(外边距,内边距,背景和边框)都不能继承.</p><p>继承值完全没有特殊性.看下面的例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&#x27;page-title&#x27;</span>&gt;</span>Meerkat<span class="tag">&lt;<span class="name">em</span>&gt;</span>Central<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>welcome to the best place......<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">*&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">color</span>:gray;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span><span class="selector-id">#page-title</span>&#123;</span></span><br><span class="line"><span class="css"><span class="attribute">color</span>:black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如图</p><p><img src="/2020/11/17/css/image-20210802112426284.png" alt="image-20210802112426284"></p><p>因为统配选择器适用于所有元素,而且有0特殊性,其颜色声明指定的值gray要优先于继承值(black),因为继承值根本没有特殊性,因此em元素显示为灰色而不是黑色.</p><h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>如果特殊性相等的两个规则同时应用到一个元素会怎样?</p><h4 id="按权重和来源排序"><a href="#按权重和来源排序" class="headerlink" title="按权重和来源排序"></a>按权重和来源排序</h4><p>层叠规则:</p><p><img src="/2020/11/17/css/image-20210802112938917.png" alt="层叠规则"></p><p>总结一下,再声明权重方面要考虑5级,权重由大到小顺序依次为:</p><p>1.读者的重要声明</p><p>2.创作人员的重要声明</p><p>3.创作人员的正常声明</p><p>4.读者的正常声明</p><p>5.用户代理声明</p><h4 id="按特殊性排序"><a href="#按特殊性排序" class="headerlink" title="按特殊性排序"></a>按特殊性排序</h4><p>如果权重相同,则按特殊性排序.</p><h4 id="按顺序排序"><a href="#按顺序排序" class="headerlink" title="按顺序排序"></a>按顺序排序</h4><p>如果两个规则的权重,来源和特殊性完全相同,那么再样式表中后出现的一个会胜出.</p><p>正是由于按这种顺序排序,才有了通常推荐的链接样式顺序,一般建议<strong>按link-visited-hover-active(LVHA)的顺序声明链接样式</strong>.因为这些选择器的特殊性都是一样的,都是0,0,1,0.因此与元素匹配的最后一个选择器才会胜出.正在”点击”的未访问链接可以与其中的3个规则匹配:link,hover,active.所以在这三个规则当中最后声明的一个将胜出.</p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="用RGB指定颜色"><a href="#用RGB指定颜色" class="headerlink" title="用RGB指定颜色"></a>用RGB指定颜色</h3><p>通过组合不同的红色绿色和蓝色分量来创造颜色.有四种方式</p><h4 id="函数式RGB颜色"><a href="#函数式RGB颜色" class="headerlink" title="函数式RGB颜色"></a>函数式RGB颜色</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rgb(<span class="number">100%</span>,<span class="number">100%</span>,<span class="number">100%</span>) <span class="comment">/*黑色*/</span></span><br><span class="line">rgb(<span class="number">0%</span>,<span class="number">0%</span>,<span class="number">0%</span>)<span class="comment">/*白色*/</span></span><br><span class="line"></span><br><span class="line">rgb(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)<span class="comment">/*黑色*/</span></span><br><span class="line">rgb(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)<span class="comment">/*白色*/</span></span><br></pre></td></tr></table></figure><h4 id="十六进制RGB颜色"><a href="#十六进制RGB颜色" class="headerlink" title="十六进制RGB颜色"></a>十六进制RGB颜色</h4><h4 id="web安全颜色"><a href="#web安全颜色" class="headerlink" title="web安全颜色"></a>web安全颜色</h4><p><img src="/2020/11/17/css/image-20210802140351091.png" alt="web安全颜色"></p><h3 id="长度单位-1"><a href="#长度单位-1" class="headerlink" title="长度单位"></a>长度单位</h3><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p>em ex px</p><h5 id="em和ex"><a href="#em和ex" class="headerlink" title="em和ex"></a>em和ex</h5><p>1个em定义为一种给定字体的font-size值,如果一个元素的font-size为14像素,那么1em就等于14像素.</p><p>另一方面,在设置字体大小时,em的值会相对于父元素的字体大小改变.</p><p>与此不同,ex是指所用字体中小写x的高度.</p><h2 id="水平auto"><a href="#水平auto" class="headerlink" title="水平auto"></a>水平auto</h2><p>要求七个值之和等于包含块的width.</p><p>内边距,边框和内容宽度绝对不能为负值,只有外边距能小于零.</p><p>只有margin-left,width,margin-right三个属性可以设置为auto.</p><h3 id="只有一个auto"><a href="#只有一个auto" class="headerlink" title="只有一个auto"></a>只有一个auto</h3><p>当这三个属性中只有一个属性为auto时,将会由这个auto的属性来填补所需的距离.而当三个都设置具体的值时,但是此时仍然出现过分约束的情况,则会调整右外边距的值.</p><h3 id="有两个auto"><a href="#有两个auto" class="headerlink" title="有两个auto"></a>有两个auto</h3><p>两个外边距为auto而width设置为具体值时,两个外边距的值相等,此时元素水平居中.</p><p>将某个外边距以及width设置为auto时,设置为auto的外边距会变为0,而width会变为所需的值.</p><h3 id="三个auto"><a href="#三个auto" class="headerlink" title="三个auto"></a>三个auto</h3><p>三个都是auto的情况下,两个外边距会变为0,width尽可能的宽.</p><h2 id="垂直auto"><a href="#垂直auto" class="headerlink" title="垂直auto"></a>垂直auto</h2><p>如果一个块元素的margin-top或margin-bottom设置为auto,会自动计算为0.</p><h2 id="内边距和外边距"><a href="#内边距和外边距" class="headerlink" title="内边距和外边距"></a>内边距和外边距</h2><h4 id="百分数和外边距"><a href="#百分数和外边距" class="headerlink" title="百分数和外边距"></a>百分数和外边距</h4><p>外边距可以设置为百分数,百分数是相对于<strong>父元素的width</strong>计算的.</p><p>如果外边距指定少于四个值,规则如下:</p><ul><li>如果缺少左外边距的值,则使用右外边距的值.</li><li>如果缺少下外边距的值,则使用上外边距的值.</li><li>如果缺少右外边距的值,则使用上外边距的值.</li></ul><p>总结:如果指定了三个值,那么第四个值(左外边距)会取第二个值(右外边距);如果给定了两个值,那么第四个值(左外边距)会取第二个值(右外边距),第三个值(下外边距)会取第一个值(上外边距);如果给定了一个值,那么其他三个值都取这个值.</p><h4 id="百分数和内边距"><a href="#百分数和内边距" class="headerlink" title="百分数和内边距"></a>百分数和内边距</h4><p>内边距可以设置为百分数,百分数是相对于<strong>父元素的width</strong>计算的.</p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>默认下,元素的前景色(如color:red)会应用到边框.比如设置了边框的样式为solid,但是没有设置颜色,这个时候边框的默认宽度为2px,颜色为元素的前景色.</p><p>背景色background-color不能继承,其默认值是transparent.文档中有些元素没有自己的背景.那么透过所有的这些元素都能看到父元素的北京.这些元素并没有继承背景,只是能透过他们看到北京而已.</p><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背景图像也不能继承.原因:如果能继承,而且向body应用了一个背景图像,这个图象将用于文档所有元素的背景,而且每个元素都完成自己的平铺.</p><p>可以设置平铺的方向如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>();</span><br><span class="line"><span class="attribute">background-repeat</span>: repeat-x; <span class="comment">/*可选repeat,repeat-y,no-repeat*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背景定位"><a href="#背景定位" class="headerlink" title="背景定位"></a>背景定位</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>();</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat; <span class="comment">/*可选repeat,repeat-y,no-repeat*/</span></span><br><span class="line"><span class="attribute">background-position</span>: center; </span><br><span class="line">    <span class="comment">/*使用值的方式时,第一个数为水平方向.第二个为垂直方向*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用数值</p><p>这将解释为从元素内边距区左上角的偏移,偏移点是原图像的左上角.</p><p>也可以使用百分数值</p><p>将原图像在一个元素中居中时,图像中描述为50% 50%的点(中心点)与元素中描述为50% 50%的点(中心点)对齐.如果图像位于0% 0%,其左上角将放在元素内边距区的左上角,如果图像位置是100% 100%,会使原图像的右下角放在内边距区的右下角.</p><h4 id="背景固定"><a href="#背景固定" class="headerlink" title="背景固定"></a>背景固定</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>();</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat; <span class="comment">/*可选repeat,repeat-y,no-repeat*/</span></span><br><span class="line"><span class="attribute">background-position</span>: center; </span><br><span class="line">    <span class="comment">/*使用值的方式时,第一个数为水平方向.第二个为垂直方向*/</span></span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed; <span class="comment">/*可选scroll*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixed,原图像不会随文档滚动,其次原图像的放置由可视区的大小确定,而不是由包含该图像的元素大小决定.</p><h1 id="查漏补缺"><a href="#查漏补缺" class="headerlink" title="查漏补缺"></a>查漏补缺</h1><h2 id="display-none、visibility-hidden-和-opacity-0-之间的区别？"><a href="#display-none、visibility-hidden-和-opacity-0-之间的区别？" class="headerlink" title="display:none、visibility:hidden 和 opacity:0 之间的区别？"></a>display:none、visibility:hidden 和 opacity:0 之间的区别？</h2><img src="/2020/11/17/css/devApp\myblog\source\_posts\css\image-20220607155418699.png" alt="image-20220607155418699" style="zoom: 50%;">]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序</title>
      <link href="/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><h2 id="列表循环"><a href="#列表循环" class="headerlink" title="列表循环"></a>列表循环</h2><p>1 wx:for=”“  wx:for-item=”循环项的名称”  wx:for-index=”循环项的索引”</p><p>2 wx:key=”唯一的值”用来提高列表渲染的性能</p><p>​    1 wx:key 绑定一个普通的字符串的时候,那么这个字符串名称肯定是循环数组中的对象的唯一属性</p><p>​    2 wx:key=”*this” 表示这个数组是一个普通数组,”*this” 就是循环项.比如[1,2,3,52]</p><h2 id="对象循环"><a href="#对象循环" class="headerlink" title="对象循环"></a>对象循环</h2><p>1 wx:for=”“  wx:for-item=”对象的值”  wx:for-index=”对象的属性”</p><h1 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h1><p>例如需求为文本框中的内容发生改变,下面的view 中的数据也随之发生改变</p><p>首先在data中定义num=0之后编辑wxml文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleInput&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  &#123;&#123;num&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中bindinput作用是监听文本框发生改变,接下来在js文件中编写handleInput方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleInput</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">num</span>: e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小程序中修改数据的语法为this.setData({ }).其中e中包含传入的文本框中的值</p><h1 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h1><h2 id="自定义组件的基本使用"><a href="#自定义组件的基本使用" class="headerlink" title="自定义组件的基本使用"></a>自定义组件的基本使用</h2><p>在项目中新建components文件夹,在components文件夹下新建tabs文件夹,在tabs文件夹下新建components命名为Tabs,这样自定义组件就建好了</p><p>需要使用自定义组件的时候只需在响应界面的json中添加响应的组件和路径比如下面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Tabs&quot;</span>:<span class="string">&quot;../../components/tabs/Tabs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在页面的wxml文件中使用命名的组件作为标签即可,如<Tabs></Tabs></p><h2 id="tabbar实例"><a href="#tabbar实例" class="headerlink" title="tabbar实例"></a>tabbar实例</h2><p>接下来展示一个tabbar 的实例,实现结果如图</p><img src="/2020/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F/devApp\blog\source\_posts\小程序.assets\image-20210422135024938.png" alt="image-20210422135024938" style="zoom: 33%;"><p>首先在Tabs.js中定义tabbar的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    tabs:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        title:<span class="string">&quot;首页&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        title:<span class="string">&quot;购物车&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">3</span>,</span><br><span class="line">        title:<span class="string">&quot;我的&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来编辑wxml界面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;tabs-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;title-item &#123;&#123;item.isActive?&#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;handleTap&quot;</span> <span class="attr">data-index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.title&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中bindtap是用来绑定点击事件,data-index是需要传递给绑定事件的参数,当点击时可以在e中获取,详细请看下面的handleTap方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleTap</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = e.currentTarget.dataset.index;</span><br><span class="line">      <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">      tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        tabs</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来修改样式文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tabs-item</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.title-item</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父向子传递数据"><a href="#父向子传递数据" class="headerlink" title="父向子传递数据"></a>父向子传递数据</h2><p>父组件(页面)向子组件(自定义组件)传递数据,需要通过标签属性进行传递</p><p>比如上面的tabbar实例,若其他界面也需要用到这个tabbar,但是样式不变,里面的每一项的标题需要改变.这样就可以将标题的数据存在父组件中,然后在子组件中进行接收</p><p>在父组件,即任意的page的js的data中定义tabs数组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    msg:<span class="string">&quot;这是页面二&quot;</span>,</span><br><span class="line">    tabs:[</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">0</span>,</span><br><span class="line">        title:<span class="string">&quot;首页&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">1</span>,</span><br><span class="line">        title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">2</span>,</span><br><span class="line">        title:<span class="string">&quot;购物车&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id:<span class="number">3</span>,</span><br><span class="line">        title:<span class="string">&quot;我的&quot;</span>,</span><br><span class="line">        isActive:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再在本页面的wxml使用子组件的地方传出数据,使用标签,名称自定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在Tabs组件的js中接收数据.父向子传递数据,在子组件中的js文件的properties中接收</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    tabs:&#123;</span><br><span class="line">      type:Array,</span><br><span class="line">      value:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是tabs这组数据就可以当作Tabs组件自己的数据进行使用</p><h2 id="子向父传递数据"><a href="#子向父传递数据" class="headerlink" title="子向父传递数据"></a>子向父传递数据</h2><p>进行如上的更改后看起来是没有问题,但是想一想,Tabs组件对点击事件进行处理,即改变数组中被点击的isActive的属性的时候,是将父组件传递的tabs数组当作自己的数据进行更改了.也就是说相当于Tabs组件复制了一份tabs数组对其进行操作,然而父组件中的源数据(也就是父组件中的tabs数组)并没有被更改.</p><p>这时需要在Tabs组件(也就是子组件)中向父组件(也就是page页面)传递一个被点击的页面的index参数,即子向父传递数据,从而在父组件中对源数据(也就是父组件中的tabs数组)进行更改.</p><p>子组件向父组件传递数据使用this.triggerEvent(“父组件自定义事件的名称”,要传递的参数).</p><p>所以更改Tabs组件的js中handleTap方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleTap</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> index = e.currentTarget.dataset.index;</span><br><span class="line">      <span class="built_in">this</span>.triggerEvent(<span class="string">&quot;itemChange&quot;</span>,index);</span><br><span class="line">      <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">      tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">        tabs</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来需要回到父组件中,在父组件的标签上加入一个自定义事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Tabs</span> <span class="attr">tabs</span>=<span class="string">&quot;&#123;&#123;tabs&#125;&#125;&quot;</span> <span class="attr">binditemChange</span>=<span class="string">&quot;handleItemChange&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Tabs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>binditemChange即”bind”拼接上this.triggerEvent(“itemChange”,index)传入的自定义事件名称.这样就可以在父组件的handleItemChange方法中处理Tabs传进来的数据了</p><p>在父组件的js中定义handleItemChange方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleItemChange</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = e.detail.index;</span><br><span class="line">    <span class="keyword">let</span> tabs = <span class="built_in">this</span>.data.tabs;</span><br><span class="line">    tabs.forEach(<span class="function">(<span class="params">v,i</span>)=&gt;</span>i===index?v.isActive=<span class="literal">true</span>:v.isActive=<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样下来就完成了子向父传递数据,并对父组件中的数组进行操作.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解TCP/IP</title>
      <link href="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/"/>
      <url>/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/</url>
      
        <content type="html"><![CDATA[<h1 id="分层参考模型"><a href="#分层参考模型" class="headerlink" title="分层参考模型"></a>分层参考模型</h1><p>ISO制定的OSI参考模型，分成了七层。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201031142356957.png" alt="da"></p><p>在这一模型中，每个分层都接收由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务。上下层之间进行交互时所遵循的约定叫做“接口”。同一层之间的交互所遵循的约定叫做“协议。</p><h2 id="各层的功能"><a href="#各层的功能" class="headerlink" title="各层的功能"></a>各层的功能</h2><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201031144647886.png" alt="asda"></p><h2 id="网络层和数据链路层的区别"><a href="#网络层和数据链路层的区别" class="headerlink" title="网络层和数据链路层的区别"></a>网络层和数据链路层的区别</h2><p>网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址，而数据链路层则只负责发送一个分段内的数据。</p><h1 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h1><h2 id="1、面向有连接型和面向无连接型"><a href="#1、面向有连接型和面向无连接型" class="headerlink" title="1、面向有连接型和面向无连接型"></a>1、面向有连接型和面向无连接型</h2><p>面向无连接型包括以太网、UDP等协议。</p><p>面向有连接型包括ATM、帧中继、TCP等协议。</p><h2 id="2、电路交换和分组交换"><a href="#2、电路交换和分组交换" class="headerlink" title="2、电路交换和分组交换"></a>2、电路交换和分组交换</h2><p>在分组交换中，由<strong>分组交换机(路由器)<strong>连接通信线路。分组交换的大致处理过程是:发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，</strong>缓存到自己的缓冲区</strong>，然后再转发给目标计算机。因此，分组交换也有另一个名称:蓄积交换。路由器接收到数据以后会按照顺序缓存到相应的队列当中，再以<strong>先进先出的顺序将它们逐一发送出去</strong>。</p><h2 id="3、根据接收端数量分类"><a href="#3、根据接收端数量分类" class="headerlink" title="3、根据接收端数量分类"></a>3、根据接收端数量分类</h2><p>单播 广播 多播 任播</p><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>MAC地址和IP地址在标识一个通讯主体时虽然都具有唯一性，但是只有IP地址具有层次性。</p><h1 id="网络的构成要素"><a href="#网络的构成要素" class="headerlink" title="网络的构成要素"></a>网络的构成要素</h1><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201103150203879.png" alt="image-20201103150203879"></p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201103150226220.png" alt="image-20201103150226220"></p><h2 id="传输速率和吞吐量"><a href="#传输速率和吞吐量" class="headerlink" title="传输速率和吞吐量"></a>传输速率和吞吐量</h2><p>​        在数据传输的过程中，两个<strong>设备之间</strong>数据流动的物理速度称为<strong>传输速率</strong>。单位为bps (Bits Per Second,每秒比特数)。从严格意义上讲，<strong>各种传输媒介中信号的流动速度是恒定的。因此，即使数据链路的传输速率不相同，也不会出现传输的速度忽快忽慢的情况</strong>“。传输速率高也不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。以我们生活中的道路交通为例，低速数据链路就如同车道较少无法让很多车同时通过的情况。与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。传输速率又称作带宽( Bandwidth)。带宽越大网络传输能力就越强。</p><p>​        此外，<strong>主机之间</strong>实际的传输速率被称作<strong>吞吐量</strong>。其单位与带宽相同,都是bps (Bits Per Second)。<strong>吞吐量这个词不仅街量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额(不含报文首部，只计算数据字段本身)等信息</strong>。</p><h2 id="传输设备"><a href="#传输设备" class="headerlink" title="传输设备"></a>传输设备</h2><p>1、中继器：物理层</p><p>①物理层面上延长网络的设备，但不能无限延长。负责对减弱的信号进行<strong>放大和发送</strong>。</p><p>②只负责将电信号转换为光信号，因此<strong>不能在传输速率不同的媒介中转发</strong>。也<strong>不负责判断数据是否发生错误</strong>。</p><p>③集线器可以看成多口中继器，每个端口都可以成为一个中继器。</p><p>2、网桥（2层交换机）：数据链路层</p><p>●网桥根据数据帧的内容转发数据给相邻的其他网络<br>●网桥<strong>没有连接网段个数的限制</strong><br>●网桥基本只用于连接相同类型的网络。但是有时也可以连接<strong>传输速率不同</strong>的网络。</p><p>①数据链路的数据帧有一数据位叫做FCS，用以校验数据是否正确送达目的地。网桥通过检查这个域的值来<strong>丢弃损坏的数据</strong>。</p><p>②网桥还能通过地址自学机制和过滤功能<strong>控制网络流量</strong>。</p><p>③以太网等网络中经常使用的交换集线器(Hub”)，现在基本也属于网桥的一种。交换集线器中连接电缆的每个端口都能提供类似网桥的功能。</p><p>④自学式网桥。</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201103164819940.png" alt="image-20201103164819940"></p><p>3、路由器（3层交换机）：网络层</p><p>网桥是根据MAC地址进行处理，而路由器是根据IP地址进行处理</p><p>4、网关</p><p>网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。它与4~7层交换机一样都是处理传输层及以上的数据，但是<strong>网关不仅转发数据还负责对数据进行转换</strong>，它通常会使用一个表示层或应用层网关，<strong>在两个不能进行直接通信的协议之间进行翻译，最终实现两者之间的通信</strong>。</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC地址长48比特</p><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201106102737993.png" alt="image-20201106102737993"></p><h2 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h2><p>在这种方式下，设备之间使用同一个载波信道进行发送和接收，为此基本上采用半双工通信方式，并对介质进行访问控制。</p><p>共享介质型网络有两种介质访问控制方式：①争用方式②令牌传递方式</p><h3 id="争用方式（CSMA载波监听多路访问）"><a href="#争用方式（CSMA载波监听多路访问）" class="headerlink" title="争用方式（CSMA载波监听多路访问）"></a>争用方式（CSMA载波监听多路访问）</h3><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201106103313606.png" alt="dasd"></p><p>CSMA/CD是一种CSMA改良的方式，其工作原理如下</p><ul><li>如果载波信道上没有数据流动，则任何站都可以发送数据。</li><li>检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立即释放载波信道。</li><li>放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</li></ul><h3 id="令牌传递方式"><a href="#令牌传递方式" class="headerlink" title="令牌传递方式"></a>令牌传递方式</h3><p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source_posts\图解TCP-IP\image-20201106104106797.png" alt="dawdw"></p><p>优点：①不会有冲突②每个站都有通过平等循环获得令牌的机会，因此即使网络拥堵也不会导致性能下降。</p><p>缺点：数据链路的利用率达不到100%。</p><h2 id="非共享介质网络"><a href="#非共享介质网络" class="headerlink" title="非共享介质网络"></a>非共享介质网络</h2><p>每个站直连交换机，由交换机负责转发数据帧，全双工通信。</p><p>缺点：一旦交换机发生故障，与之相连的所有计算机将无法通信。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点( end-to-end)通信”。(节点是主机和路由器的统称)</p><p>IP是跨越网络传送数据包,使整个互联网都能收到数据的协议,使用IP地址作为主机的标识.</p><p>虽然IP也是分组交换的一种协议,但是<strong>它不具有重发机制,即使分组数据包未能到达对端主机也不会重发.因此属于非可靠性传输协议</strong>.</p><h3 id="网络层和数据链路层区别"><a href="#网络层和数据链路层区别" class="headerlink" title="网络层和数据链路层区别"></a>网络层和数据链路层区别</h3><p>仔细分析一下机票和火车票，不难发现，每张票只能够在某一限定区间内移动。此处的“区间内”就如同通信网络上的数据链路。而这个区间内的出发地点.和目的地点就如同某一个数据链路的源地址和目标地址等首部信息”。整个全程的行程表的作用就相当于网络层。</p><h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><p>IP大致分为三大作用模块，它们是<strong>IP寻址</strong>、<strong>路由</strong>（最终节点为止的转发)以及<strong>IP分包与组包</strong>。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>MAC地址是用来识别同一链路中不同计算机的一种识别码</p><p>IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址</p><h4 id="IP为什么采用面向无连接"><a href="#IP为什么采用面向无连接" class="headerlink" title="IP为什么采用面向无连接"></a>IP为什么采用面向无连接</h4><p>主要有两点原因:一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。因此，IP为了实现简单化与高速化采用面向无连接的方式。</p><h4 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h4><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211227154848944.png" alt="image-20211227154848944" style="zoom:67%;"><p>数据链路实现某一区间内的通信,及两个直接相连的主机或路由器间的通信.而IP实现直接至最终目标地址的通信.</p><h3 id="IP地址基础知识"><a href="#IP地址基础知识" class="headerlink" title="IP地址基础知识"></a>IP地址基础知识</h3><p>IP地址由<strong>网络标识</strong>和<strong>主机标识</strong>两部分组成</p><h4 id="多播和广播"><a href="#多播和广播" class="headerlink" title="多播和广播"></a>多播和广播</h4><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211230095457645.png" alt="image-20211230095457645" style="zoom: 67%;"><p>路由器不转发广播的包,但是可以复制多播的包.</p><h3 id="路由控制-1"><a href="#路由控制-1" class="headerlink" title="路由控制"></a>路由控制</h3><p>下图是发送IP包的实例</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211230103655364.png" alt="image-20211230103655364" style="zoom:67%;"><h3 id="报文的分片与重组"><a href="#报文的分片与重组" class="headerlink" title="报文的分片与重组"></a>报文的分片与重组</h3><p>任何一台主机都有必要对IP分片（ IP Fragmentation)进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p><p>由于以太网的默认MTU是1500字节，因此4342字节的IP数据报无法在一个帧当中发送完成。这时，路由器将此IP数据报划分成了3个分片进行发送。而这种分片处理只要路由器认为有必要，会周而复始地进行”。</p><p><strong>经过分片之后的P数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</strong></p><h3 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h3><p>所谓路径MTU (Path MTU)是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小。<strong>即路径中存在的所有数据链路中最小的MTU</strong>。而路径MTU发现从发送主机按照路径MTU的大小将数据报分片后进行发送。进行路径MTU发现，就可以避免在中途的路由器上进行分片处理.</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6的特点"><a href="#IPv6的特点" class="headerlink" title="IPv6的特点"></a>IPv6的特点</h4><ul><li>IPv4的地址长度为4个8位字节,即32比特.而IPv6的地址长度则是128比特,一般携程8个16位字节.</li></ul><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211230132817732.png" alt="image-20211230132817732" style="zoom:67%;"><p><strong>IPv6的分片处理旨在作为起点的发送端主机上运行,路由器不参与分片.因此IPv6中”路径MTU发现”功能必不可少</strong></p><h2 id="IP相关协议"><a href="#IP相关协议" class="headerlink" title="IP相关协议"></a>IP相关协议</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211230165719225.png" alt="image-20211230165719225" style="zoom:67%;"><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>从分组数据包的IP地址中解析出物理地址(MAC地址)的一种协议</p><p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址。不过ARP只适用于IPv4.</p><p>过程:主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机I地址。也就是说，ARP请求包中已经包含了主机B的IP地址172.20.1.2。由于广播的包可以被同一个链路上所有的主机或路由器接收，因此ARP的请求包也就会被这同一个链路上所有的主机和路由器进行解析。如果ARP请求包中的目标I地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞人ARP响应包返回给主机A。</p><h4 id="IP和MAC地址缺一不可"><a href="#IP和MAC地址缺一不可" class="headerlink" title="IP和MAC地址缺一不可"></a>IP和MAC地址缺一不可</h4><p>如图所示，主机A想要发送IP数据报给主机B时必须得经过路由器C。即使知道了主机B的MAC地址，由于路由器C会隔断两个网络，还是无法实现直接从主机A发送数据报给主机B。此时，主机A必须得先将数据报发送给路由器C的MAC地址C1。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211231140405938.png" alt="image-20211231140405938" style="zoom:80%;"><p>此外，假定MAC地址就用广播地址，那么路由器D也将会收到该广播消息。于是路由器D又将该消息转发给路由器C，导致数据包被重复发送两次。<br>在以太网上发送IP包时，“下次要经由哪个路由器发送数据报”这一信息非常重要。而这里的“下一个路由器”就是相应的 MAC地址。</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>有了DHCP，实现自动设置IP地址、统一管理IP地址分配，计算机只要连接到网络,就可以进行TCP/IP通信。也就是说，DHCP让即插即用”变得可能。而 DHCP不仅在IPv4中，在IPv6中也可以使用。</p><h3 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h3><p>在一个如图所示的网络环境里，网络A、B使用IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A与网络B之间将无法直接进行通信。为了让它们之间正常通信，这时必须得采用IP隧道的功能。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20220104093929815.png" alt="image-20220104093929815" style="zoom:50%;"><p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C。</p><p>一般情况下，紧接着IP首部的是TCP 或UDP的首部。然而，现在的应用当中“IP首部的后面还是IP首部”或者“IP首部的后面是IPv6的首部”等情况与日俱增。这种在网络层的首部后面继续追加网络层首部的通信方法就叫做“IP隧道”。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP和UDP区分"><a href="#TCP和UDP区分" class="headerlink" title="TCP和UDP区分"></a>TCP和UDP区分</h2><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211221102623825.png" alt="image-20211221102623825" style="zoom: 33%;"><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211221102757217.png" alt="image-20211221102757217" style="zoom:33%;"><p>TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是<strong>“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”</strong>。只要其中某一项不同，则被认为是其他通信。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp首部最少20个字节，TCP首部有20个字节的固定数据，用来存放报文传输过程所需的信息。</p><p><code>UDP</code>报头包括4个字段，每个字段占用2个字节</p><p>TCP通过<strong>检验和</strong>、<strong>序列号</strong>、<strong>确认应答</strong>、<strong>重发控制</strong>、<strong>连接管理</strong>以及<strong>窗口控制</strong>等机制实现可靠性传输。</p><h3 id="通过序列号和确认应答提高可靠性"><a href="#通过序列号和确认应答提高可靠性" class="headerlink" title="通过序列号和确认应答提高可靠性"></a>通过序列号和确认应答提高可靠性</h3><p>上述这些确认应答处理、重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节(8位字节）都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。就这样，通过序列号和确认应答号，TCP可以实现可靠传输。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223102350624.png" alt="image-20211223102350624" style="zoom: 67%;"><h3 id="重发超时如何确定"><a href="#重发超时如何确定" class="headerlink" title="重发超时如何确定"></a>重发超时如何确定</h3><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。</p><p>情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差’。将这个往返时间和偏差相加重发超时的时间，就是比这个总和稍大一点的时间,如下图</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223104036166.png" alt="image-20211223104036166" style="zoom:67%;"><p>在BSD的Unix 以及Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍’。不过，由于最初的数据包还不知道往返时间，所以其重发超时一般设置为6秒左右。</p><p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p><p>此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223104643218.png" alt="image-20211223104643218" style="zoom:67%;"><h3 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h3><p><strong>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值</strong>。下图中,窗口大小为4个段</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223112941083.png" alt="image-20211223112941083" style="zoom: 67%;"><p>如图所示，发送数据中高亮圈起的部分正是前面所提到的窗口。在这个窗口内的数据即便没有收到确认应答也可以发送出去。此外，从该窗口中能看到的数据因其某种数据已在传输中丢失，所以发送端才能收到确认应答，这种情况也需进行重发。为此，<strong>发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据</strong>。</p><p><strong>在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端已收到的数据</strong>。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p><p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也被称为滑动窗口控制。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223135446077.png" alt="image-20211223135446077" style="zoom:67%;"><h3 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a>窗口控制与重发控制</h3><ul><li>确认应答未能及时返回</li></ul><p>首先，我们先考虑确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的。然而，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，就如图所示，某些确认应答即便丢失也无需重发。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223140236249.png" alt="image-20211223140236249" style="zoom:67%;"><p>如上图所示,即使接收端已经接收到了1-1000的数据,并且发送了确认应答1001,但是确认应答在传输的过程中由于种种原因未能到达发送端.这时会继续发送1001-2000数据,接收端收到后会发送确认应答2001,这个如果能成功发送的话则发送端就知道2001前面的数据均成功发送.</p><ul><li>报文丢失的情况</li></ul><p>如图所示。当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回。而<strong>发送端主机如果连续3次收到同一个确认应答</strong>，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。(之所以连续收到3次而不是两次的理由是内为、即使数据段的序号被替换两次也不会触发重发机制。)</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223140933294.png" alt="image-20211223140933294" style="zoom:50%;"><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>发送端根据自己的实际情况发送数据。但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其他问题上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。</p><p>为了防止这种现象的发生，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。该大小限度就被称作窗口大小。在前面所介绍的<strong>窗口大小的值就是由接收端主机决定的</strong>。.<strong>TCP首部中，专门有一个字段用来通知窗口大小</strong>。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20211223143220983.png" alt="image-20211223143220983" style="zoom:67%;"><p>如图所示，当接收端收到从3001号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后，在收到发送窗口更新通知后通信才得以继续进行。如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p><p>TCP为了防止该问题的出现，在通信一开始时就会通过一个叫做<strong>慢启动</strong>的算法得出的数值，对发送数据量进行控制。</p><p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段( 1MSS)’发送数据，之后每收到一次确认应答（ ACK)，拥塞窗口的值就加1。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小那个值，发送比其还要小的数据量。</p><h3 id="提高网络利用率的规范"><a href="#提高网络利用率的规范" class="headerlink" title="提高网络利用率的规范"></a>提高网络利用率的规范</h3><ul><li>Nagle算法</li></ul><p>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。</p><p>①已发送的数据都已经收到确认应答时    ②可以发送最大段长度(MSS)的数据时</p><ul><li>延迟确认应答</li></ul><p>每个段的接收者收到完好的段时都会向发送者回送小的确认分组,如果发送者没有在指定的窗口时间内收到确认信息,发送者就认为分组已经被破坏并重发数据.</p><p>由于确认报文很小,所以tcp允许在发往相同方向的输出数据分组中对其进行”捎带”.为了增加确认报文找到同向传输数据分组的可能性,很多tcp栈都实现了一种”延迟确认”算法,延迟确认算法会在一个特定的窗口时间内将输出的确认存放在缓冲区中,以寻找能够捎带它的输出数据分组,如果在那个时段内没有输出数据分组,就将确认信息放在单独的分组中传送.</p><ul><li>捎带应答</li></ul><h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><p>自治系统（路由选择域)内部动态路由采用的协议是域内路由协议，即 IGP。而自治系统之间的路由控制采用的是域间路由协议，即 EGP。</p><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>路由控制有各种各样的算法，其中最具代表性的有两种，是<strong>距离向量</strong>(Distance-Vector)算法和<strong>链路状态</strong>(Link-State)算法。</p><img src="/2020/11/07/%E5%9B%BE%E8%A7%A3TCP-IP/devApp\myblog\source\_posts\图解TCP-IP\image-20220104131150918.png" alt="image-20220104131150918" style="zoom:50%;"><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解http</title>
      <link href="/2020/11/07/%E5%9B%BE%E8%A7%A3http/"/>
      <url>/2020/11/07/%E5%9B%BE%E8%A7%A3http/</url>
      
        <content type="html"><![CDATA[<p><img src="http%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="http"></p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><img src="D:\devApp\myblog\source\_posts\图解http\image-20220309103307182.png" alt="image-20220309103307182" style="zoom: 67%;"><h2 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手?"></a><strong>为什么三次握手?</strong></h2><p>1.同步序列号</p><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个seq序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值 ISN（初始 seq 序列号）， 并确认对方已经收到了序列号起始值的必经步骤</p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p><p>2.确认收发双发的接收发送能力</p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><img src="D:\devApp\myblog\source\_posts\图解http\image-20220309133148617.png" alt="image-20220309133148617" style="zoom: 50%;"><p>四次挥手过程：<br>第一次挥手<br>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>第二次挥手<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>第三次挥手<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>第四次挥手<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<strong>服务器结束TCP连接的时间要比客户端早一些</strong>。</p><h2 id="为什么四次"><a href="#为什么四次" class="headerlink" title="为什么四次"></a>为什么四次</h2><p>确保数据能够完整传输。<br>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。<br>但未必被动方所有的数据都完整的发送给了主动方，TCP 提供了连接的一端结束他的发送后，还能接收来自另一端数据的能力，也就是所谓的半关闭。所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，（按照常理的话，第二次和第三次挥手应该一起回复FIN=1和ACK=1的，但是因为服务器端可能有数据没发完，所以不能也立刻去主动申请关闭，所以要把ACK和FIN分开）<br>再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><h2 id="为什么要等待2MSL"><a href="#为什么要等待2MSL" class="headerlink" title="为什么要等待2MSL"></a>为什么要等待2MSL</h2><p>MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间</p><p>等2MSL是为了等待在2MSL这段时间中可能出现的服务端FIN超时重传，如果服务端真的需要超时重传，那么一定会在这段时间里进行，反之，若过了这段时间还没有重传，则可以确认ACK被服务端收到了。</p><p>另外一个重要原因理由2，为了保证本连接持续的时间所产生的所有分组都从网络中消失，也就是保证新建立一个TCP连接时，来自该连接老的重复分组都已经在网络中消失了。假设客户端发送ACK刚刚过了一个MSL时间，而服务端在收到这个ACK<strong>之前一瞬间刚好</strong>启动超时重传FIN，所以要等这个FIN也消失，就是2MSL了。</p><h1 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h1><p>​        统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。<br>​        拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。<br>​        现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。<br>​        那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p><p>​        可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：身份证号：1234567来标识他。不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而<strong>URL就是用定位的方式实现的URI</strong>。</p><p>​        回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。<br>​        对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了<a href="https://link.zhihu.com/?target=http://741236985.html">http://741236985.html</a>，那感觉叫成URI更为合适，不过这样子的话还得想办法找到这个资源咯…</p><h1 id="HTTP1-1请求方法"><a href="#HTTP1-1请求方法" class="headerlink" title="HTTP1.1请求方法"></a>HTTP1.1请求方法</h1><p>GET(获取资源)</p><p>POST(传输实体主体)</p><p>HEAD(获取报文头部)</p><p>PUT(传输文件)</p><p>DELETE(删除文件)</p><p>OPTIONS(询问支持的方法)</p><p>TRACE(追踪路径)：用来确认链接过程中发生的一系列操作</p><p>CONNECT(要求用隧道协议连接代理)      CONNECT 代理服务器名:端口号 HTTP版本</p><p><img src="D:\devApp\myblog\source_posts\图解http\image-20201024125744129.png" alt="image-20201024125744129"></p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p><img src="D:\devApp\myblog\source_posts\图解http\image-20201024142856776.png" alt="image-20201024142856776"></p><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>200 ok 表示请求在服务器端被正常处理了</p><p>204 No Content:请求处理成功，但没有资源可以返回。一般在只需要客户端往服务器端发送信息，而服务器端不需要对客户端发送新的信息内容的情况下使用。</p><p>206 Partial Content:该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content- Range指定范围的实体内容。</p><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><p>301 Moved Permanently ：永久性重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p><p>302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的URI,希望用户(本次)能使用新的URI访问。</p><p>303 See Other:该状态码表示由于请求对应的资源存在着另一个URI,<strong>应使用GET方法</strong>定向获取请求的资源。<strong>303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</strong>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另-一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p><p>304 Not Modified :该状态码表示客户端发送附带条件的请求”时，<strong>服务器端允许请求访问资源，但未满足条件的情况</strong>。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在3XX类别中，但是和重定向没有关系。</p><p>307 Temporary Redirect ：临时重定向。</p><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h2><p>400 Bad Request：表示请求报文中存在语法错误</p><p>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证(BASIC认证，DIGEST认证)的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p><p>403 Forbidden：表明请求资源的访问被服务器拒绝了，未获得文件系统的访问授权，访问权限出现某些问题(从未授权的发送源IP地址试图访问)等列举的情况都可能是发生403的原因。</p><p>404 Not Found：服务器上无法找到请求的资源。</p><h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h2><p>500 Internal Server Error：该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p><p>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><p>HTTP主要有这些不足，例举如下<br>●通信使用<strong>明文(不加密)</strong>,内容可能会被窃听<br>●不验证<strong>通信方的身份</strong>，因此有可能遭遇伪装<br>●无法证明<strong>报文的完整性</strong>，所以有可能已遭篡改</p><p>HTTPS：把添加了加密处理和认证等机制的HTTP称为HTTPS。与SSL或TLS组合使用的HTTP被称为HTTPS ( HTTP Secure,超文本传输安全协议)或HTTP over SSL。即通过SSL( Secure Socket Layer,安全套接层)加密HTTP的通信内容。SSL不仅提供加密处理，还是用了一种证书的手段用于确定通信方。还能对报文进行完整性保护。</p><p>HTTPS并非是应用层的一-种新协议。只是HTTP通信接口部分用SSL ( Secure Socket Layer )和TLS ( Transport Layer Security)协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS,其实就是身披SSL协议这层外壳的HTTP。</p><h2 id="两种加密机制"><a href="#两种加密机制" class="headerlink" title="两种加密机制"></a>两种加密机制</h2><h3 id="共享密钥加密"><a href="#共享密钥加密" class="headerlink" title="共享密钥加密"></a>共享密钥加密</h3><p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做<strong>对称密钥加密</strong>。</p><img src="D:\devApp\myblog\source\_posts\图解http\image-20211214141733500.png" alt="image-20211214141733500" style="zoom:33%;"><p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能 安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥 就可会落入攻击者之手，同时也就失去了加密的意义。另外还得 设法安全地保管接收到的密钥。</p><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。顾名思 义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发 布，任何人都可以获得。</p><p>使用公开密钥加密方式，<strong>发送密文的一方使用对方的公开密钥进 行加密处理</strong>，<strong>对方收到被加密的信息后，再使用自己的私有密钥 进行解密</strong>。利用这种方式，不需要发送用来解密的私有密钥，也 不必担心密钥被攻击者窃听而盗走。</p><p>SSL采用一种 叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p><h2 id="HTTPS的加密机制"><a href="#HTTPS的加密机制" class="headerlink" title="HTTPS的加密机制"></a>HTTPS的加密机制</h2><p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</p><p>过程：</p><p>①使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥</p><p>②确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信</p><img src="D:\devApp\myblog\source\_posts\图解http\image-20201026131022322.png" alt="image-20201026131022322" style="zoom:80%;"><h2 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h2><p><img src="D:\devApp\myblog\source_posts\图解http\image-20201026135254930.png" alt="image-20201026135254930"></p><p><img src="D:\devApp\myblog\source_posts\图解http\image-20201026135327753.png" alt="image-20201026135327753"></p><h2 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h2><p>①因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</p><p>SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU<br>及内存等资源，导致处理速度变慢。</p><p>②除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构(CA)购买。</p><h1 id="http-1-0和http-1-1区别"><a href="#http-1-0和http-1-1区别" class="headerlink" title="http/1.0和http/1.1区别"></a>http/1.0和http/1.1区别</h1><h2 id="方法区别"><a href="#方法区别" class="headerlink" title="方法区别"></a>方法区别</h2><img src="D:\devApp\myblog\source\_posts\图解http\image-20211213111503958.png" alt="image-20211213111503958" style="zoom:50%;"><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p><h1 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h1><blockquote><p>若 HTTP 首部字段重复了会如何?</p><p> 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时 会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑 的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的 首部字段，而有些则会优先处理最后出现的首部字段。</p></blockquote><h2 id="端到端首部（End-to-end-Header）"><a href="#端到端首部（End-to-end-Header）" class="headerlink" title="端到端首部（End-to-end Header）"></a>端到端首部（End-to-end Header）</h2><p><strong>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标</strong>，且必 须保存在由缓存生成的响应中，另外规定它必须被转发。</p><h2 id="逐跳首部（Hop-by-hop-Header）"><a href="#逐跳首部（Hop-by-hop-Header）" class="headerlink" title="逐跳首部（Hop-by-hop Header）"></a>逐跳首部（Hop-by-hop Header）</h2><p><strong>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再 转发</strong>。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提 供 Connection 首部字段。</p><p>http/1.1中的逐跳首部字段如下</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><h2 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h2><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>首部字段 Cache-Control 能够控制缓存的行为</p><p><code>Cache-Control: private, max-age=0, no-cache</code></p><h4 id="表示是否能缓存的指令"><a href="#表示是否能缓存的指令" class="headerlink" title="表示是否能缓存的指令"></a>表示是否能缓存的指令</h4><h5 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h5><p>使用 no-cache 指令的目的是为了防止从缓存中返回<strong>过期</strong>的资源。</p><p> 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。 </p><p>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。</p><h5 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a>no-store</h5><p>当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含 机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。</p><h5 id="no-cache和no-store区别"><a href="#no-cache和no-store区别" class="headerlink" title="no-cache和no-store区别"></a>no-cache和no-store区别</h5><p> 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 <strong>no-cache 代表不缓存过期的资源</strong>，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。<strong>no-store 才是真正地不进行缓存</strong>.</p><h4 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h4><h5 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a>max-age</h5><p><code>Cache-Control: max-age=604800（单位：秒）</code></p><p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓 存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。</p><p>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时 间。</p><p>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略</p><h5 id="min-fresh"><a href="#min-fresh" class="headerlink" title="min-fresh"></a>min-fresh</h5><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。 比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。</p><h5 id="max-stale"><a href="#max-stale" class="headerlink" title="max-stale"></a>max-stale</h5><p>使用 max-stale 可指示缓存资源，<strong>即使过期也照常接收</strong>。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p><h5 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h5><p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，<strong>该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout</strong>。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection 首部字段具备如下两个作用。 </p><ul><li>控制不再转发给代理的首部字段 </li></ul><p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。</p><img src="D:\devApp\myblog\source\_posts\图解http\image-20211214132233306.png" alt="image-20211214132233306" style="zoom:50%;"><ul><li>管理持久连接</li></ul><p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。</p><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><img src="D:\devApp\myblog\source\_posts\图解http\image-20211214133110180.png" alt="image-20211214133110180" style="zoom: 50%;"><p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。</p><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使 用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况 下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响 应。</p><h2 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h2><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒 体类型。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><img src="D:\devApp\myblog\source\_posts\图解http\image-20211214133535159.png" alt="image-20211214133535159" style="zoom:33%;"><p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差 异。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><h2 id="为cookie服务的首部字段"><a href="#为cookie服务的首部字段" class="headerlink" title="为cookie服务的首部字段"></a>为cookie服务的首部字段</h2><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p><p><code>Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT</code></p><img src="D:\devApp\myblog\source\_posts\图解http\image-20211214135048935.png" alt="image-20211214135048935" style="zoom: 50%;"><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。XSS全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line"></span><br><span class="line">response.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;uid=112; Path=/; HttpOnly&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h3><p>把<strong>cookie-secure</strong>的值改为了<strong>true</strong>，<strong>true</strong>意味着”<strong>指示浏览器仅通过 HTTPS 连接传回 cookie。这可以确保 cookie ID 是安全的，且仅用于使用 HTTPS 的网站。如果启用此功能，则 HTTP 上的会话 Cookie 将不再起作用。</strong>“</p><h3 id="二级域名之间的-Cookie-共享"><a href="#二级域名之间的-Cookie-共享" class="headerlink" title="二级域名之间的 Cookie 共享"></a>二级域名之间的 Cookie 共享</h3><p>根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的！“</p><p>比如现在有两个二级域名，<code>http://a.xxx.com</code>(域名 A)和<code>http://b.xxx.com</code>(域名 B)。那么域名 A 的登录 Cookie 在域名 B 下可以使用吗？</p><p>答:默认情况下，域名 A 服务主机中生成的 Cookie，只有域名 A 的服务器能拿到，其他域名是拿不到这个 Cookie 的，这就是<strong>仅限主机Cookie</strong>。</p><p>但是服务端可以通过显式地声明 Cookie 的 domian 来定义它的域，如上例子通过<code>Set-Cookie</code>将域名 A 的登录 Cookie 的 domain（域）设置成<code>http://xxx.com</code>（他们<strong>共同的顶级域名</strong>），path 设置成<code>’/’</code>，<code>Set-Cookie： name=value;domain=xxx.com;path=’/’</code>，那么域名 B 便可以读到。</p><p>那如果域名 1 设置<code>Set-Cookie： mykey=myvalue1;domain=e.f.com.cn;path=’/’</code><br>域名 2 设置<code>Set-Cookie： mykey=myvalue2;domain=e.f.com.cn;path=’/’</code><br>那该域下 mykey 的值会被覆盖为 myvalue2，很好理解，同一个域下，Cookie 的 mykey 是唯一的。通常，我们要通过设置正确的 domain 和 path，减少不必要的数据传输,节省带宽。</p><h1 id="用户身份认证"><a href="#用户身份认证" class="headerlink" title="用户身份认证"></a>用户身份认证</h1><h2 id="BASIC-认证-基本认证"><a href="#BASIC-认证-基本认证" class="headerlink" title="BASIC 认证(基本认证)"></a>BASIC 认证(基本认证)</h2><img src="D:\devApp\myblog\source\_posts\图解http\image-20211215094521769.png" alt="image-20211215094521769" style="zoom:50%;"><p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要 任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程 中，如果被人窃听，被盗的可能性极高。</p><h2 id="DIGEST-认证-摘要认证"><a href="#DIGEST-认证-摘要认证" class="headerlink" title="DIGEST 认证(摘要认证)"></a>DIGEST 认证(摘要认证)</h2><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p><code>XSS</code> 全称是 <code>Cross Site Scripting</code>(即<code>跨站脚本</code>)，为了和 CSS 区分，故叫它<code>XSS</code>。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。</p><p>这些操作一般可以完成下面这些事情:</p><ol><li>窃取<code>Cookie</code>。</li><li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li><li>修改 DOM 伪造登录表单。</li><li>在页面中生成浮窗广告。</li></ol><p>通常情况，XSS 攻击的实现有三种方式——<strong>存储型</strong>、<strong>反射型</strong>和<strong>文档型</strong>。原理都比较简单，先来一一介绍一下。</p><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。</p><p>常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中<code>直接执行</code>, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。</p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型XSS指的是恶意脚本作为<strong>网络请求的一部分</strong>。</p><p>比如我输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://sanyuan.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在服务器端会拿到<code>q</code>参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。</p><h3 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h3><p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后<strong>修改里面的 html 文档</strong>！</p><p>这样的劫持方式包括<code>WIFI路由器劫持</code>或者<code>本地恶意软件</code>等。</p><h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><p>1.无论是在前端和服务端，都要对用户的输入进行<strong>转码</strong>或者<strong>过滤</strong>。</p><p>2.利用 HttpOnly.很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p><p>3.利用浏览器的安全策略,比如禁止向其它域提交数据,限制其他域下的资源加载。</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户<strong>目前的登录状态</strong>发起跨站请求。</p><p>举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。那么恭喜你，被攻击了:）</p><p>可能会做三样事情。列举如下：</p><p>1.自动发get请求</p><p>黑客网页里面可能有一段这样的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;&gt;</span><br></pre></td></tr></table></figure><p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 <a href="https://link.zhihu.com/?target=http://xxx.com">http://xxx.com</a> 的 cookie 信息(这里是假定你已经在 <a href="https://link.zhihu.com/?target=http://xxx.com">http://xxx.com</a> 中登录过)。</p><p>假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p><p>2.自动发送post请求</p><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&#x27;hacker-form&#x27; action=&quot;https://xxx.com/info&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hhh&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;hidden&quot; name=&quot;count&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;document.getElementById(&#x27;hacker-form&#x27;).submit();&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p><p>3.诱导点击发送 GET 请求</p><p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://xxx/info?user=hhh&amp;count=100&quot; taget=&quot;_blank&quot;&gt;点击进入修仙世界&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击后，自动发送 get 请求，接下来和<code>自动发 GET 请求</code>部分同理。</p><h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h3><p>1.利用Cookie的SameSite属性</p><p><code>CSRF攻击</code>中重要的一环就是自动发送目标站点下的 <code>Cookie</code>,然后就是这一份 Cookie 模拟了用户的身份。可以对请求中 Cookie 的携带作一些限制，这个字段就是<code>SameSite</code>。</p><p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p><p><strong>a.</strong> 在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</p><p><strong>b.</strong> 在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</p><p><strong>c.</strong> 在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</p><p>2.验证来源站点</p><p>这就需要要用到请求头中的两个字段: <strong>Origin</strong>和<strong>Referer</strong>。</p><p>其中，<strong>Origin</strong>只包含域名信息，而<strong>Referer</strong>包含了<code>具体</code>的 URL 路径。</p><p>当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p><p>3.CSRFToken</p><p>首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。</p><p>然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是<code>CSRF Token</code>，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p><p><code>CSRF</code>攻击一般会有三种方式: - 自动 GET 请求 - 自动 POST 请求 - 诱导点击发送 GET 请求</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记1</title>
      <link href="/2020/09/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/"/>
      <url>/2020/09/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h3 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h3><p>​        在面试题中经常会出现这样一个题目，给一个数组，其中含有N个非负元素，让你求出数组中出现次数超过一半的数字。</p><p>​        看到这个问题我们首先想到的可能是暴力的解法，那就是将数组排个序，输出中间的元素就行了，因为如果出现次数超过一半的话排完序后中间的那个元素肯定是我们需要求的值。</p><p>​        这样做的话排序的时间复杂度一般来说是O(NlogN)，那么有没有时间复杂度为n的算法呢？</p><p>​        投票算法。核心就是<strong>对拼消耗</strong>。</p><p>​        玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。最后能剩下的必定是自己人。（在某乎上看到的通俗解释）</p><p>​        下面进行举例，找出数组中的主要元素，数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>]; <span class="comment">//假设第一个数即为核心元素</span></span><br><span class="line">        <span class="keyword">int</span> account = <span class="number">1</span>;  <span class="comment">//设定一个计数器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==ans)&#123;</span><br><span class="line">                account++; <span class="comment">//如果相等，计数器加一</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                account--;   <span class="comment">//如果不相等，计数器减一</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(account == <span class="number">0</span>)&#123;   <span class="comment">//若计数器等于零，则从下一个数从新开始</span></span><br><span class="line">                ans = nums [i+<span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">                account = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>1、位运算右移一位可代替除以2，左移一位可代替乘2。</p><p>2、对n做右移运算时，一定要考虑到n为负数时的特殊情况。</p><p>3、判断一个数的最后一位是不是1，只需与1做位与运算，若结果为1则最后一位是1，若结果为0则最后一位为0</p><p>4、判断n的奇偶性可以将n和1做位与运算，若结果为1则n为奇数，若结果为0，则n为偶数。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>设置一个pre和cur分别指向前一个节点和当前节点(例如反转链表)</p><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></p><p>由于不能直接获取长度,从而需要遍历才能知道链表的长度,确定哪个是中间节点.</p><p>但是可以转为数学问题,一个快指针,一个慢指针,快指针每次移动两步,慢指针每次移动一步,这样当快指针遍历完之后,慢指针一定指向的是中间节点</p><p>*设置标记,遍历过的节点添加tag属性为true(如判断链表是否有环)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目部署到服务器流程</title>
      <link href="/2020/05/08/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/05/08/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="一-安装JDK"><a href="#一-安装JDK" class="headerlink" title="一 安装JDK"></a>一 安装JDK</h4><h5 id="1-下载64位版本的jdk"><a href="#1-下载64位版本的jdk" class="headerlink" title="1 下载64位版本的jdk"></a>1 下载64位版本的jdk</h5><p>jdk-8u171-linux-x64.tar.gz下载到本地,用xftp传到/usr/local/java中</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2 解压"></a>2 解压</h5><p>tar -xzvf jdk-8u171-linux-x64.tar.gz</p><h5 id="3-配置系统环境变量"><a href="#3-配置系统环境变量" class="headerlink" title="3 配置系统环境变量"></a>3 配置系统环境变量</h5><p>vim /etc/profile  进入对文件的编写，将下面的添加到文件的最后</p><p>JAVA_HOME=/usr/local/java/jdk1.8<br>JRE_HOME=/usr/local/java/jdk1.8/jre<br>PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>export JAVA_HOME JRE_HOME PATH CLASSPATH</p><p>添加后按esc，输入  ：wq   保存并退出编辑。</p><p>source /etc/profile   使配置生效</p><h5 id="4-查看版本"><a href="#4-查看版本" class="headerlink" title="4 查看版本"></a>4 查看版本</h5><p>java -version    查看java版本</p><p>成功！</p><h4 id="二-安装tomcat"><a href="#二-安装tomcat" class="headerlink" title="二 安装tomcat"></a>二 安装tomcat</h4><h5 id="1-下载tomcat"><a href="#1-下载tomcat" class="headerlink" title="1 下载tomcat"></a>1 下载tomcat</h5><p><a href="http://tomcat.apache.org/download-70.cgi">http://tomcat.apache.org/download-70.cgi</a><br>选择core下面的tar.gz包下载</p><h5 id="2上传和安装"><a href="#2上传和安装" class="headerlink" title="2上传和安装"></a>2上传和安装</h5><p>用xftp传到/usr/local/tomcat中</p><h5 id="3-解压"><a href="#3-解压" class="headerlink" title="3 解压"></a>3 解压</h5><p>tar -zxvf apache-tomcat-8.0.33.tar.gz     //解压</p><p>cp -R apache-tomcat-8.0.33 /usr/local/tomcat    //移动和重命名</p><h5 id="4-启动和测试"><a href="#4-启动和测试" class="headerlink" title="4 启动和测试"></a>4 启动和测试</h5><p>./startup.sh  //<strong>在tomcat的bin目录下执行此命令，显示下面的信息</strong></p><p>Using CATALINA_BASE:   /usr/local/tomcat<br>Using CATALINA_HOME:   /usr/local/tomcat<br>Using CATALINA_TMPDIR: /usr/local/tomcat/temp<br>Using JRE_HOME:        /usr/java/jdk1.7.0_67<br>Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar<br>Tomcat started.</p><h5 id="5-设置自动启动"><a href="#5-设置自动启动" class="headerlink" title="5 设置自动启动"></a>5 设置自动启动</h5><p>设置tomcat开机自启</p><p>1、进入编辑<br>vi /etc/rc.d/rc.local<br>2、打开后在最底部复制下面<br>export JDK_HOME=/usr/java/jdk1.6.0_41<br>export JAVA_HOME=/usr/java/jdk1.6.0_41<br>/uer/local/tomcat/bin/startup.sh<br>3、重启服务器，试试能不能访问。<br>Tips:<br>如果JDK和Tomcat安装的目录不跟上面的一样，请修改相应路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装系统后恢复MySQL</title>
      <link href="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/"/>
      <url>/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/</url>
      
        <content type="html"><![CDATA[<p><strong>此方法只有在装MySQL时没有装到C盘中时适用</strong></p><p>本人由于考研加之电脑太垃圾就重装了一下系统，很多东西都需要从新配置，所以遇到很多坑，比如接下来的MySQL！！！！！！！！</p><h4 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1.配置环境变量"></a>1.配置环境变量</h4><p>这个应该都知道</p><p>①. 和其实环境变量的配置方法一样，我们打开环境变量配置窗口（组合键win+Pause -&gt; 更改设置 -&gt; 系统属性里选择“高级” -&gt; 环境变量）</p><p>②. 选中系统变量中的“path”，编辑path值，新建输入mysql安装目录下的bin文件夹所在路径：D:\proApp\MySQL\bin，保存退出</p><p><strong>注意：把上面的路径改为你自己电脑中的安装路径</strong></p><p>但把这个做完后我以为就完成了，自信的在cmd中输入mysql -u root -p，结果报错：启动MySQL报错:ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)</p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/mysql4.jpg"><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/mysql4.jpg" alt="alt"></p><h4 id="2-找到安装MySQL的文件夹中的my-ini文件"><a href="#2-找到安装MySQL的文件夹中的my-ini文件" class="headerlink" title="2.找到安装MySQL的文件夹中的my.ini文件"></a>2.找到安装MySQL的文件夹中的my.ini文件</h4><p>在[mysqld]下更改basedir和datadir。basedir改为MySQL安装的位置，datadir改为MySQL目录下的data文件夹，比如我的。</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql1.jpg"></p><h4 id="3-管理员身份打开cmd安装mysql"><a href="#3-管理员身份打开cmd安装mysql" class="headerlink" title="3.管理员身份打开cmd安装mysql"></a>3.管理员身份打开cmd安装mysql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install mysql</span><br></pre></td></tr></table></figure><p>可能提示已经安装：The service already exists!，由于本机中已经安装了mysql服务，所以没关系，继续！</p><p>启动MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>这时应该已经能成功启动了，是不是很激动！</p><h4 id="4-进入mysql"><a href="#4-进入mysql" class="headerlink" title="4.进入mysql"></a>4.进入mysql</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>这应该每个人都很熟悉，但是别以为成功了，这时你输入密码会发现以前的密码已经失效，接下来就是重设密码。</p><h4 id="5-设置权限认证跳过"><a href="#5-设置权限认证跳过" class="headerlink" title="5.设置权限认证跳过"></a>5.设置权限认证跳过</h4><p>还是在my.ini文件中的[mysqld]下加上 skip-grant-tables，这样就能跳过密码输入，不需要密码就能进入MySQL。</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql2.png"></p><h4 id="6-重启MySQL"><a href="#6-重启MySQL" class="headerlink" title="6.重启MySQL"></a>6.重启MySQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>如图</p><p><img src="/2020/01/02/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E6%81%A2%E5%A4%8DMySQL/proApp\Hexo\fx\source\img\mysql3.jpg"></p><p>重启后， 以 mysql -u root -p 登陆<br>会发现我们可以不需要密码就可以登陆</p><h4 id="7-重设密码"><a href="#7-重设密码" class="headerlink" title="7.重设密码"></a>7.重设密码</h4><h5 id="首先先选择-mysql-数据库"><a href="#首先先选择-mysql-数据库" class="headerlink" title="首先先选择 mysql 数据库"></a>首先先选择 mysql 数据库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><h5 id="然后更新-password"><a href="#然后更新-password" class="headerlink" title="然后更新 password"></a>然后更新 password</h5><p>①.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string = password ( &#x27;新密码&#x27; ) where user = &#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>②.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user  set Password=password(&#x27;新密码&#x27;) where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><h4 id="8-在-my-ini-文件中去掉-加上的-skip-grant-tables，重启-mysql-服务，以新密码登陆就大功告成了！"><a href="#8-在-my-ini-文件中去掉-加上的-skip-grant-tables，重启-mysql-服务，以新密码登陆就大功告成了！" class="headerlink" title="8.在 my.ini 文件中去掉 加上的 skip-grant-tables，重启 mysql 服务，以新密码登陆就大功告成了！"></a>8.在 my.ini 文件中去掉 加上的 skip-grant-tables，重启 mysql 服务，以新密码登陆就大功告成了！</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 重装系统后的坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
